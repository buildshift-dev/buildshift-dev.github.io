{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"blog/","title":"buildshift.dev Blog","text":"<p>Welcome to buildshift.dev! This is where I share hard-won insights about software architecture, cloud infrastructure, and the messy realities of building production systems. Think of it as war stories from the trenches, but with practical code examples and a healthy dose of humor about our shared struggles with distributed systems.</p>"},{"location":"blog/#content-categories","title":"Content Categories","text":""},{"location":"blog/#python-software-architecture","title":"\ud83d\udc0d Python &amp; Software Architecture","text":"<p>Clean Architecture in Python - A complete 16-part series taking you from chaotic scripts to production-ready systems:</p> <p>\ud83c\udfd7\ufe0f Foundation &amp; Setup - From Script to Architecture - Why structure matters from day one - Modern Python Project Setup - Beyond requirements.txt</p> <p>\ud83d\udcd0 Core Architecture Concepts - Domain-Driven Design in Python - Starting with business problems - Clean Architecture Patterns - Keeping business logic pure - Value Objects in Python - Eliminating primitive obsession - Factory Patterns - Building complex objects right - Python Type Hints - Your first line of defense</p> <p>\ud83e\uddea Testing &amp; Quality Assurance - Testing Strategy for Microservices - Building confidence through systematic testing - Code Quality Automation - Pre-commit hooks and CI/CD</p> <p>\ud83d\ude80 Production &amp; Security - Production-Ready Logging - From local debug to AWS CloudWatch - Securing Python Applications - Beyond OWASP - JWT Authentication in AWS - From development to production</p> <p>\u26a1 Deployment &amp; Evolution - FastAPI + Clean Architecture - A match made in heaven - AWS Deployment Patterns - ECS Fargate vs Lambda - Evolving Your Architecture - Patterns for growth - Keeping Your Codebase Tidy - Linters and workspace harmony</p>"},{"location":"blog/#infrastructure-as-code","title":"\u2601\ufe0f Infrastructure as Code","text":"<p>Terraform - Organization, state management, and real-world lessons:</p> <ul> <li>Terraform State Management Best Practices - Don't let state files ruin your day</li> <li>Terraform Project Organization - Building maintainable infrastructure code</li> </ul>"},{"location":"blog/#cloud-cost-architecture","title":"\ud83d\udcb0 Cloud Cost &amp; Architecture","text":"<p>AWS Cost Optimization - The hidden complexities of cloud economics:</p> <ul> <li>The Hidden Complexity of Estimating Cloud Egress Costs - Why egress estimation feels like fortune telling</li> </ul>"},{"location":"blog/#getting-started","title":"\ud83c\udfaf Getting Started","text":"<p>New here? Start with Welcome to buildshift.dev to understand the philosophy and approach behind all the content.</p>"},{"location":"blog/#recent-posts","title":"Recent Posts","text":"<p>All posts are organized by topic above, with the most comprehensive content in the Clean Architecture series. Each post includes working code examples from the buildshift.dev project repositories - no theoretical fluff, just battle-tested patterns from production systems.</p>"},{"location":"blog/#open-source-projects","title":"Open Source Projects","text":"<p>Every blog post is backed by real code in the buildshift.dev GitHub organization:</p> <ul> <li>clean-py - Production-ready Python microservice with Clean Architecture (supports the entire Python series)</li> <li>tf-tutorial - Terraform organization and state management examples</li> <li>aws-egress-estimate - AWS egress cost analysis tool</li> <li>clean-dotnet - Clean Architecture patterns in .NET</li> </ul>"},{"location":"blog/#stay-updated","title":"Stay Updated","text":"<ul> <li>GitHub: Follow @buildshift-dev for repository updates and new project releases</li> <li>RSS: Subscribe to the blog feed for new posts (coming soon)</li> </ul> <p>Questions about the content or want to see a specific topic covered? Check out the GitHub repositories first - the code often tells the full story better than any blog post can.</p>"},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/","title":"Welcome to buildshift.dev","text":"<p>Welcome to the BuildShift development blog! I'm excited to share this new platform where I'll be documenting my journey in serverless architecture, Python development, and the various open-source projects that make up the BuildShift ecosystem.</p>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#what-is-buildshift","title":"What is BuildShift?","text":"<p>BuildShift represents more than just a blog - it's an ecosystem of tools, libraries, and resources designed to help developers build better serverless applications. The name \"BuildShift\" reflects the fundamental transformation happening in how we approach software development:</p> <ul> <li>Build - Creating applications with modern, cloud-native approaches</li> <li>Shift - Moving from traditional architectures to serverless-first solutions</li> </ul>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#the-buildshift-ecosystem","title":"The BuildShift Ecosystem","text":"<p>All BuildShift projects are open-source and available on GitHub. Here's what you can expect to find:</p>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#serverless-tools-templates","title":"\ud83d\ude80 Serverless Tools &amp; Templates","text":"<ul> <li>Production-ready AWS Lambda functions</li> <li>CDK constructs for common patterns</li> <li>Deployment pipeline templates</li> <li>Monitoring and observability tools</li> </ul>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#python-development-utilities","title":"\ud83d\udc0d Python Development Utilities","text":"<ul> <li>AWS SDK helper libraries</li> <li>Testing frameworks for serverless apps</li> <li>Development workflow automation</li> <li>Code quality and formatting tools</li> </ul>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#developer-productivity","title":"\ud83d\udcbb Developer Productivity","text":"<ul> <li>VS Code extensions and configurations</li> <li>Environment setup scripts</li> <li>Documentation templates</li> <li>Best practice guidelines</li> </ul>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#what-to-expect-from-this-blog","title":"What to Expect from This Blog","text":"<p>I'll be covering a wide range of topics, all grounded in real-world experience from building and maintaining BuildShift projects:</p>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#deep-technical-content","title":"Deep Technical Content","text":"<ul> <li>Architecture patterns used in BuildShift repositories</li> <li>Implementation details with code examples</li> <li>Performance optimization lessons learned</li> <li>Cost analysis of different approaches</li> </ul>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#practical-tutorials","title":"Practical Tutorials","text":"<ul> <li>Step-by-step guides using BuildShift tools</li> <li>Integration examples with popular services</li> <li>Troubleshooting common issues</li> <li>Best practices from production deployments</li> </ul>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#project-spotlights","title":"Project Spotlights","text":"<ul> <li>In-depth looks at specific BuildShift repositories</li> <li>Development process and decision-making</li> <li>Community contributions and collaboration</li> <li>Roadmaps and future plans</li> </ul>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#repository-driven-content","title":"Repository-Driven Content","text":"<p>One thing that sets this blog apart is its direct connection to active development work. Every post will reference specific repositories in the BuildShift organization, providing:</p> <ul> <li>Live code examples you can run and modify</li> <li>Real implementation details from production systems  </li> <li>Working solutions to common problems</li> <li>Continuous updates as projects evolve</li> </ul>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#getting-started","title":"Getting Started","text":"<p>If you're new to serverless development or AWS, I recommend starting with these resources:</p> <ol> <li>buildshift.dev/serverless-starter - A minimal serverless application template</li> <li>buildshift.dev/aws-sdk-helpers - Python utilities for AWS development</li> <li>buildshift.dev/cdk-constructs - Reusable infrastructure components</li> </ol>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#join-the-community","title":"Join the Community","text":"<p>BuildShift is built on the principles of open source and knowledge sharing. Here's how you can get involved:</p> <ul> <li>\u2b50 Star repositories that you find useful</li> <li>\ud83d\udc1b Report issues or suggest improvements  </li> <li>\ud83d\udd00 Submit pull requests with your contributions</li> <li>\ud83d\udcac Start discussions about architecture and best practices</li> <li>\ud83d\udce2 Share your own experiences using BuildShift tools</li> </ul>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#whats-coming-next","title":"What's Coming Next","text":"<p>In upcoming posts, I'll be diving into:</p> <ul> <li>\"Serverless Cost Optimization\" - Real numbers from BuildShift projects</li> <li>\"Python Patterns for AWS Lambda\" - Code examples from production systems</li> <li>\"CDK Construct Deep Dive\" - Building reusable infrastructure components</li> <li>\"Monitoring Serverless at Scale\" - Lessons from high-traffic applications</li> </ul>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/05/20/welcome-to-buildshiftdev/#stay-connected","title":"Stay Connected","text":"<ul> <li>RSS Feed: Subscribe to this blog for new post notifications</li> <li>GitHub: Follow @buildshift.dev for repository updates</li> <li>LinkedIn: Connect with me for professional discussions</li> <li>Twitter: Follow for quick updates and industry thoughts</li> </ul> <p>Thanks for joining me on this journey! I'm excited to share what I've learned and look forward to learning from the community as BuildShift grows.</p> <p>Have questions about any BuildShift repositories or suggestions for blog topics? Feel free to reach out - I'd love to hear from you!</p>","tags":["welcome","buildshift","aws","serverless","python","open-source"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/","title":"The Hidden Complexity of Estimating Cloud Egress Costs","text":"<p>This post was inspired by my attempt to build an aws-egress-estimate tool\u2014a project that ultimately proved just how complex and nearly impossible accurate egress estimation truly is.</p> <p>When I first started working with cloud infrastructure, I thought estimating costs would be straightforward. CPU hours, storage, memory\u2014these seemed like simple metrics to track and predict. Then I encountered egress charges, and everything changed. What appeared to be a minor line item in the billing documentation turned into one of the most unpredictable aspects of cloud cost management.</p>","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#why-egress-estimation-feels-like-fortune-telling","title":"Why Egress Estimation Feels Like Fortune Telling","text":"<p>Egress costs represent charges for data leaving your cloud environment. Sounds simple enough, right? The reality is far more nuanced. Unlike compute resources that you provision explicitly, egress happens as a consequence of your architecture, your users' behavior, and the intricate dance between your services.</p> graph LR     subgraph \"Cloud Environment\"         A[Application] --&gt; B[Database]         A --&gt; C[Cache]         A --&gt; D[Storage]     end      A --&gt;|$$$| E[Internet/Users]     A --&gt;|$$$| F[Other Regions]     A --&gt;|$$$| G[External APIs]     D --&gt;|$$$| H[Backup Location]      class A,B,C,D internal     class E,F,G,H egress      classDef internal fill:#4a90e2,stroke:#2c5aa0,stroke-width:2px,color:#fff     classDef egress fill:#e74c3c,stroke:#c0392b,stroke-width:2px,color:#fff <p>The fundamental challenge isn't just about measuring data volume. It's about predicting how data will flow through a system that's constantly evolving. Every new feature, every architectural change, every shift in user behavior can dramatically alter your egress patterns. I've seen teams add what they thought was a minor feature\u2014a new image processing endpoint\u2014only to watch their egress costs triple because they didn't account for CDN cache misses on dynamically generated content.</p>","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#the-interconnection-maze","title":"The Interconnection Maze","text":"<p>Modern cloud architectures rarely exist in isolation. Your typical application might span multiple availability zones, regions, or even cloud providers. Each boundary crossed represents a potential egress charge, and these boundaries aren't always obvious.</p> <p>Consider a seemingly simple microservices architecture. Service A talks to Service B, which queries a database, calls an external API, and returns data to Service A. Now multiply this by dozens of services, add in service mesh sidecars, observability agents, and backup systems. Each connection potentially crosses a billing boundary. The result? A web of data flows that would make even the most patient network engineer reach for a strong coffee.</p> graph TD     subgraph AZ1[Availability Zone 1]         SA[Service A]         SB[Service B]     end      subgraph AZ2[Availability Zone 2]         SC[Service C]         DB[(Database)]     end      subgraph Region2[Region 2]         SD[Service D]         BK[(Backup)]     end      subgraph External         API[External API]         MON[Monitoring]     end      SA -.-&gt;|Free| SB     SA --&gt;|$ Cross-AZ| SC     SB --&gt;|$ Cross-AZ| DB     SC --&gt;|$$$ Cross-Region| SD     DB --&gt;|$$$ Cross-Region| BK     SA --&gt;|$$$ Internet| API     SA --&gt;|$$$ Internet| MON     SB --&gt;|$$$ Internet| MON     SC --&gt;|$$$ Internet| MON      class SA,SB,SC,DB,SD,BK services     class API,MON external      classDef services fill:#27ae60,stroke:#229954,stroke-width:2px,color:#fff     classDef external fill:#e67e22,stroke:#d35400,stroke-width:2px,color:#fff <p>The real kicker is that these interconnections often grow organically. Teams add services, integrate third-party tools, and implement new features without always considering the cumulative effect on data transfer costs. I've worked with companies that discovered their logging infrastructure was generating more egress charges than their actual application traffic. The logs meant to help them save money were quietly draining their budget.</p>","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#the-prediction-paradox","title":"The Prediction Paradox","text":"<p>So, is estimating egress impossible? Not quite, but it requires a different mindset than estimating other cloud resources. You can't simply look at your current usage and multiply by expected growth. Egress patterns are non-linear and often counterintuitive.</p> <p>What you can do is build models based on scenarios and ranges rather than precise predictions. Start by mapping your major data flows\u2014where does data enter your system, how does it move between components, and where does it exit? Look for patterns in your existing traffic. Do you see spikes during certain hours? Are there seasonal variations? Understanding these patterns gives you a baseline, even if it's imperfect.</p> <p>The key is to embrace uncertainty while building in buffers. I typically recommend teams estimate their egress costs in ranges: optimistic, realistic, and pessimistic scenarios. This approach acknowledges the inherent unpredictability while still providing useful guidance for budgeting and architectural decisions.</p>","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#egress-cost-estimation-scenarios","title":"Egress Cost Estimation Scenarios","text":"Scenario Monthly Data Transfer Estimated Cost Key Assumptions Optimistic 500 GB $45 \u2022 High CDN cache hit rate (90%+)\u2022 Minimal cross-region traffic\u2022 Efficient API usage Realistic 2 TB $180 \u2022 Moderate CDN cache hits (70%)\u2022 Some cross-region replication\u2022 Normal monitoring overhead Pessimistic 5 TB $450 \u2022 Poor cache performance (40%)\u2022 Significant cross-region traffic\u2022 Verbose logging/monitoring Worst Case 10 TB $900+ \u2022 Cache failures\u2022 Unoptimized APIs\u2022 Data transfer storms","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#gotchas-that-keep-engineers-up-at-night","title":"Gotchas That Keep Engineers Up at Night","text":"<p>Through years of cloud cost investigations, I've encountered numerous egress-related surprises that teams consistently miss:</p> flowchart LR     subgraph Hidden[\"Hidden Egress Sources\"]         direction TB         DB[Database&lt;br/&gt;Replication]         BK[Backup&lt;br/&gt;Pipeline]         API[API Gateway&lt;br/&gt;Amplification]         LOG[Monitoring &amp;&lt;br/&gt;Logging]         CDN[CDN Cache&lt;br/&gt;Misses]     end      subgraph Impact[\"Cost Impact\"]         direction TB         LOW[\"$ Low&lt;br/&gt;(&lt; $100/mo)\"]         MED[\"$$ Medium&lt;br/&gt;($100-1000/mo)\"]         HIGH[\"$$$ High&lt;br/&gt;(&gt; $1000/mo)\"]     end      DB --&gt; HIGH     BK --&gt; MED     API --&gt; HIGH     LOG --&gt; MED     CDN --&gt; HIGH      class DB,API,CDN highCost     class BK,LOG medCost     class HIGH critical     class MED warning     class LOW normal      classDef highCost fill:#c0392b,stroke:#a93226,stroke-width:2px,color:#fff     classDef medCost fill:#d68910,stroke:#b9770e,stroke-width:2px,color:#fff     classDef critical fill:#922b21,stroke:#7b241c,stroke-width:3px,color:#fff     classDef warning fill:#af601a,stroke:#935116,stroke-width:2px,color:#fff     classDef normal fill:#239b56,stroke:#1e8449,stroke-width:2px,color:#fff <p>The Cross-Region Database Replication Trap: Many teams set up multi-region deployments for reliability without realizing that database replication between regions generates substantial egress charges. That real-time sync keeping your disaster recovery site updated? It's essentially a 24/7 egress generator.</p> <p>The Forgotten Backup Pipeline: Automated backups to external storage or different regions create predictable but often overlooked egress costs. Teams budget for storage but forget about the transfer costs, especially when they implement aggressive backup strategies with multiple daily snapshots.</p> <p>The API Gateway Amplification Effect: Public APIs can become egress multipliers. One external request might trigger dozens of internal service calls, each potentially crossing network boundaries. A popular API endpoint can turn into a significant cost center if the internal data flows aren't optimized.</p> <p>The Monitoring and Logging Vortex: Comprehensive observability is crucial, but shipping logs and metrics to external services or different regions adds up quickly. I've seen cases where verbose logging in production environments generated more egress charges than the actual application serving users.</p> <p>The CDN Cache Miss Penalty: CDNs are supposed to reduce egress costs by serving content from edge locations. But if your cache hit ratio is poor\u2014due to unique query parameters, personalized content, or incorrect cache headers\u2014you might actually increase your egress costs as the CDN repeatedly fetches content from your origin servers.</p>","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#building-a-pragmatic-approach","title":"Building a Pragmatic Approach","text":"<p>Given these challenges, how should teams approach egress estimation? Start with visibility. You can't optimize what you can't measure. Implement comprehensive tagging and use cloud provider tools to track data transfer costs by service, team, and purpose.</p> <p>Next, architect with egress in mind. Colocate chatty services in the same availability zone. Use regional endpoints where possible. Implement smart caching strategies. These decisions, made early, can prevent significant costs down the line.</p> <p>Finally, treat egress costs as a first-class metric in your architecture reviews. When proposing new features or services, include data transfer patterns in the design documentation. Ask questions like: Where will this data come from? Where will it go? How often will this transfer happen?</p>","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#egress-cost-optimization-action-plan","title":"Egress Cost Optimization Action Plan","text":"<ul> <li>[ ] Audit Current Architecture</li> <li>[ ] Map all service-to-service communications</li> <li>[ ] Identify cross-AZ and cross-region traffic</li> <li>[ ] Document external API dependencies</li> <li> <p>[ ] Review backup and replication strategies</p> </li> <li> <p>[ ] Implement Monitoring</p> </li> <li>[ ] Enable detailed billing reports with cost allocation tags</li> <li>[ ] Set up alerts for unusual egress spikes</li> <li>[ ] Create dashboards for data transfer metrics</li> <li> <p>[ ] Track CDN cache hit ratios</p> </li> <li> <p>[ ] Optimize Architecture</p> </li> <li>[ ] Colocate chatty services in same AZ</li> <li>[ ] Implement request batching for external APIs</li> <li>[ ] Configure appropriate CDN cache headers</li> <li> <p>[ ] Review and optimize logging verbosity</p> </li> <li> <p>[ ] Establish Governance</p> </li> <li>[ ] Create data transfer budget per team/service</li> <li>[ ] Include egress estimates in design reviews</li> <li>[ ] Document egress patterns in architecture decisions</li> <li>[ ] Regular quarterly egress cost reviews</li> </ul>","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#the-path-forward","title":"The Path Forward","text":"<p>Estimating egress costs perfectly might be impossible, but that doesn't mean we should throw our hands up in defeat. Like many aspects of distributed systems, it's about managing complexity and uncertainty rather than eliminating them entirely.</p> <p>The teams that succeed are those that acknowledge the challenge, build observable systems, and create feedback loops that allow them to adjust quickly when reality diverges from their estimates. They don't aim for perfect predictions but rather for sustainable architectures that can evolve without creating budget surprises.</p> <p>Cloud egress costs reflect the fundamental complexity of modern distributed systems. By understanding the challenges, recognizing the common pitfalls, and building pragmatic estimation models, we can at least make these costs predictable enough to plan around\u2014even if we can't predict them down to the last byte.</p>","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#resources-and-references","title":"Resources and References","text":"","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#aws-documentation","title":"AWS Documentation","text":"<ul> <li>AWS Data Transfer Pricing - Official AWS pricing for data transfer</li> <li>Understanding Data Transfer Costs - AWS Cost and Usage Report guide</li> <li>VPC Peering and Data Transfer - Understanding VPC peering impacts</li> </ul>","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#cost-optimization-guides","title":"Cost Optimization Guides","text":"<ul> <li>AWS Well-Architected Framework - Cost Optimization Pillar</li> <li>CloudFront Best Practices - CDN optimization strategies</li> </ul>","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#community-resources","title":"Community Resources","text":"<ul> <li>The Duckbill Group's AWS Cost Optimization Tips - Practical insights from cloud economists</li> <li>AWS Cost Optimization Community - AWS re:Post community discussions</li> </ul>","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#tools-and-calculators","title":"Tools and Calculators","text":"<ul> <li>AWS Pricing Calculator - Official AWS cost estimation tool</li> <li>AWS Cost Explorer - Analyze your actual AWS costs</li> <li>VPC Reachability Analyzer - Understand network paths</li> </ul>","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/07/23/the-hidden-complexity-of-estimating-cloud-egress-costs/#related-reading","title":"Related Reading","text":"<ul> <li>\"Cloud FinOps\" by J.R. Storment and Mike Fuller - Comprehensive guide to cloud financial management</li> <li>The Fallacy of Zero-Cost Abstractions in Cloud Services - Werner Vogels' perspectives on distributed systems</li> </ul>","tags":["aws","egress","cost-estimation","cloud-architecture","aws-egress-estimate"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/","title":"From Script to Architecture: Why Your Python Project Needs Structure","text":"<p>Every Python developer has been there. You start with a simple script to solve a problem. Maybe it's processing some data, automating a task, or building a quick API endpoint. The script grows. Features get added. Before you know it, you're staring at a 2,000-line file that nobody wants to touch, let alone understand.</p> <p>I've witnessed this organic growth countless times in production systems. What starts as <code>app.py</code> becomes a tangled web of functions, global variables, and copy-pasted code blocks. The cost of adding new features skyrockets. Bugs become harder to track. Testing? Nearly impossible without running the entire application.</p> <p>The clean-py repository demonstrates how to avoid this trap from day one. It's not about over-engineering; it's about sustainable development practices that scale with your needs.</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#the-real-cost-of-unstructured-code","title":"The Real Cost of Unstructured Code","text":"<p>Let me share a story from a recent consulting engagement. A startup had built their entire e-commerce platform in three Python files: <code>main.py</code>, <code>database.py</code>, and <code>utils.py</code>. The <code>main.py</code> alone was over 5,000 lines. Every developer on the team had a different understanding of how the system worked. Deployment was a prayer. Testing was manual.</p> <p>When they needed to add a new payment provider, what should have been a two-day task turned into a three-week nightmare. The payment logic was scattered across all three files. Database transactions weren't properly managed. Error handling was inconsistent. The team eventually had to freeze feature development for two months to refactor the codebase.</p> <p>This scenario plays out in companies every day. The hidden costs include:</p> <ul> <li>Developer velocity decline: New features take exponentially longer to implement</li> <li>Knowledge silos: Only certain developers understand certain parts of the code</li> <li>Bug multiplication: Fixes in one area break functionality elsewhere</li> <li>Onboarding nightmare: New team members take months to become productive</li> <li>Testing impossibility: Automated testing becomes a pipe dream</li> </ul>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#recognizing-the-warning-signs","title":"Recognizing the Warning Signs","text":"<p>Your Python project needs architectural attention when you notice these symptoms:</p> <p>Code Smells: - Functions with more than 50 lines becoming common - Global variables used for configuration and state - Circular imports forcing creative import strategies - Business logic mixed with database queries and API handlers - Copy-pasted code blocks with slight variations - Comments like \"Don't touch this - it works somehow\"</p> <p>Development Pain Points: - Fear of refactoring because you might break something - Merge conflicts on every pull request - Inability to work on features in parallel - Testing requires the entire application environment - Debugging involves print statements throughout the code</p> <p>Operational Issues: - Deployments require careful coordination - Rolling back changes is risky or impossible - Performance problems are hard to isolate - Monitoring and logging are afterthoughts</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#the-journey-from-script-to-architecture","title":"The Journey from Script to Architecture","text":"<p>The transformation doesn't happen overnight, but it follows a predictable path. Here's how a typical Python project evolves, using our e-commerce platform as an example:</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#stage-1-the-monolithic-script","title":"Stage 1: The Monolithic Script","text":"<pre><code># app.py - Everything in one place\nimport sqlite3\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\nconn = sqlite3.connect('shop.db')\n\n@app.route('/products')\ndef get_products():\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT * FROM products WHERE active = 1\")\n    products = cursor.fetchall()\n    return jsonify(products)\n\n@app.route('/order', methods=['POST'])\ndef create_order():\n    data = request.json\n    # 200 lines of order processing logic here\n    # Including payment processing, inventory updates, emails...\n    return jsonify({\"status\": \"success\"})\n\nif __name__ == '__main__':\n    app.run()\n</code></pre> <p>This works for a prototype, but it's already showing problems. Database connections aren't managed properly. Business logic is mixed with HTTP handling. There's no separation of concerns.</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#stage-2-basic-separation","title":"Stage 2: Basic Separation","text":"<pre><code># models.py\nclass Product:\n    def __init__(self, id, name, price):\n        self.id = id\n        self.name = name\n        self.price = price\n\n# database.py\nimport sqlite3\n\nclass Database:\n    def __init__(self):\n        self.conn = sqlite3.connect('shop.db')\n\n    def get_products(self):\n        cursor = self.conn.cursor()\n        cursor.execute(\"SELECT * FROM products WHERE active = 1\")\n        return cursor.fetchall()\n\n# app.py\nfrom flask import Flask, jsonify\nfrom database import Database\nfrom models import Product\n\napp = Flask(__name__)\ndb = Database()\n\n@app.route('/products')\ndef get_products():\n    products = db.get_products()\n    return jsonify(products)\n</code></pre> <p>Better, but still problematic. The database layer knows about SQL. The models are anemic. The application layer is tightly coupled to Flask.</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#stage-3-clean-architecture-introduction","title":"Stage 3: Clean Architecture Introduction","text":"<p>This is where the real transformation begins. Look at how the clean-py repository structures the same functionality:</p> <pre><code># src/domain/entities/product.py\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nfrom typing import Optional\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: Money\n    sku: str\n    inventory_count: int\n\n    def can_purchase(self, quantity: int) -&gt; bool:\n        \"\"\"Business rule: Can we purchase this quantity?\"\"\"\n        return self.inventory_count &gt;= quantity and quantity &gt; 0\n\n    def calculate_total(self, quantity: int) -&gt; Money:\n        \"\"\"Business logic for price calculation\"\"\"\n        if not self.can_purchase(quantity):\n            raise ValueError(f\"Cannot purchase {quantity} items\")\n        return self.price * quantity\n\n# src/domain/repositories/product_repository.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional\n\nclass ProductRepository(ABC):\n    @abstractmethod\n    async def get_by_id(self, product_id: str) -&gt; Optional[Product]:\n        pass\n\n    @abstractmethod\n    async def get_active_products(self) -&gt; List[Product]:\n        pass\n\n# src/application/use_cases/get_products.py\nclass GetProductsUseCase:\n    def __init__(self, product_repo: ProductRepository):\n        self.product_repo = product_repo\n\n    async def execute(self) -&gt; List[ProductDTO]:\n        products = await self.product_repo.get_active_products()\n        return [ProductDTO.from_domain(p) for p in products]\n\n# src/infrastructure/database/product_repository_impl.py\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nclass ProductRepositoryImpl(ProductRepository):\n    def __init__(self, session: AsyncSession):\n        self.session = session\n\n    async def get_active_products(self) -&gt; List[Product]:\n        result = await self.session.execute(\n            select(ProductModel).where(ProductModel.active == True)\n        )\n        return [model.to_domain() for model in result.scalars()]\n\n# src/presentation/api/products.py\nfrom fastapi import APIRouter, Depends\n\nrouter = APIRouter()\n\n@router.get(\"/products\")\nasync def get_products(\n    use_case: GetProductsUseCase = Depends(get_products_use_case)\n):\n    products = await use_case.execute()\n    return products\n</code></pre> <p>Notice the dramatic differences: - Domain layer contains business rules and entities - Application layer orchestrates use cases - Infrastructure layer handles technical details - Presentation layer manages HTTP concerns - Each layer has clear responsibilities and boundaries</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#benefits-of-structured-architecture","title":"Benefits of Structured Architecture","text":"<p>The investment in architecture pays dividends immediately:</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#1-testability","title":"1. Testability","text":"<p>Each layer can be tested in isolation. Domain logic doesn't need a database. Use cases can be tested with mock repositories. This leads to fast, reliable test suites.</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#2-maintainability","title":"2. Maintainability","text":"<p>When a bug report comes in, you know exactly where to look. Payment issue? Check the payment use case. Database problem? It's isolated to the repository layer.</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#3-flexibility","title":"3. Flexibility","text":"<p>Need to switch from PostgreSQL to MongoDB? Only the infrastructure layer changes. Want to add a GraphQL API alongside REST? Add it to the presentation layer without touching business logic.</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#4-team-scalability","title":"4. Team Scalability","text":"<p>New developers can work on specific layers without understanding the entire system. Frontend developers focus on the presentation layer. Database experts optimize the infrastructure layer. Domain experts refine business rules.</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#5-performance-optimization","title":"5. Performance Optimization","text":"<p>With clear boundaries, performance bottlenecks are easier to identify and fix. You can cache at the appropriate layer, optimize database queries without touching business logic, and add async processing where it makes sense.</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#the-path-forward","title":"The Path Forward","text":"<p>Transitioning from script to architecture doesn't mean throwing away your existing code. It's about gradually introducing structure:</p> <ol> <li>Start with the domain: Identify your core business entities and rules</li> <li>Extract use cases: Move business workflows into dedicated classes</li> <li>Abstract infrastructure: Hide database and external service details behind interfaces</li> <li>Separate presentation: Keep HTTP/API concerns in their own layer</li> <li>Add tests: Each refactoring step should be backed by tests</li> </ol> <p>The clean-py repository provides a complete example of this architecture in action. It demonstrates patterns that work in production, from simple CRUD operations to complex business workflows.</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#conclusion","title":"Conclusion","text":"<p>The evolution from script to architecture is a journey every successful Python project must take. The question isn't whether you need structure, but when you'll introduce it. Starting with good architecture from day one isn't over-engineering; it's professional software development.</p> <p>In the next post, we'll dive deep into setting up a Python project with modern tooling, going beyond simple requirements.txt files to create a professional development environment that supports your architectural goals.</p> <p>Remember: Architecture isn't about complexity. It's about managing complexity. Your future self, your team, and your users will thank you for the investment.</p>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#references-and-further-reading","title":"References and Further Reading","text":"","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#project-repository","title":"Project Repository","text":"<ul> <li>Clean-Py Repository - Complete implementation of Clean Architecture in Python</li> <li>Project Documentation - Detailed patterns and guides</li> </ul>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#books-and-articles","title":"Books and Articles","text":"<ul> <li>Clean Architecture by Robert C. Martin - The definitive guide to Clean Architecture</li> <li>Domain-Driven Design by Eric Evans - Essential reading for understanding domain modeling</li> <li>Architecture Patterns with Python - Free online book on Python architecture patterns</li> </ul>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#python-resources","title":"Python Resources","text":"<ul> <li>PEP 8 - Style Guide for Python Code - Python coding conventions</li> <li>Real Python - Application Layouts - Guide to Python project structures</li> <li>Python Packaging Guide - Official Python packaging documentation</li> </ul>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/22/from-script-to-architecture---why-your-python-project-needs-structure/#related-blog-posts-in-this-series","title":"Related Blog Posts in This Series","text":"<ul> <li>Setting Up a Python Project Like a Pro - Modern Python project setup</li> <li>Domain-Driven Design in Python - DDD patterns in Python</li> <li>Clean Architecture in Python - Implementing Clean Architecture</li> </ul>","tags":["python","clean-architecture","software-design","clean-py","project-structure"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/","title":"Setting Up a Python Project Like a Pro: Beyond requirements.txt","text":"<p>The difference between a hobby project and a production-ready application often comes down to the boring stuff: project setup, dependency management, and development workflows. I've seen too many Python projects fail not because of bad code, but because of poor project infrastructure.</p> <p>When I review Python projects, I can immediately tell which ones will scale and which ones will become maintenance nightmares. The secret isn't in the application code\u2014it's in the foundation. The clean-py repository demonstrates what a professional Python setup looks like in practice.</p> <p>Let's build a Python project setup that your future self will thank you for.</p>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#the-problem-with-traditional-python-setup","title":"The Problem with Traditional Python Setup","text":"<p>Most Python tutorials teach you to create a <code>requirements.txt</code> file and call it a day. This approach works for simple scripts, but it falls apart quickly in real projects:</p> <pre><code># The traditional way\npip install flask sqlalchemy pytest\npip freeze &gt; requirements.txt\n</code></pre> <p>This creates several problems: - No separation between development and production dependencies - Version conflicts between projects on the same machine - Dependency resolution happens at install time, not declaration time - No metadata about the project itself - No standard way to run common tasks</p> <p>I once inherited a project with a 200-line <code>requirements.txt</code> file. Nobody knew which dependencies were actually needed. Updating any package was a game of Russian roulette. The development setup instructions were a 3-page Word document that was always out of date.</p>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#modern-python-project-structure","title":"Modern Python Project Structure","text":"<p>Here's what a professional Python project structure looks like:</p> <pre><code>clean-py/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 clean_py/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 domain/\n\u2502       \u251c\u2500\u2500 application/\n\u2502       \u251c\u2500\u2500 infrastructure/\n\u2502       \u2514\u2500\u2500 presentation/\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 unit/\n\u2502   \u251c\u2500\u2500 integration/\n\u2502   \u2514\u2500\u2500 e2e/\n\u251c\u2500\u2500 docs/\n\u251c\u2500\u2500 scripts/\n\u251c\u2500\u2500 .github/\n\u2502   \u2514\u2500\u2500 workflows/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 .pre-commit-config.yaml\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .env.example\n\u2514\u2500\u2500 README.md\n</code></pre> <p>Each component serves a specific purpose. Let's explore the critical ones.</p>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#pyprojecttoml-the-modern-way","title":"pyproject.toml: The Modern Way","text":"<p>The <code>pyproject.toml</code> file is Python's answer to <code>package.json</code> in Node.js or <code>Cargo.toml</code> in Rust. It centralizes project configuration, dependencies, and metadata:</p> <pre><code>[build-system]\nrequires = [\"setuptools&gt;=68.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"clean-py\"\nversion = \"1.0.0\"\ndescription = \"Production-ready Python microservice with Clean Architecture\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.11\"\nlicense = {text = \"MIT\"}\nauthors = [{name = \"Your Name\", email = \"you@example.com\"}]\nkeywords = [\"clean-architecture\", \"ddd\", \"microservice\", \"fastapi\"]\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n]\n\ndependencies = [\n    \"fastapi&gt;=0.104.0\",\n    \"uvicorn[standard]&gt;=0.24.0\",\n    \"sqlalchemy&gt;=2.0.0\",\n    \"asyncpg&gt;=0.29.0\",\n    \"pydantic&gt;=2.5.0\",\n    \"pydantic-settings&gt;=2.1.0\",\n    \"python-jose[cryptography]&gt;=3.3.0\",\n    \"passlib[bcrypt]&gt;=1.7.4\",\n    \"python-multipart&gt;=0.0.6\",\n    \"httpx&gt;=0.25.0\",\n    \"redis&gt;=5.0.0\",\n    \"structlog&gt;=23.2.0\",\n    \"python-json-logger&gt;=2.0.7\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest&gt;=7.4.0\",\n    \"pytest-asyncio&gt;=0.21.0\",\n    \"pytest-cov&gt;=4.1.0\",\n    \"pytest-env&gt;=1.1.0\",\n    \"pytest-mock&gt;=3.12.0\",\n    \"black&gt;=23.11.0\",\n    \"ruff&gt;=0.1.0\",\n    \"mypy&gt;=1.7.0\",\n    \"pre-commit&gt;=3.5.0\",\n    \"ipython&gt;=8.17.0\",\n    \"ipdb&gt;=0.13.13\",\n    \"factory-boy&gt;=3.3.0\",\n    \"faker&gt;=20.0.0\",\n]\n\naws = [\n    \"boto3&gt;=1.29.0\",\n    \"watchtower&gt;=3.0.0\",\n]\n\n[project.urls]\nHomepage = \"https://github.com/buildshift-dev/clean-py\"\nDocumentation = \"https://github.com/buildshift-dev/clean-py/docs\"\nRepository = \"https://github.com/buildshift-dev/clean-py\"\nIssues = \"https://github.com/buildshift-dev/clean-py/issues\"\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n\n[tool.setuptools.package-data]\n\"*\" = [\"*.yaml\", \"*.yml\", \"*.json\", \"*.txt\"]\n\n[tool.black]\nline-length = 88\ntarget-version = ['py311']\ninclude = '\\.pyi?$'\n\n[tool.ruff]\ntarget-version = \"py311\"\nline-length = 88\nselect = [\n    \"E\",  # pycodestyle errors\n    \"W\",  # pycodestyle warnings\n    \"F\",  # pyflakes\n    \"I\",  # isort\n    \"B\",  # flake8-bugbear\n    \"C4\",  # flake8-comprehensions\n    \"UP\",  # pyupgrade\n    \"ARG\",  # flake8-unused-arguments\n    \"SIM\",  # flake8-simplify\n]\nignore = [\n    \"E501\",  # line too long (handled by black)\n    \"B008\",  # do not perform function calls in argument defaults\n    \"C901\",  # too complex\n]\n\n[tool.mypy]\npython_version = \"3.11\"\nwarn_return_any = true\nwarn_unused_configs = true\ndisallow_untyped_defs = true\ndisallow_any_unimported = false\nno_implicit_optional = true\ncheck_untyped_defs = true\nshow_error_codes = true\nwarn_unused_ignores = true\n\n[tool.pytest.ini_options]\nminversion = \"7.0\"\ntestpaths = [\"tests\"]\npython_files = \"test_*.py\"\npython_classes = \"Test*\"\npython_functions = \"test_*\"\naddopts = \"\"\"\n    --strict-markers\n    --tb=short\n    --cov=src\n    --cov-branch\n    --cov-report=term-missing\n    --cov-report=html\n    --cov-report=xml\n    --no-cov-on-fail\n\"\"\"\nasyncio_mode = \"auto\"\n\n[tool.coverage.run]\nsource = [\"src\"]\nomit = [\"*/tests/*\", \"*/test_*.py\"]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise AssertionError\",\n    \"raise NotImplementedError\",\n    \"if __name__ == .__main__.:\",\n    \"if TYPE_CHECKING:\",\n]\n</code></pre> <p>This single file replaces multiple configuration files and provides: - Project metadata and description - Production and development dependencies - Tool configurations (Black, Ruff, MyPy, Pytest, Coverage) - Build system configuration</p>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#makefile-cross-platform-task-automation","title":"Makefile: Cross-Platform Task Automation","text":"<p>While Python has various task runners, Make remains the most universal. Here's a production-ready Makefile:</p> <pre><code>.PHONY: help\nhelp: ## Show this help message\n    @echo \"Usage: make [target]\"\n    @echo \"\"\n    @echo \"Available targets:\"\n    @grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = \":.*?## \"}; {printf \"  %-20s %s\\n\", $$1, $$2}'\n\n.PHONY: install\ninstall: ## Install project in development mode\n    pip install -e \".[dev]\"\n    pre-commit install\n\n.PHONY: install-prod\ninstall-prod: ## Install production dependencies only\n    pip install -e .\n\n.PHONY: update\nupdate: ## Update dependencies to latest versions\n    pip install --upgrade pip setuptools wheel\n    pip install --upgrade -e \".[dev]\"\n\n.PHONY: format\nformat: ## Format code with black and ruff\n    black src tests\n    ruff check --fix src tests\n\n.PHONY: lint\nlint: ## Run all linting checks\n    black --check src tests\n    ruff check src tests\n    mypy src\n\n.PHONY: test\ntest: ## Run unit tests\n    pytest tests/unit -v\n\n.PHONY: test-integration\ntest-integration: ## Run integration tests\n    pytest tests/integration -v\n\n.PHONY: test-all\ntest-all: ## Run all tests with coverage\n    pytest tests -v --cov=src --cov-report=term-missing\n\n.PHONY: test-watch\ntest-watch: ## Run tests in watch mode\n    ptw tests -- -v\n\n.PHONY: clean\nclean: ## Clean up generated files\n    rm -rf dist build *.egg-info\n    find . -type d -name __pycache__ -exec rm -rf {} +\n    find . -type f -name \"*.pyc\" -delete\n    rm -rf .coverage htmlcov .pytest_cache .mypy_cache .ruff_cache\n\n.PHONY: build\nbuild: clean ## Build distribution packages\n    python -m build\n\n.PHONY: docker-build\ndocker-build: ## Build Docker image\n    docker build -t clean-py:latest .\n\n.PHONY: docker-run\ndocker-run: ## Run application in Docker\n    docker-compose up\n\n.PHONY: db-upgrade\ndb-upgrade: ## Apply database migrations\n    alembic upgrade head\n\n.PHONY: db-migrate\ndb-migrate: ## Create new migration\n    alembic revision --autogenerate -m \"$(message)\"\n\n.PHONY: run\nrun: ## Run the application locally\n    uvicorn src.clean_py.presentation.api.main:app --reload --port 8000\n\n.PHONY: run-prod\nrun-prod: ## Run the application in production mode\n    uvicorn src.clean_py.presentation.api.main:app --host 0.0.0.0 --port 8000 --workers 4\n\n.PHONY: security-check\nsecurity-check: ## Run security checks\n    pip-audit\n    bandit -r src\n    safety check\n\n.PHONY: docs\ndocs: ## Generate documentation\n    mkdocs build\n\n.PHONY: docs-serve\ndocs-serve: ## Serve documentation locally\n    mkdocs serve\n</code></pre> <p>Now developers can run consistent commands regardless of their environment: <pre><code>make install        # Setup development environment\nmake test          # Run tests\nmake lint          # Check code quality\nmake run           # Start the application\n</code></pre></p>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#pre-commit-hooks-quality-gates-at-commit-time","title":"Pre-commit Hooks: Quality Gates at Commit Time","text":"<p>Pre-commit hooks catch issues before they enter your repository. Here's a comprehensive configuration:</p> <pre><code># .pre-commit-config.yaml\ndefault_language_version:\n  python: python3.11\n\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.5.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-json\n      - id: check-toml\n      - id: check-added-large-files\n        args: ['--maxkb=1000']\n      - id: check-case-conflict\n      - id: check-merge-conflict\n      - id: detect-private-key\n      - id: debug-statements\n      - id: mixed-line-ending\n        args: ['--fix=lf']\n\n  - repo: https://github.com/psf/black\n    rev: 23.11.0\n    hooks:\n      - id: black\n        language_version: python3.11\n\n  - repo: https://github.com/charliermarsh/ruff-pre-commit\n    rev: v0.1.6\n    hooks:\n      - id: ruff\n        args: [--fix, --exit-non-zero-on-fix]\n\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.7.1\n    hooks:\n      - id: mypy\n        additional_dependencies: [types-all]\n        args: [--strict, --ignore-missing-imports]\n\n  - repo: https://github.com/PyCQA/bandit\n    rev: 1.7.5\n    hooks:\n      - id: bandit\n        args: ['-r', 'src', '-ll']\n        exclude: tests/\n\n  - repo: https://github.com/pycqa/isort\n    rev: 5.12.0\n    hooks:\n      - id: isort\n        args: [\"--profile\", \"black\"]\n\n  - repo: https://github.com/asottile/pyupgrade\n    rev: v3.15.0\n    hooks:\n      - id: pyupgrade\n        args: [--py311-plus]\n\n  - repo: local\n    hooks:\n      - id: pytest-check\n        name: pytest-check\n        entry: pytest\n        language: system\n        pass_filenames: false\n        always_run: true\n        args: [tests/unit, --tb=short, -q]\n</code></pre> <p>Install pre-commit hooks with: <pre><code>pre-commit install\n</code></pre></p> <p>Now every commit automatically: - Formats code with Black - Checks for linting issues with Ruff - Verifies type hints with MyPy - Scans for security issues with Bandit - Runs unit tests - Fixes common issues (trailing whitespace, line endings)</p>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#environment-management","title":"Environment Management","text":"<p>Professional projects separate configuration from code. Here's how to handle environments properly:</p> <pre><code># .env.example\n# Application\nAPP_NAME=clean-py\nAPP_ENV=development\nDEBUG=true\nLOG_LEVEL=DEBUG\n\n# Database\nDATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/cleanpy\nDATABASE_POOL_SIZE=20\nDATABASE_MAX_OVERFLOW=10\n\n# Redis\nREDIS_URL=redis://localhost:6379/0\n\n# Security\nSECRET_KEY=your-secret-key-here-change-in-production\nJWT_ALGORITHM=HS256\nJWT_EXPIRATION_MINUTES=30\n\n# AWS (Production)\nAWS_REGION=us-east-1\nAWS_ACCESS_KEY_ID=\nAWS_SECRET_ACCESS_KEY=\n\n# External Services\nPAYMENT_API_KEY=\nEMAIL_SERVICE_API_KEY=\n</code></pre> <p>Use <code>pydantic-settings</code> for type-safe configuration:</p> <pre><code># src/clean_py/infrastructure/config.py\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\nfrom functools import lru_cache\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        case_sensitive=False,\n    )\n\n    # Application\n    app_name: str = \"clean-py\"\n    app_env: str = \"development\"\n    debug: bool = False\n    log_level: str = \"INFO\"\n\n    # Database\n    database_url: str\n    database_pool_size: int = 20\n    database_max_overflow: int = 10\n\n    # Redis\n    redis_url: str = \"redis://localhost:6379/0\"\n\n    # Security\n    secret_key: str\n    jwt_algorithm: str = \"HS256\"\n    jwt_expiration_minutes: int = 30\n\n    # AWS\n    aws_region: str = \"us-east-1\"\n    aws_access_key_id: str | None = None\n    aws_secret_access_key: str | None = None\n\n    @property\n    def is_production(self) -&gt; bool:\n        return self.app_env == \"production\"\n\n    @property\n    def is_development(self) -&gt; bool:\n        return self.app_env == \"development\"\n\n@lru_cache()\ndef get_settings() -&gt; Settings:\n    return Settings()\n</code></pre>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#dependency-management-best-practices","title":"Dependency Management Best Practices","text":"<p>Managing dependencies properly prevents many production issues:</p>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#1-pin-direct-dependencies-not-transitive-ones","title":"1. Pin Direct Dependencies, Not Transitive Ones","text":"<pre><code># Good - pin direct dependencies with minimum versions\ndependencies = [\n    \"fastapi&gt;=0.104.0\",\n    \"sqlalchemy&gt;=2.0.0\",\n]\n\n# Bad - pinning exact versions of everything\ndependencies = [\n    \"fastapi==0.104.1\",\n    \"sqlalchemy==2.0.23\",\n    \"starlette==0.27.0\",  # This is a fastapi dependency\n]\n</code></pre>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#2-separate-production-and-development-dependencies","title":"2. Separate Production and Development Dependencies","text":"<pre><code># Install for development\npip install -e \".[dev]\"\n\n# Install for production\npip install -e .\n\n# Install with specific extras\npip install -e \".[aws,monitoring]\"\n</code></pre>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#3-use-lock-files-for-reproducible-builds","title":"3. Use Lock Files for Reproducible Builds","text":"<pre><code># Generate lock file\npip freeze &gt; requirements-lock.txt\n\n# Or use pip-tools\npip-compile pyproject.toml -o requirements.txt\npip-compile --extra dev pyproject.toml -o requirements-dev.txt\n</code></pre>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#4-regular-dependency-updates","title":"4. Regular Dependency Updates","text":"<pre><code># Check for outdated packages\npip list --outdated\n\n# Update all packages\npip install --upgrade -e \".[dev]\"\n\n# Security audit\npip-audit\nsafety check\n</code></pre>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#virtual-environment-management","title":"Virtual Environment Management","text":"<p>Always use virtual environments. Here are the modern approaches:</p>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#using-venv-built-in","title":"Using venv (Built-in)","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate  # Unix/MacOS\n.venv\\Scripts\\activate     # Windows\n</code></pre>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#using-pyenv-pyenv-virtualenv","title":"Using pyenv + pyenv-virtualenv","text":"<pre><code>pyenv install 3.11.6\npyenv virtualenv 3.11.6 clean-py\npyenv local clean-py\n</code></pre>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#using-poetry-alternative","title":"Using Poetry (Alternative)","text":"<pre><code>poetry new clean-py\npoetry add fastapi sqlalchemy\npoetry install\npoetry shell\n</code></pre>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#continuous-integration-setup","title":"Continuous Integration Setup","text":"<p>Your project setup should include CI/CD from day one:</p> <pre><code># .github/workflows/ci.yml\nname: CI\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"3.11\", \"3.12\"]\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Cache dependencies\n        uses: actions/cache@v3\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('pyproject.toml') }}\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -e \".[dev]\"\n\n      - name: Run linting\n        run: make lint\n\n      - name: Run tests\n        run: make test-all\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n        with:\n          file: ./coverage.xml\n</code></pre>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#project-documentation","title":"Project Documentation","text":"<p>Good setup includes documentation structure:</p> <pre><code># README.md\n\n# Clean-Py: Production-Ready Python Microservice\n\n[![CI](https://github.com/buildshift-dev/clean-py/actions/workflows/ci.yml/badge.svg)](https://github.com/buildshift-dev/clean-py/actions)\n[![Coverage](https://codecov.io/gh/buildshift-dev/clean-py/branch/main/graph/badge.svg)](https://codecov.io/gh/buildshift-dev/clean-py)\n[![Python Version](https://img.shields.io/badge/python-3.11%2B-blue)](https://www.python.org/downloads/)\n\n## Quick Start\n\n### Prerequisites\n- Python 3.11+\n- PostgreSQL 14+\n- Redis 6+\n\n### Installation\n\\`\\`\\`bash\n# Clone the repository\ngit clone https://github.com/buildshift-dev/clean-py.git\ncd clean-py\n\n# Create virtual environment\npython -m venv .venv\nsource .venv/bin/activate\n\n# Install dependencies\nmake install\n\n# Copy environment variables\ncp .env.example .env\n\n# Run migrations\nmake db-upgrade\n\n# Start the application\nmake run\n\\`\\`\\`\n\n### Development\n\\`\\`\\`bash\n# Run tests\nmake test\n\n# Format code\nmake format\n\n# Run linting\nmake lint\n\n# Build Docker image\nmake docker-build\n\\`\\`\\`\n\n## Project Structure\n\\`\\`\\`\nsrc/clean_py/\n\u251c\u2500\u2500 domain/          # Business logic and entities\n\u251c\u2500\u2500 application/     # Use cases and application services  \n\u251c\u2500\u2500 infrastructure/  # External services and persistence\n\u2514\u2500\u2500 presentation/    # API and UI layers\n\\`\\`\\`\n\n## Contributing\nSee [CONTRIBUTING.md](CONTRIBUTING.md) for development guidelines.\n\n## License\nMIT License - see [LICENSE](LICENSE) for details.\n</code></pre>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#conclusion","title":"Conclusion","text":"<p>Professional Python project setup is about more than just organizing files. It's about creating a foundation that supports your team's productivity, maintains code quality, and scales with your application's growth.</p> <p>The setup we've covered here\u2014from <code>pyproject.toml</code> to pre-commit hooks to Makefiles\u2014might seem like overkill for a small project. But these patterns pay dividends as your project grows. They're the difference between a project that's a joy to work on and one that everyone avoids.</p> <p>In the next post, we'll explore Domain-Driven Design in Python, showing how to model complex business logic in a way that's both powerful and maintainable. We'll see how proper project setup enables architectural patterns that would be impossible in a poorly structured codebase.</p> <p>Start with the right foundation. Your future self and your team will thank you.</p>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/05/25/setting-up-a-python-project-like-a-pro---beyond-requirementstxt/#references","title":"References","text":"<ul> <li>Clean-Py Repository - Complete project setup example</li> <li>PEP 621 - pyproject.toml - Modern Python project metadata</li> <li>Pre-commit Framework - Git hooks for code quality</li> <li>Ruff Documentation - Fast Python linter and formatter</li> </ul>","tags":["python","project-setup","pyproject-toml","clean-py","development-workflow"]},{"location":"blog/2025/06/02/domain-driven-design-in-python---more-than-just-folders/","title":"Domain-Driven Design in Python: More Than Just Folders","text":"<p>Domain-Driven Design changed how I write software. Not because it gave me new technical patterns, but because it taught me to think differently about code. Instead of starting with database schemas or API endpoints, I now start with the business problem.</p> <p>The clean-py repository demonstrates DDD in action, showing how Python's features naturally support domain modeling. This isn't about forcing Java patterns into Python\u2014it's about leveraging Python's strengths to express business concepts clearly.</p>","tags":["ddd","domain-driven-design","python","clean-py","business-logic"]},{"location":"blog/2025/06/02/domain-driven-design-in-python---more-than-just-folders/#understanding-domain-driven-design","title":"Understanding Domain-Driven Design","text":"<p>Eric Evans introduced Domain-Driven Design in his seminal book, but the core idea is simple: software should reflect the business it serves. The code should speak the same language as domain experts. When a business person describes a process, developers should be able to point to corresponding code that mirrors that description.</p> <p>I learned this lesson the hard way. Early in my career, I built an inventory management system where the code was full of technical terms: <code>record</code>, <code>data_object</code>, <code>manager</code>, <code>processor</code>. When bugs arose, conversations with warehouse managers were painful translations between their world and mine. We were speaking different languages about the same system.</p>","tags":["ddd","domain-driven-design","python","clean-py","business-logic"]},{"location":"blog/2025/06/02/domain-driven-design-in-python---more-than-just-folders/#the-ubiquitous-language","title":"The Ubiquitous Language","text":"<p>The foundation of DDD is establishing a common language between developers and domain experts. This isn't just documentation\u2014it's the actual names used in code.</p> <p>Consider an e-commerce system. The business talks about: - Customers placing orders - Orders containing products - Inventory tracking stock levels - Payments processing transactions</p> <p>Your code should mirror this exactly:</p> <pre><code># Bad - Technical language\nclass UserRecord:\n    def create_transaction(self, item_ids: List[int]) -&gt; TransactionObject:\n        pass\n\n# Good - Business language\nclass Customer:\n    def place_order(self, products: List[Product]) -&gt; Order:\n        pass\n</code></pre> <p>The clean-py repository demonstrates this throughout. Look at the domain layer\u2014every class name, method, and variable reflects business terminology.</p>","tags":["ddd","domain-driven-design","python","clean-py","business-logic"]},{"location":"blog/2025/06/02/domain-driven-design-in-python---more-than-just-folders/#identifying-bounded-contexts","title":"Identifying Bounded Contexts","text":"<p>Real businesses aren't monoliths, and neither should your domain model be. Bounded contexts are boundaries within which a particular model applies. The same real-world concept might have different meanings in different contexts.</p> <p>Take the concept of \"Product\": - Catalog Context: Products have descriptions, images, categories - Inventory Context: Products have stock levels, warehouse locations - Pricing Context: Products have prices, discounts, tax rates - Shipping Context: Products have weight, dimensions, hazmat flags</p> <p>Trying to create one \"Product\" class for all contexts leads to a bloated, confusing model. Instead, each context has its own representation:</p> <pre><code># src/catalog/domain/product.py\n@dataclass\nclass CatalogProduct:\n    id: ProductId\n    name: str\n    description: str\n    images: List[ProductImage]\n    categories: List[Category]\n\n    def update_description(self, new_description: str) -&gt; None:\n        if len(new_description) &lt; 10:\n            raise ValueError(\"Description too short\")\n        self.description = new_description\n\n# src/inventory/domain/product.py\n@dataclass\nclass InventoryProduct:\n    sku: SKU\n    quantity_on_hand: int\n    reorder_point: int\n    warehouse_location: Location\n\n    def needs_reorder(self) -&gt; bool:\n        return self.quantity_on_hand &lt;= self.reorder_point\n\n    def receive_shipment(self, quantity: int) -&gt; None:\n        if quantity &lt;= 0:\n            raise ValueError(\"Quantity must be positive\")\n        self.quantity_on_hand += quantity\n\n# src/pricing/domain/product.py\n@dataclass\nclass PricedProduct:\n    id: ProductId\n    base_price: Money\n    tax_category: TaxCategory\n    active_discounts: List[Discount]\n\n    def calculate_price(self, quantity: int, customer: Customer) -&gt; Money:\n        price = self.base_price * quantity\n        for discount in self.active_discounts:\n            if discount.applies_to(customer):\n                price = discount.apply(price)\n        return price\n</code></pre> <p>Each model is focused and cohesive. The catalog team can work on product descriptions without worrying about inventory. The pricing team can adjust discount logic without touching shipping calculations.</p>","tags":["ddd","domain-driven-design","python","clean-py","business-logic"]},{"location":"blog/2025/06/02/domain-driven-design-in-python---more-than-just-folders/#building-rich-domain-models","title":"Building Rich Domain Models","text":"<p>Python developers often create anemic models\u2014data containers with no behavior. DDD advocates for rich models that encapsulate both data and business logic.</p> <p>Here's an anemic model:</p> <pre><code># Anemic - Just data, no behavior\n@dataclass\nclass Order:\n    id: str\n    customer_id: str\n    items: List[dict]\n    total: float\n    status: str\n    created_at: datetime\n\n# Business logic scattered in services\nclass OrderService:\n    def add_item(self, order: Order, item: dict) -&gt; None:\n        order.items.append(item)\n        order.total = sum(i['price'] * i['quantity'] for i in order.items)\n\n    def cancel_order(self, order: Order) -&gt; None:\n        if order.status == 'shipped':\n            raise Exception(\"Cannot cancel shipped order\")\n        order.status = 'cancelled'\n</code></pre> <p>Here's a rich domain model:</p> <pre><code># Rich model - Encapsulates business logic\nclass Order:\n    def __init__(self, order_id: OrderId, customer: Customer):\n        self._id = order_id\n        self._customer = customer\n        self._items: List[OrderItem] = []\n        self._status = OrderStatus.PENDING\n        self._created_at = datetime.utcnow()\n        self._events: List[DomainEvent] = []\n\n    def add_item(self, product: Product, quantity: int) -&gt; None:\n        \"\"\"Add item to order with business rule validation.\"\"\"\n        if self._status != OrderStatus.PENDING:\n            raise OrderException(\"Cannot modify confirmed order\")\n\n        if quantity &lt;= 0:\n            raise OrderException(\"Quantity must be positive\")\n\n        if not product.is_available(quantity):\n            raise OrderException(f\"Insufficient stock for {product.name}\")\n\n        # Check for existing item\n        existing_item = self._find_item(product.id)\n        if existing_item:\n            existing_item.increase_quantity(quantity)\n        else:\n            self._items.append(OrderItem(product, quantity))\n\n        self._record_event(\n            ItemAddedToOrder(self._id, product.id, quantity)\n        )\n\n    def remove_item(self, product_id: ProductId) -&gt; None:\n        \"\"\"Remove item from order.\"\"\"\n        if self._status != OrderStatus.PENDING:\n            raise OrderException(\"Cannot modify confirmed order\")\n\n        item = self._find_item(product_id)\n        if not item:\n            raise OrderException(f\"Product {product_id} not in order\")\n\n        self._items.remove(item)\n        self._record_event(ItemRemovedFromOrder(self._id, product_id))\n\n    def confirm(self) -&gt; None:\n        \"\"\"Confirm order and validate business rules.\"\"\"\n        if self._status != OrderStatus.PENDING:\n            raise OrderException(\"Order already confirmed\")\n\n        if not self._items:\n            raise OrderException(\"Cannot confirm empty order\")\n\n        if self.calculate_total() &lt; Money(10, Currency.USD):\n            raise OrderException(\"Minimum order amount is $10\")\n\n        self._status = OrderStatus.CONFIRMED\n        self._record_event(OrderConfirmed(self._id, self.calculate_total()))\n\n    def cancel(self, reason: str) -&gt; None:\n        \"\"\"Cancel order if allowed by business rules.\"\"\"\n        if self._status == OrderStatus.SHIPPED:\n            raise OrderException(\"Cannot cancel shipped order\")\n\n        if self._status == OrderStatus.DELIVERED:\n            raise OrderException(\"Cannot cancel delivered order\")\n\n        self._status = OrderStatus.CANCELLED\n        self._record_event(OrderCancelled(self._id, reason))\n\n    def calculate_total(self) -&gt; Money:\n        \"\"\"Calculate order total with business logic.\"\"\"\n        subtotal = sum(item.calculate_subtotal() for item in self._items)\n\n        # Apply customer-specific discounts\n        discount = self._customer.calculate_discount(subtotal)\n        total = subtotal - discount\n\n        # Apply shipping\n        shipping = self._calculate_shipping()\n        total = total + shipping\n\n        return total\n\n    def _calculate_shipping(self) -&gt; Money:\n        \"\"\"Calculate shipping based on business rules.\"\"\"\n        total_weight = sum(item.product.weight * item.quantity \n                          for item in self._items)\n\n        if self.calculate_total() &gt; Money(100, Currency.USD):\n            return Money(0, Currency.USD)  # Free shipping over $100\n\n        if self._customer.is_premium():\n            return Money(5, Currency.USD)  # Flat rate for premium\n\n        # Standard shipping calculation\n        return Money(10 + (total_weight * 0.5), Currency.USD)\n\n    def _find_item(self, product_id: ProductId) -&gt; Optional[OrderItem]:\n        \"\"\"Find item in order by product ID.\"\"\"\n        return next((item for item in self._items \n                    if item.product.id == product_id), None)\n\n    def _record_event(self, event: DomainEvent) -&gt; None:\n        \"\"\"Record domain event for eventual publishing.\"\"\"\n        self._events.append(event)\n</code></pre> <p>This rich model: - Encapsulates all order-related business rules - Maintains invariants (can't have negative quantities, can't modify shipped orders) - Speaks the business language (confirm, cancel, add_item) - Records domain events for cross-aggregate communication</p>","tags":["ddd","domain-driven-design","python","clean-py","business-logic"]},{"location":"blog/2025/06/02/domain-driven-design-in-python---more-than-just-folders/#aggregates-and-consistency-boundaries","title":"Aggregates and Consistency Boundaries","text":"<p>Aggregates are clusters of domain objects that we treat as a unit for data changes. They define transaction boundaries and ensure consistency.</p> <p>The Order aggregate includes Order and OrderItem entities:</p> <pre><code>class Order:  # Aggregate Root\n    def __init__(self, order_id: OrderId, customer: Customer):\n        self._id = order_id\n        self._customer = customer\n        self._items: List[OrderItem] = []  # Part of aggregate\n        # ...\n\n    def add_item(self, product: Product, quantity: int) -&gt; None:\n        # All modifications go through the aggregate root\n        # This ensures consistency\n        pass\n\nclass OrderItem:  # Entity within aggregate\n    def __init__(self, product: Product, quantity: int):\n        self.product = product\n        self.quantity = quantity\n        self._price_at_order = product.current_price()\n\n    def calculate_subtotal(self) -&gt; Money:\n        # Uses price at time of order, not current price\n        return self._price_at_order * self.quantity\n</code></pre> <p>Key aggregate principles: 1. Reference by ID: Aggregates reference other aggregates only by ID 2. Single Transaction: Changes to an aggregate happen in a single transaction 3. Eventual Consistency: Consistency between aggregates is eventual, not immediate 4. Small Aggregates: Keep aggregates small for better performance</p>","tags":["ddd","domain-driven-design","python","clean-py","business-logic"]},{"location":"blog/2025/06/02/domain-driven-design-in-python---more-than-just-folders/#value-objects-immutable-building-blocks","title":"Value Objects: Immutable Building Blocks","text":"<p>Value objects represent concepts that have no identity\u2014they're defined entirely by their attributes. Python's dataclasses and named tuples are perfect for this:</p> <pre><code>from dataclasses import dataclass, replace\nfrom decimal import Decimal\nfrom enum import Enum\n\nclass Currency(Enum):\n    USD = \"USD\"\n    EUR = \"EUR\"\n    GBP = \"GBP\"\n\n@dataclass(frozen=True)\nclass Money:\n    amount: Decimal\n    currency: Currency\n\n    def __post_init__(self):\n        if self.amount &lt; 0:\n            raise ValueError(\"Money cannot be negative\")\n\n    def __add__(self, other: 'Money') -&gt; 'Money':\n        if self.currency != other.currency:\n            raise ValueError(\"Cannot add different currencies\")\n        return Money(self.amount + other.amount, self.currency)\n\n    def __sub__(self, other: 'Money') -&gt; 'Money':\n        if self.currency != other.currency:\n            raise ValueError(\"Cannot subtract different currencies\")\n        return Money(self.amount - other.amount, self.currency)\n\n    def __mul__(self, multiplier: int) -&gt; 'Money':\n        return Money(self.amount * Decimal(multiplier), self.currency)\n\n    def convert_to(self, target_currency: Currency, rate: Decimal) -&gt; 'Money':\n        \"\"\"Convert to another currency.\"\"\"\n        if self.currency == target_currency:\n            return self\n        return Money(self.amount * rate, target_currency)\n\n    def format(self) -&gt; str:\n        \"\"\"Format for display.\"\"\"\n        symbols = {Currency.USD: \"$\", Currency.EUR: \"\u20ac\", Currency.GBP: \"\u00a3\"}\n        symbol = symbols.get(self.currency, self.currency.value)\n        return f\"{symbol}{self.amount:.2f}\"\n\n@dataclass(frozen=True)\nclass Address:\n    street: str\n    city: str\n    state: str\n    postal_code: str\n    country: str\n\n    def __post_init__(self):\n        if not all([self.street, self.city, self.postal_code, self.country]):\n            raise ValueError(\"Address requires street, city, postal code, and country\")\n\n    def format_for_shipping(self) -&gt; str:\n        \"\"\"Format address for shipping label.\"\"\"\n        return f\"{self.street}\\n{self.city}, {self.state} {self.postal_code}\\n{self.country}\"\n\n@dataclass(frozen=True)\nclass EmailAddress:\n    value: str\n\n    def __post_init__(self):\n        if not self._is_valid_email(self.value):\n            raise ValueError(f\"Invalid email address: {self.value}\")\n\n    def _is_valid_email(self, email: str) -&gt; bool:\n        import re\n        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n        return bool(re.match(pattern, email))\n\n    @property\n    def domain(self) -&gt; str:\n        return self.value.split('@')[1]\n\n    def __str__(self) -&gt; str:\n        return self.value\n</code></pre> <p>Value objects provide: - Type safety (can't accidentally pass a string where Money is expected) - Business logic encapsulation (Money knows how to add itself) - Immutability (prevents accidental mutations) - Self-validation (invalid states are impossible)</p>","tags":["ddd","domain-driven-design","python","clean-py","business-logic"]},{"location":"blog/2025/06/02/domain-driven-design-in-python---more-than-just-folders/#domain-services","title":"Domain Services","text":"<p>Sometimes business logic doesn't naturally fit within an entity or value object. Domain services handle these cases:</p> <pre><code>class PricingService:\n    \"\"\"Domain service for complex pricing calculations.\"\"\"\n\n    def calculate_order_total(\n        self,\n        order: Order,\n        customer: Customer,\n        promotions: List[Promotion],\n        tax_calculator: TaxCalculator\n    ) -&gt; Money:\n        \"\"\"Calculate total with all applicable discounts and taxes.\"\"\"\n\n        subtotal = order.calculate_subtotal()\n\n        # Apply promotions\n        for promotion in promotions:\n            if promotion.applies_to(order, customer):\n                subtotal = promotion.apply_discount(subtotal)\n\n        # Apply customer loyalty discount\n        if customer.loyalty_tier == LoyaltyTier.GOLD:\n            subtotal = subtotal * Decimal('0.9')  # 10% off\n        elif customer.loyalty_tier == LoyaltyTier.SILVER:\n            subtotal = subtotal * Decimal('0.95')  # 5% off\n\n        # Calculate tax\n        tax = tax_calculator.calculate_tax(subtotal, customer.address)\n\n        # Add shipping\n        shipping = self._calculate_shipping(order, customer)\n\n        return subtotal + tax + shipping\n\n    def _calculate_shipping(self, order: Order, customer: Customer) -&gt; Money:\n        \"\"\"Complex shipping calculation logic.\"\"\"\n        # Business logic that involves multiple aggregates\n        pass\n\nclass InventoryAllocationService:\n    \"\"\"Domain service for inventory allocation.\"\"\"\n\n    def allocate_inventory(\n        self,\n        order: Order,\n        warehouses: List[Warehouse]\n    ) -&gt; AllocationResult:\n        \"\"\"Allocate inventory from multiple warehouses.\"\"\"\n\n        allocations = []\n        remaining_items = order.get_items().copy()\n\n        # Sort warehouses by proximity to customer\n        sorted_warehouses = self._sort_by_proximity(\n            warehouses, \n            order.shipping_address\n        )\n\n        for warehouse in sorted_warehouses:\n            if not remaining_items:\n                break\n\n            warehouse_allocations = []\n            for item in remaining_items[:]:\n                available = warehouse.check_availability(item.product.sku)\n                if available &gt;= item.quantity:\n                    warehouse_allocations.append(\n                        Allocation(warehouse, item.product, item.quantity)\n                    )\n                    remaining_items.remove(item)\n                elif available &gt; 0:\n                    warehouse_allocations.append(\n                        Allocation(warehouse, item.product, available)\n                    )\n                    item.quantity -= available\n\n            if warehouse_allocations:\n                allocations.extend(warehouse_allocations)\n\n        if remaining_items:\n            raise InsufficientInventoryException(remaining_items)\n\n        return AllocationResult(allocations)\n</code></pre>","tags":["ddd","domain-driven-design","python","clean-py","business-logic"]},{"location":"blog/2025/06/02/domain-driven-design-in-python---more-than-just-folders/#domain-events","title":"Domain Events","text":"<p>Domain events capture things that happen in the business domain. They enable loose coupling between aggregates and bounded contexts:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Any, Dict\nfrom abc import ABC\n\n@dataclass\nclass DomainEvent(ABC):\n    \"\"\"Base class for domain events.\"\"\"\n    occurred_at: datetime = None\n\n    def __post_init__(self):\n        if self.occurred_at is None:\n            self.occurred_at = datetime.utcnow()\n\n@dataclass\nclass OrderPlaced(DomainEvent):\n    order_id: OrderId\n    customer_id: CustomerId\n    total: Money\n\n@dataclass\nclass PaymentProcessed(DomainEvent):\n    payment_id: PaymentId\n    order_id: OrderId\n    amount: Money\n    payment_method: str\n\n@dataclass\nclass InventoryReserved(DomainEvent):\n    order_id: OrderId\n    reservations: List[Dict[str, Any]]\n\n@dataclass\nclass OrderShipped(DomainEvent):\n    order_id: OrderId\n    tracking_number: str\n    carrier: str\n    estimated_delivery: datetime\n\n# Event handlers in different bounded contexts\nclass InventoryEventHandler:\n    def handle_order_placed(self, event: OrderPlaced) -&gt; None:\n        \"\"\"Reserve inventory when order is placed.\"\"\"\n        order = self.order_repository.get(event.order_id)\n\n        for item in order.items:\n            self.inventory_service.reserve(\n                item.product.sku,\n                item.quantity,\n                event.order_id\n            )\n\n        self.event_bus.publish(\n            InventoryReserved(\n                order_id=event.order_id,\n                reservations=[...]\n            )\n        )\n\nclass EmailEventHandler:\n    def handle_order_placed(self, event: OrderPlaced) -&gt; None:\n        \"\"\"Send confirmation email when order is placed.\"\"\"\n        customer = self.customer_repository.get(event.customer_id)\n        order = self.order_repository.get(event.order_id)\n\n        self.email_service.send_order_confirmation(\n            customer.email,\n            order\n        )\n\n    def handle_order_shipped(self, event: OrderShipped) -&gt; None:\n        \"\"\"Send shipping notification.\"\"\"\n        order = self.order_repository.get(event.order_id)\n        customer = self.customer_repository.get(order.customer_id)\n\n        self.email_service.send_shipping_notification(\n            customer.email,\n            event.tracking_number,\n            event.carrier,\n            event.estimated_delivery\n        )\n</code></pre>","tags":["ddd","domain-driven-design","python","clean-py","business-logic"]},{"location":"blog/2025/06/02/domain-driven-design-in-python---more-than-just-folders/#implementing-ddd-in-python-projects","title":"Implementing DDD in Python Projects","text":"<p>Here's how to structure a DDD Python project:</p> <pre><code>src/\n\u251c\u2500\u2500 shared_kernel/          # Shared value objects and utilities\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 money.py\n\u2502   \u251c\u2500\u2500 address.py\n\u2502   \u2514\u2500\u2500 identifiers.py\n\u2502\n\u251c\u2500\u2500 catalog/                # Catalog bounded context\n\u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u251c\u2500\u2500 product.py\n\u2502   \u2502   \u251c\u2500\u2500 category.py\n\u2502   \u2502   \u2514\u2500\u2500 events.py\n\u2502   \u251c\u2500\u2500 application/\n\u2502   \u2502   \u2514\u2500\u2500 services.py\n\u2502   \u2514\u2500\u2500 infrastructure/\n\u2502       \u2514\u2500\u2500 repositories.py\n\u2502\n\u251c\u2500\u2500 ordering/               # Ordering bounded context\n\u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u251c\u2500\u2500 order.py\n\u2502   \u2502   \u251c\u2500\u2500 customer.py\n\u2502   \u2502   \u2514\u2500\u2500 events.py\n\u2502   \u251c\u2500\u2500 application/\n\u2502   \u2502   \u2514\u2500\u2500 services.py\n\u2502   \u2514\u2500\u2500 infrastructure/\n\u2502       \u2514\u2500\u2500 repositories.py\n\u2502\n\u2514\u2500\u2500 inventory/              # Inventory bounded context\n    \u251c\u2500\u2500 domain/\n    \u2502   \u251c\u2500\u2500 warehouse.py\n    \u2502   \u251c\u2500\u2500 stock.py\n    \u2502   \u2514\u2500\u2500 events.py\n    \u251c\u2500\u2500 application/\n    \u2502   \u2514\u2500\u2500 services.py\n    \u2514\u2500\u2500 infrastructure/\n        \u2514\u2500\u2500 repositories.py\n</code></pre>","tags":["ddd","domain-driven-design","python","clean-py","business-logic"]},{"location":"blog/2025/06/02/domain-driven-design-in-python---more-than-just-folders/#common-ddd-pitfalls-in-python","title":"Common DDD Pitfalls in Python","text":"<ol> <li>Over-using inheritance: Favor composition over inheritance</li> <li>Anemic models: Don't separate data from behavior</li> <li>Large aggregates: Keep aggregates small and focused</li> <li>Ignoring bounded contexts: Don't try to create one model for everything</li> <li>Direct aggregate references: Reference by ID, not object reference</li> <li>Skipping value objects: Use value objects for concepts without identity</li> </ol>","tags":["ddd","domain-driven-design","python","clean-py","business-logic"]},{"location":"blog/2025/06/02/domain-driven-design-in-python---more-than-just-folders/#conclusion","title":"Conclusion","text":"<p>Domain-Driven Design isn't about following rigid rules or copying Java patterns. It's about creating code that reflects your business domain accurately. Python's flexibility makes it an excellent language for DDD\u2014dataclasses for value objects, ABC for interfaces, type hints for clarity.</p> <p>The clean-py repository shows these patterns in action. Study how the domain layer captures business logic, how aggregates maintain consistency, and how events enable communication between bounded contexts.</p> <p>In the next post, we'll explore Clean Architecture, showing how to organize these domain models into a maintainable, testable application structure. We'll see how DDD and Clean Architecture complement each other to create robust, business-focused applications.</p> <p>Remember: The goal isn't to use every DDD pattern. It's to model your domain in a way that makes the complex simple and the implicit explicit.</p>","tags":["ddd","domain-driven-design","python","clean-py","business-logic"]},{"location":"blog/2025/06/02/domain-driven-design-in-python---more-than-just-folders/#references","title":"References","text":"<ul> <li>Clean-Py Repository - DDD patterns in Python</li> <li>Domain-Driven Design by Eric Evans - The original DDD book</li> <li>Python Dataclasses - Perfect for value objects</li> <li>Implementing DDD by Vaughn Vernon - Practical DDD guidance</li> </ul>","tags":["ddd","domain-driven-design","python","clean-py","business-logic"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/","title":"Clean Architecture in Python: Keeping Your Business Logic Pure","text":"<p>Software architecture is like city planning. Without proper zoning, you end up with industrial waste flowing into residential areas and traffic jams everywhere. Clean Architecture provides that zoning system for your codebase, creating clear boundaries between business logic and technical infrastructure.</p> <p>I've spent years untangling codebases where database queries were mixed with HTTP handling, business rules were scattered across controllers, and changing a database table required touching dozens of files. Clean Architecture changed how I think about software design\u2014not as technical layers, but as concentric circles with business logic at the center.</p> <p>The clean-py repository demonstrates Clean Architecture principles in Python, showing how to structure applications that are testable, maintainable, and independent of frameworks. This isn't about academic purity; it's about practical patterns that make your code easier to understand, change, and scale.</p>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#understanding-clean-architecture","title":"Understanding Clean Architecture","text":"<p>Robert Martin introduced Clean Architecture as a way to create software that is:</p> <ul> <li>Independent of frameworks: Your business logic doesn't depend on FastAPI, Django, or any other framework</li> <li>Testable: Business rules can be tested without UI, database, or external services</li> <li>Independent of UI: The same business logic works with web APIs, command-line interfaces, or desktop applications</li> <li>Independent of database: Your business logic doesn't care whether you use PostgreSQL, MongoDB, or in-memory storage</li> <li>Independent of external agencies: Business rules don't know about third-party services</li> </ul> <p>The key insight is dependency inversion. Instead of high-level business logic depending on low-level technical details, both depend on abstractions. The result is software where the most important code\u2014your business logic\u2014has no external dependencies.</p>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#the-concentric-circles","title":"The Concentric Circles","text":"<p>Clean Architecture organizes code into concentric circles:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Infrastructure            \u2502  \u2190 Frameworks, databases, web servers\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502        Presentation         \u2502    \u2502  \u2190 Controllers, REST APIs, CLI\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502    \u2502\n\u2502  \u2502  \u2502     Application     \u2502    \u2502    \u2502  \u2190 Use cases, application services\n\u2502  \u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502    \u2502    \u2502\n\u2502  \u2502  \u2502  \u2502   Domain    \u2502    \u2502    \u2502    \u2502  \u2190 Entities, value objects, business rules\n\u2502  \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502    \u2502    \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Dependencies point inward. The domain layer has no dependencies. The application layer depends only on the domain. The presentation layer can depend on application and domain, but not infrastructure. Infrastructure can depend on everything but is injected through interfaces.</p>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#domain-layer-pure-business-logic","title":"Domain Layer: Pure Business Logic","text":"<p>The domain layer contains your business entities, value objects, and rules. It has zero dependencies on external libraries or frameworks:</p> <pre><code># src/domain/entities/customer.py\nfrom dataclasses import dataclass, field\nfrom datetime import UTC, datetime\nfrom typing import Any\nfrom uuid import UUID, uuid4\n\nfrom src.shared_kernel import (\n    Address,\n    AggregateRoot, \n    CustomerId,\n    DomainEvent,\n    Email,\n    PhoneNumber,\n)\n\n@dataclass(frozen=True)\nclass CustomerCreated(DomainEvent):\n    \"\"\"Domain event raised when a customer is created.\"\"\"\n\n    event_id: UUID\n    occurred_at: datetime\n    customer_id: CustomerId\n    customer_name: str\n    customer_email: str\n\n@dataclass\nclass Customer(AggregateRoot):\n    \"\"\"Customer aggregate root with enhanced value objects and domain events.\"\"\"\n\n    customer_id: CustomerId\n    name: str\n    email: Email\n    address: Address | None = None\n    phone: PhoneNumber | None = None\n    is_active: bool = True\n    preferences: dict[str, Any] = field(default_factory=dict)\n    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))\n    updated_at: datetime = field(default_factory=lambda: datetime.now(UTC))\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Initialize the aggregate and validate business rules.\"\"\"\n        # Set the entity ID from customer_id for base Entity class\n        object.__setattr__(self, \"id\", self.customer_id.value)\n        self._validate_business_rules()\n\n    def _validate_business_rules(self) -&gt; None:\n        \"\"\"Validate customer business rules.\"\"\"\n        if not self.name.strip():\n            raise ValueError(\"Customer name cannot be empty\")\n        # Email validation is handled by the Email value object\n\n    @classmethod\n    def create(\n        cls,\n        customer_id: CustomerId,\n        name: str,\n        email: Email,\n        address: Address | None = None,\n        phone: PhoneNumber | None = None,\n        preferences: dict[str, Any] | None = None,\n    ) -&gt; \"Customer\":\n        \"\"\"Factory method to create a new customer with domain event.\"\"\"\n        customer = cls(\n            id=customer_id.value,\n            customer_id=customer_id,\n            name=name,\n            email=email,\n            address=address,\n            phone=phone,\n            preferences=preferences or {},\n        )\n\n        # Raise domain event\n        customer.add_domain_event(\n            CustomerCreated(\n                event_id=uuid4(),\n                occurred_at=datetime.now(UTC),\n                customer_id=customer_id,\n                customer_name=name,\n                customer_email=str(email),\n            )\n        )\n\n        return customer\n\n    def deactivate(self, reason: str = \"Manual deactivation\") -&gt; \"Customer\":\n        \"\"\"Deactivate the customer and raise domain event.\"\"\"\n        if not self.is_active:\n            raise ValueError(\"Customer is already deactivated\")\n\n        deactivated_customer = Customer(\n            id=self.customer_id.value,\n            customer_id=self.customer_id,\n            name=self.name,\n            email=self.email,\n            address=self.address,\n            phone=self.phone,\n            is_active=False,\n            preferences=self.preferences,\n            created_at=self.created_at,\n            updated_at=datetime.now(UTC),\n        )\n\n        # Copy domain events and add deactivation event\n        deactivated_customer._domain_events = self._domain_events.copy()\n        deactivated_customer.add_domain_event(\n            CustomerDeactivated(\n                event_id=uuid4(),\n                occurred_at=datetime.now(UTC),\n                customer_id=self.customer_id,\n                reason=reason,\n            )\n        )\n\n        return deactivated_customer\n</code></pre> <p>Notice several key characteristics:</p> <ol> <li>Pure business logic: No imports from FastAPI, SQLAlchemy, or other frameworks</li> <li>Rich domain model: The entity contains behavior, not just data</li> <li>Value objects: Email, Address, and CustomerId provide type safety and validation</li> <li>Domain events: Business events are raised when important things happen</li> <li>Immutability: Operations return new instances rather than modifying state</li> </ol> <p>The domain also defines repository interfaces:</p> <pre><code># src/domain/repositories/customer_repository.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom src.domain.entities.customer import Customer\nfrom src.shared_kernel import CustomerId\n\nclass CustomerRepository(ABC):\n    \"\"\"Abstract repository for customer persistence.\"\"\"\n\n    @abstractmethod\n    async def save(self, customer: Customer) -&gt; Customer:\n        \"\"\"Save a customer and return the saved instance.\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_id(self, customer_id: CustomerId) -&gt; Optional[Customer]:\n        \"\"\"Find a customer by their ID.\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_email(self, email: str) -&gt; Optional[Customer]:\n        \"\"\"Find a customer by their email address.\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_all_active(self) -&gt; List[Customer]:\n        \"\"\"Find all active customers.\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete(self, customer_id: CustomerId) -&gt; None:\n        \"\"\"Delete a customer by ID.\"\"\"\n        pass\n</code></pre> <p>These interfaces define what the domain needs from the outside world without coupling to specific implementations. The domain layer declares its needs; other layers fulfill them.</p>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#application-layer-orchestrating-business-logic","title":"Application Layer: Orchestrating Business Logic","text":"<p>The application layer contains use cases\u2014the workflows your application supports. It depends on the domain layer but remains independent of infrastructure:</p> <pre><code># src/application/use_cases/commands/create_customer.py\nfrom dataclasses import dataclass\nfrom typing import Any\nfrom uuid import uuid4\n\nfrom src.domain.entities.customer import Customer\nfrom src.domain.repositories.customer_repository import CustomerRepository\nfrom src.shared_kernel import CustomerId, Email\n\n@dataclass\nclass CreateCustomerCommand:\n    name: str\n    email: str\n    preferences: dict[str, Any] | None = None\n\nclass CreateCustomerUseCase:\n    def __init__(self, customer_repository: CustomerRepository) -&gt; None:\n        self._customer_repo = customer_repository\n\n    async def execute(self, command: CreateCustomerCommand) -&gt; Customer:\n        # Check if customer with email already exists\n        existing = await self._customer_repo.find_by_email(command.email)\n        if existing:\n            raise ValueError(f\"Customer with email {command.email} already exists\")\n\n        # Create new customer using factory method\n        customer_id = CustomerId(uuid4())\n        email = Email(command.email)\n\n        customer = Customer.create(\n            customer_id=customer_id,\n            name=command.name,\n            email=email,\n            preferences=command.preferences or {},\n        )\n\n        return await self._customer_repo.save(customer)\n</code></pre> <p>The use case:</p> <ol> <li>Validates business rules: Checks for duplicate emails</li> <li>Orchestrates domain operations: Uses the Customer factory method</li> <li>Depends on abstractions: Uses the CustomerRepository interface</li> <li>Remains pure: No HTTP, database, or framework concerns</li> </ol> <p>Query use cases follow similar patterns:</p> <pre><code># src/application/use_cases/queries/search_customers.py\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\nfrom src.domain.entities.customer import Customer\nfrom src.domain.repositories.customer_repository import CustomerRepository\n\n@dataclass\nclass SearchCustomersQuery:\n    name_filter: Optional[str] = None\n    email_filter: Optional[str] = None\n    active_only: bool = True\n\nclass SearchCustomersUseCase:\n    def __init__(self, customer_repository: CustomerRepository) -&gt; None:\n        self._customer_repo = customer_repository\n\n    async def execute(self, query: SearchCustomersQuery) -&gt; List[Customer]:\n        # This is simplified - in a real app, you'd have more sophisticated\n        # search capabilities in your repository\n        if query.active_only:\n            customers = await self._customer_repo.find_all_active()\n        else:\n            customers = await self._customer_repo.find_all()\n\n        # Apply filters\n        filtered_customers = customers\n        if query.name_filter:\n            filtered_customers = [\n                c for c in filtered_customers \n                if query.name_filter.lower() in c.name.lower()\n            ]\n\n        if query.email_filter:\n            filtered_customers = [\n                c for c in filtered_customers \n                if query.email_filter.lower() in str(c.email).lower()\n            ]\n\n        return filtered_customers\n</code></pre>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#infrastructure-layer-technical-implementation-details","title":"Infrastructure Layer: Technical Implementation Details","text":"<p>The infrastructure layer implements the interfaces defined by inner layers. It handles databases, external APIs, file systems, and other technical concerns:</p> <pre><code># src/infrastructure/database/repositories/customer_repository_impl.py\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.domain.entities.customer import Customer\nfrom src.domain.repositories.customer_repository import CustomerRepository\nfrom src.infrastructure.database.models.customer_model import CustomerModel\nfrom src.shared_kernel import CustomerId\n\nclass CustomerRepositoryImpl(CustomerRepository):\n    \"\"\"SQLAlchemy implementation of CustomerRepository.\"\"\"\n\n    def __init__(self, session: AsyncSession) -&gt; None:\n        self._session = session\n\n    async def save(self, customer: Customer) -&gt; Customer:\n        \"\"\"Save a customer to the database.\"\"\"\n        # Convert domain entity to database model\n        customer_model = CustomerModel.from_domain(customer)\n\n        # Check if this is an existing customer\n        existing = await self._session.get(CustomerModel, customer.id)\n        if existing:\n            # Update existing model\n            for attr, value in customer_model.__dict__.items():\n                if not attr.startswith('_'):\n                    setattr(existing, attr, value)\n        else:\n            # Add new model\n            self._session.add(customer_model)\n\n        await self._session.commit()\n        await self._session.refresh(customer_model if not existing else existing)\n\n        # Convert back to domain entity\n        return (customer_model if not existing else existing).to_domain()\n\n    async def find_by_id(self, customer_id: CustomerId) -&gt; Optional[Customer]:\n        \"\"\"Find customer by ID.\"\"\"\n        result = await self._session.get(CustomerModel, customer_id.value)\n        return result.to_domain() if result else None\n\n    async def find_by_email(self, email: str) -&gt; Optional[Customer]:\n        \"\"\"Find customer by email.\"\"\"\n        stmt = select(CustomerModel).where(CustomerModel.email == email)\n        result = await self._session.execute(stmt)\n        customer_model = result.scalar_one_or_none()\n        return customer_model.to_domain() if customer_model else None\n\n    async def find_all_active(self) -&gt; List[Customer]:\n        \"\"\"Find all active customers.\"\"\"\n        stmt = select(CustomerModel).where(CustomerModel.is_active == True)\n        result = await self._session.execute(stmt)\n        return [model.to_domain() for model in result.scalars()]\n\n    async def delete(self, customer_id: CustomerId) -&gt; None:\n        \"\"\"Delete customer by ID.\"\"\"\n        customer_model = await self._session.get(CustomerModel, customer_id.value)\n        if customer_model:\n            await self._session.delete(customer_model)\n            await self._session.commit()\n</code></pre> <p>The database model handles the mapping between domain entities and database tables:</p> <pre><code># src/infrastructure/database/models/customer_model.py\nimport json\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional\nfrom uuid import UUID\n\nfrom sqlalchemy import JSON, Boolean, DateTime, String, Text\nfrom sqlalchemy.dialects.postgresql import UUID as PostgresUUID\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom src.domain.entities.customer import Customer\nfrom src.infrastructure.database.models.base import BaseModel\nfrom src.shared_kernel import Address, CustomerId, Email, PhoneNumber\n\nclass CustomerModel(BaseModel):\n    \"\"\"SQLAlchemy model for customer persistence.\"\"\"\n\n    __tablename__ = \"customers\"\n\n    id: Mapped[UUID] = mapped_column(\n        PostgresUUID(as_uuid=True), \n        primary_key=True\n    )\n    name: Mapped[str] = mapped_column(String(255), nullable=False)\n    email: Mapped[str] = mapped_column(String(255), nullable=False, unique=True)\n    address_data: Mapped[Optional[Dict[str, Any]]] = mapped_column(\n        JSON, \n        nullable=True, \n        name=\"address\"\n    )\n    phone_data: Mapped[Optional[str]] = mapped_column(\n        String(20), \n        nullable=True, \n        name=\"phone\"\n    )\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True)\n    preferences: Mapped[Dict[str, Any]] = mapped_column(\n        JSON, \n        default=dict\n    )\n    created_at: Mapped[datetime] = mapped_column(DateTime, nullable=False)\n    updated_at: Mapped[datetime] = mapped_column(DateTime, nullable=False)\n\n    @classmethod\n    def from_domain(cls, customer: Customer) -&gt; \"CustomerModel\":\n        \"\"\"Convert domain entity to database model.\"\"\"\n        return cls(\n            id=customer.id,\n            name=customer.name,\n            email=str(customer.email),\n            address_data=customer.address.to_dict() if customer.address else None,\n            phone_data=str(customer.phone) if customer.phone else None,\n            is_active=customer.is_active,\n            preferences=customer.preferences,\n            created_at=customer.created_at,\n            updated_at=customer.updated_at,\n        )\n\n    def to_domain(self) -&gt; Customer:\n        \"\"\"Convert database model to domain entity.\"\"\"\n        address = None\n        if self.address_data:\n            address = Address.from_dict(self.address_data)\n\n        phone = None\n        if self.phone_data:\n            phone = PhoneNumber(self.phone_data)\n\n        return Customer(\n            id=self.id,\n            customer_id=CustomerId(self.id),\n            name=self.name,\n            email=Email(self.email),\n            address=address,\n            phone=phone,\n            is_active=self.is_active,\n            preferences=self.preferences,\n            created_at=self.created_at,\n            updated_at=self.updated_at,\n        )\n</code></pre>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#presentation-layer-external-interface","title":"Presentation Layer: External Interface","text":"<p>The presentation layer handles external communication\u2014HTTP APIs, command-line interfaces, message queues. It depends on inner layers but remains focused on protocol concerns:</p> <pre><code># src/presentation/api/v1/customers.py\nfrom typing import List\nfrom uuid import UUID\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom pydantic import BaseModel\n\nfrom src.application.use_cases.commands.create_customer import (\n    CreateCustomerCommand,\n    CreateCustomerUseCase,\n)\nfrom src.application.use_cases.queries.search_customers import (\n    SearchCustomersQuery,\n    SearchCustomersUseCase,\n)\nfrom src.presentation.schemas.customer_schemas import (\n    CreateCustomerRequest,\n    CustomerResponse,\n)\nfrom src.presentation.repositories import get_customer_repository\n\nrouter = APIRouter(prefix=\"/api/v1/customers\", tags=[\"customers\"])\n\n@router.post(\"/\", response_model=CustomerResponse, status_code=status.HTTP_201_CREATED)\nasync def create_customer(\n    request: CreateCustomerRequest,\n    customer_repo = Depends(get_customer_repository),\n):\n    \"\"\"Create a new customer.\"\"\"\n    use_case = CreateCustomerUseCase(customer_repo)\n    command = CreateCustomerCommand(\n        name=request.name,\n        email=request.email,\n        preferences=request.preferences,\n    )\n\n    try:\n        customer = await use_case.execute(command)\n        return CustomerResponse.from_domain(customer)\n    except ValueError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e),\n        )\n\n@router.get(\"/\", response_model=List[CustomerResponse])\nasync def search_customers(\n    name: str = None,\n    email: str = None,\n    active_only: bool = True,\n    customer_repo = Depends(get_customer_repository),\n):\n    \"\"\"Search customers.\"\"\"\n    use_case = SearchCustomersUseCase(customer_repo)\n    query = SearchCustomersQuery(\n        name_filter=name,\n        email_filter=email,\n        active_only=active_only,\n    )\n\n    customers = await use_case.execute(query)\n    return [CustomerResponse.from_domain(c) for c in customers]\n\n@router.get(\"/{customer_id}\", response_model=CustomerResponse)\nasync def get_customer(\n    customer_id: UUID,\n    customer_repo = Depends(get_customer_repository),\n):\n    \"\"\"Get customer by ID.\"\"\"\n    from src.shared_kernel import CustomerId\n\n    customer = await customer_repo.find_by_id(CustomerId(customer_id))\n    if not customer:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Customer not found\",\n        )\n\n    return CustomerResponse.from_domain(customer)\n</code></pre> <p>The presentation layer uses DTOs (Data Transfer Objects) to handle external data representation:</p> <pre><code># src/presentation/schemas/customer_schemas.py\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, EmailStr, Field\n\nfrom src.domain.entities.customer import Customer\n\nclass CreateCustomerRequest(BaseModel):\n    \"\"\"Request model for creating a customer.\"\"\"\n\n    name: str = Field(..., min_length=1, max_length=255, description=\"Customer name\")\n    email: EmailStr = Field(..., description=\"Customer email address\")\n    preferences: Optional[Dict[str, Any]] = Field(\n        default=None, \n        description=\"Customer preferences as key-value pairs\"\n    )\n\nclass CustomerResponse(BaseModel):\n    \"\"\"Response model for customer data.\"\"\"\n\n    id: UUID\n    name: str\n    email: str\n    is_active: bool\n    preferences: Dict[str, Any]\n    created_at: datetime\n    updated_at: datetime\n\n    @classmethod\n    def from_domain(cls, customer: Customer) -&gt; \"CustomerResponse\":\n        \"\"\"Convert domain entity to response model.\"\"\"\n        return cls(\n            id=customer.id,\n            name=customer.name,\n            email=str(customer.email),\n            is_active=customer.is_active,\n            preferences=customer.preferences,\n            created_at=customer.created_at,\n            updated_at=customer.updated_at,\n        )\n</code></pre>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#dependency-injection-and-wiring","title":"Dependency Injection and Wiring","text":"<p>Clean Architecture requires careful dependency injection. The clean-py repository shows how to wire dependencies:</p> <pre><code># src/presentation/repositories.py\nfrom functools import lru_cache\n\nfrom src.domain.repositories.customer_repository import CustomerRepository\nfrom src.infrastructure.database.repositories.customer_repository_impl import (\n    CustomerRepositoryImpl,\n)\nfrom src.infrastructure.database.session import get_async_session\n\n@lru_cache()\ndef get_customer_repository() -&gt; CustomerRepository:\n    \"\"\"Get customer repository instance.\"\"\"\n    session = get_async_session()\n    return CustomerRepositoryImpl(session)\n</code></pre> <p>In production systems, you'd use a proper dependency injection container like <code>dependency-injector</code> or <code>punq</code>:</p> <pre><code># Example with dependency-injector\nfrom dependency_injector import containers, providers\nfrom dependency_injector.wiring import Provide, inject\n\nclass Container(containers.DeclarativeContainer):\n    # Configuration\n    config = providers.Configuration()\n\n    # Database\n    database = providers.Singleton(\n        Database,\n        db_url=config.database.url,\n    )\n\n    # Repositories\n    customer_repository = providers.Factory(\n        CustomerRepositoryImpl,\n        session=database.provided.session,\n    )\n\n    # Use cases\n    create_customer_use_case = providers.Factory(\n        CreateCustomerUseCase,\n        customer_repository=customer_repository,\n    )\n\n@inject\ndef create_customer_endpoint(\n    request: CreateCustomerRequest,\n    use_case: CreateCustomerUseCase = Provide[Container.create_customer_use_case],\n):\n    \"\"\"Create customer endpoint with injected dependencies.\"\"\"\n    command = CreateCustomerCommand(\n        name=request.name,\n        email=request.email,\n        preferences=request.preferences,\n    )\n    return use_case.execute(command)\n</code></pre>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#testing-clean-architecture","title":"Testing Clean Architecture","text":"<p>The beauty of Clean Architecture reveals itself in testing. Each layer can be tested independently:</p>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#domain-layer-testing","title":"Domain Layer Testing","text":"<pre><code># tests/unit/domain/test_customer.py\nimport pytest\nfrom src.domain.entities.customer import Customer\nfrom src.shared_kernel import CustomerId, Email\n\ndef test_customer_creation():\n    \"\"\"Test customer creation with domain events.\"\"\"\n    customer_id = CustomerId()\n    email = Email(\"test@example.com\")\n\n    customer = Customer.create(\n        customer_id=customer_id,\n        name=\"John Doe\",\n        email=email,\n        preferences={\"theme\": \"dark\"},\n    )\n\n    assert customer.name == \"John Doe\"\n    assert customer.email == email\n    assert customer.is_active\n    assert len(customer.get_domain_events()) == 1\n\n    event = customer.get_domain_events()[0]\n    assert event.customer_name == \"John Doe\"\n\ndef test_customer_deactivation():\n    \"\"\"Test customer deactivation business rule.\"\"\"\n    customer = Customer.create(\n        customer_id=CustomerId(),\n        name=\"John Doe\", \n        email=Email(\"test@example.com\"),\n    )\n\n    deactivated = customer.deactivate(\"Account closed\")\n\n    assert not deactivated.is_active\n    assert len(deactivated.get_domain_events()) == 2  # Created + Deactivated\n</code></pre>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#application-layer-testing","title":"Application Layer Testing","text":"<pre><code># tests/unit/application/test_create_customer.py\nimport pytest\nfrom unittest.mock import AsyncMock\n\nfrom src.application.use_cases.commands.create_customer import (\n    CreateCustomerCommand,\n    CreateCustomerUseCase,\n)\nfrom src.domain.entities.customer import Customer\nfrom src.shared_kernel import CustomerId, Email\n\n@pytest.fixture\ndef mock_customer_repository():\n    return AsyncMock()\n\n@pytest.mark.asyncio\nasync def test_create_customer_success(mock_customer_repository):\n    \"\"\"Test successful customer creation.\"\"\"\n    # Arrange\n    mock_customer_repository.find_by_email.return_value = None\n    mock_customer_repository.save.return_value = Customer.create(\n        customer_id=CustomerId(),\n        name=\"John Doe\",\n        email=Email(\"test@example.com\"),\n    )\n\n    use_case = CreateCustomerUseCase(mock_customer_repository)\n    command = CreateCustomerCommand(\n        name=\"John Doe\",\n        email=\"test@example.com\",\n        preferences={\"theme\": \"dark\"},\n    )\n\n    # Act\n    result = await use_case.execute(command)\n\n    # Assert\n    assert result.name == \"John Doe\"\n    mock_customer_repository.find_by_email.assert_called_once_with(\"test@example.com\")\n    mock_customer_repository.save.assert_called_once()\n\n@pytest.mark.asyncio\nasync def test_create_customer_duplicate_email(mock_customer_repository):\n    \"\"\"Test creating customer with duplicate email raises error.\"\"\"\n    # Arrange\n    existing_customer = Customer.create(\n        customer_id=CustomerId(),\n        name=\"Existing\",\n        email=Email(\"test@example.com\"),\n    )\n    mock_customer_repository.find_by_email.return_value = existing_customer\n\n    use_case = CreateCustomerUseCase(mock_customer_repository)\n    command = CreateCustomerCommand(\n        name=\"John Doe\",\n        email=\"test@example.com\",\n    )\n\n    # Act &amp; Assert\n    with pytest.raises(ValueError, match=\"Customer with email .* already exists\"):\n        await use_case.execute(command)\n</code></pre>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#integration-testing","title":"Integration Testing","text":"<pre><code># tests/integration/test_customer_repository.py\nimport pytest\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker\n\nfrom src.domain.entities.customer import Customer\nfrom src.infrastructure.database.repositories.customer_repository_impl import (\n    CustomerRepositoryImpl,\n)\nfrom src.shared_kernel import CustomerId, Email\n\n@pytest.fixture\nasync def repository():\n    \"\"\"Create repository with in-memory database.\"\"\"\n    engine = create_async_engine(\"sqlite+aiosqlite:///:memory:\")\n    async with engine.begin() as conn:\n        await conn.run_sync(BaseModel.metadata.create_all)\n\n    async_session = async_sessionmaker(engine)\n    session = async_session()\n\n    yield CustomerRepositoryImpl(session)\n\n    await session.close()\n    await engine.dispose()\n\n@pytest.mark.asyncio\nasync def test_save_and_find_customer(repository):\n    \"\"\"Test saving and finding a customer.\"\"\"\n    # Arrange\n    customer = Customer.create(\n        customer_id=CustomerId(),\n        name=\"John Doe\",\n        email=Email(\"test@example.com\"),\n    )\n\n    # Act\n    saved_customer = await repository.save(customer)\n    found_customer = await repository.find_by_id(customer.customer_id)\n\n    # Assert\n    assert saved_customer.name == \"John Doe\"\n    assert found_customer is not None\n    assert found_customer.name == \"John Doe\"\n    assert found_customer.email == Email(\"test@example.com\")\n</code></pre>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#benefits-of-clean-architecture","title":"Benefits of Clean Architecture","text":"<p>The investment in Clean Architecture pays dividends:</p>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#1-framework-independence","title":"1. Framework Independence","text":"<p>Your business logic isn't tied to FastAPI, Django, or any framework. Switching from FastAPI to Django only requires changes in the presentation layer:</p> <pre><code># Django views using the same use cases\nfrom django.http import JsonResponse\nfrom django.views import View\n\nclass CreateCustomerView(View):\n    def post(self, request):\n        use_case = CreateCustomerUseCase(get_customer_repository())\n        command = CreateCustomerCommand(\n            name=request.POST['name'],\n            email=request.POST['email'],\n        )\n        customer = use_case.execute(command)\n        return JsonResponse(CustomerSerializer(customer).data)\n</code></pre>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#2-database-independence","title":"2. Database Independence","text":"<p>Switching from PostgreSQL to MongoDB only requires implementing new repositories:</p> <pre><code># MongoDB repository implementation\nclass MongoCustomerRepository(CustomerRepository):\n    def __init__(self, collection):\n        self.collection = collection\n\n    async def save(self, customer: Customer) -&gt; Customer:\n        document = {\n            '_id': str(customer.id),\n            'name': customer.name,\n            'email': str(customer.email),\n            # ... other fields\n        }\n        await self.collection.replace_one(\n            {'_id': str(customer.id)}, \n            document, \n            upsert=True\n        )\n        return customer\n</code></pre>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#3-testability","title":"3. Testability","text":"<p>Business logic can be tested without external dependencies:</p> <pre><code>def test_complex_business_rule():\n    \"\"\"Test complex business logic in isolation.\"\"\"\n    # No database, no HTTP, no external services required\n    customer = Customer.create(\n        customer_id=CustomerId(),\n        name=\"John Doe\",\n        email=Email(\"test@example.com\"),\n    )\n\n    # Test business rules directly\n    assert customer.can_place_order()\n    assert customer.calculate_loyalty_discount() == Money(0)\n</code></pre>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#4-multiple-interfaces","title":"4. Multiple Interfaces","text":"<p>The same business logic can support multiple interfaces:</p> <pre><code># REST API\n@router.post(\"/customers\")\nasync def create_customer_rest(request: CreateCustomerRequest):\n    use_case = CreateCustomerUseCase(get_customer_repository())\n    return await use_case.execute(CreateCustomerCommand(...))\n\n# GraphQL API  \nasync def create_customer_graphql(info, input):\n    use_case = CreateCustomerUseCase(get_customer_repository())\n    return await use_case.execute(CreateCustomerCommand(...))\n\n# CLI Command\n@click.command()\n@click.option('--name')\n@click.option('--email')\ndef create_customer_cli(name, email):\n    use_case = CreateCustomerUseCase(get_customer_repository())\n    customer = use_case.execute(CreateCustomerCommand(name=name, email=email))\n    click.echo(f\"Created customer: {customer.name}\")\n</code></pre>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":"","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#1-over-engineering-simple-applications","title":"1. Over-Engineering Simple Applications","text":"<p>Not every application needs Clean Architecture. For simple CRUD applications, it might be overkill. Use it when:</p> <ul> <li>Business logic is complex</li> <li>Multiple teams work on the codebase</li> <li>You need to support multiple interfaces</li> <li>The application will evolve significantly over time</li> </ul>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#2-leaky-abstractions","title":"2. Leaky Abstractions","text":"<p>Domain entities shouldn't know about infrastructure concerns:</p> <pre><code># Bad - domain entity knowing about HTTP\nclass Customer:\n    def to_json(self) -&gt; str:  # \u274c HTTP concern in domain\n        return json.dumps(self.__dict__)\n\n# Good - infrastructure handles serialization\nclass CustomerResponse:\n    @classmethod\n    def from_domain(cls, customer: Customer) -&gt; \"CustomerResponse\":\n        return cls(...)\n</code></pre>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#3-anemic-domain-models","title":"3. Anemic Domain Models","text":"<p>Don't create entities that are just data containers:</p> <pre><code># Bad - anemic model\nclass Customer:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\nclass CustomerService:\n    def validate_customer(self, customer):  # \u274c Logic outside entity\n        if not customer.name:\n            raise ValueError(\"Name required\")\n\n# Good - rich domain model\nclass Customer:\n    def __init__(self, name, email):\n        self._validate(name, email)  # \u2705 Validation in entity\n        self.name = name\n        self.email = email\n\n    def _validate(self, name, email):\n        if not name.strip():\n            raise ValueError(\"Name required\")\n</code></pre>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#conclusion","title":"Conclusion","text":"<p>Clean Architecture isn't about following rules blindly\u2014it's about creating software that reflects your business domain clearly and remains adaptable to change. By organizing code into concentric circles with dependencies pointing inward, you create applications that are testable, maintainable, and independent of technical details.</p> <p>The clean-py repository demonstrates these principles in practice, showing how Python's features support Clean Architecture naturally. The key is starting with your business logic and building outward, not starting with the database or framework and working in.</p> <p>In the next post, we'll dive deep into Value Objects\u2014those small but powerful classes that make your domain model more expressive and your code more reliable. We'll see how they eliminate primitive obsession and create type-safe domain boundaries.</p>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/08/clean-architecture-in-python---keeping-your-business-logic-pure/#references","title":"References","text":"<ul> <li>Clean Architecture Book - Uncle Bob's original Clean Architecture concept</li> <li>Clean-Py Repository - Complete Clean Architecture implementation</li> <li>Domain-Driven Design - Martin Fowler's DDD overview</li> <li>Hexagonal Architecture - Alistair Cockburn's original concept</li> </ul> <p>Remember: Clean Architecture isn't about complexity\u2014it's about managing complexity in the right places.</p>","tags":["clean-architecture","python","business-logic","clean-py","software-design"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/","title":"Value Objects in Python: Small Classes, Big Impact","text":"<p>String-typed everything. It's the bane of every Python developer's existence. You've seen it before:</p> <pre><code>def create_user(user_id: str, email: str, amount: str, currency: str):\n    # What happens if someone passes email as user_id?\n    # What if amount isn't a valid number?\n    # What if currency is \"banana\"?\n    pass\n</code></pre> <p>This is primitive obsession\u2014using built-in types for domain concepts that deserve their own representation. It leads to bugs that slip past code review, runtime errors that should be compile-time errors, and business logic scattered throughout your codebase.</p> <p>Value Objects solve this problem elegantly. They're small, immutable classes that represent domain concepts and encapsulate their validation and behavior. The clean-py repository demonstrates how Value Objects transform Python code from error-prone string manipulation into type-safe, expressive domain modeling.</p>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#what-are-value-objects","title":"What Are Value Objects?","text":"<p>Value Objects are objects without identity\u2014they're defined entirely by their attributes. Two Email objects with the same email address are considered equal, unlike entities where two Customer objects with the same name might be different people.</p> <p>Eric Evans, in Domain-Driven Design, describes Value Objects as having these characteristics:</p> <ul> <li>No identity: They're equal if their attributes are equal</li> <li>Immutable: Once created, they cannot be changed</li> <li>Side-effect free: Operations return new instances rather than modifying existing ones</li> <li>Replaceable: You can substitute one instance for another with the same value</li> </ul> <p>Here's a simple example:</p> <pre><code># Primitive obsession - error-prone\ndef send_email(recipient_email: str, sender_email: str, amount: str):\n    # No validation, easy to mix up parameters\n    if not \"@\" in recipient_email:  # Basic validation scattered everywhere\n        raise ValueError(\"Invalid email\")\n    # ... more code\n\n# Value Object approach - type-safe and self-validating\ndef send_email(recipient: Email, sender: Email, amount: Money):\n    # Parameters are guaranteed valid by their types\n    # Impossible to mix up recipient and sender\n    # Business logic is centralized in the value objects\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#building-value-objects-in-python","title":"Building Value Objects in Python","text":"<p>Python's <code>dataclass</code> decorator provides an excellent foundation for Value Objects. The clean-py repository shows the pattern:</p> <pre><code># src/shared_kernel/base/value_object.py\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass ValueObject(ABC):\n    \"\"\"Base class for value objects.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate after initialization.\"\"\"\n        self.validate()\n\n    @abstractmethod\n    def validate(self) -&gt; None:\n        \"\"\"Override in subclasses to add validation logic.\"\"\"\n        ...\n</code></pre> <p>The <code>frozen=True</code> parameter makes the dataclass immutable. The <code>__post_init__</code> hook ensures validation runs after object creation. The abstract <code>validate</code> method forces subclasses to implement their business rules.</p>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#email-beyond-string-validation","title":"Email: Beyond String Validation","text":"<p>Email addresses appear everywhere in modern applications, but they're almost always represented as strings. This leads to validation code scattered throughout your application and bugs when invalid emails slip through:</p> <pre><code># src/shared_kernel/value_objects/email.py\nimport re\nfrom dataclasses import dataclass\nfrom ..base.value_object import ValueObject\n\n@dataclass(frozen=True)\nclass Email(ValueObject):\n    \"\"\"Email address value object with validation.\"\"\"\n\n    value: str\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate email format.\"\"\"\n        if not self.value:\n            raise ValueError(\"Email cannot be empty\")\n\n        # Basic email validation regex\n        email_pattern = r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\"\n        if not re.match(email_pattern, self.value):\n            raise ValueError(f\"Invalid email format: {self.value}\")\n\n    @property\n    def domain(self) -&gt; str:\n        \"\"\"Get the domain part of the email.\"\"\"\n        return self.value.split(\"@\")[1]\n\n    @property\n    def local_part(self) -&gt; str:\n        \"\"\"Get the local part of the email.\"\"\"\n        return self.value.split(\"@\")[0]\n\n    def is_corporate_email(self, corporate_domains: set[str]) -&gt; bool:\n        \"\"\"Check if this is a corporate email address.\"\"\"\n        return self.domain in corporate_domains\n\n    def __str__(self) -&gt; str:\n        return self.value\n</code></pre> <p>Now email handling becomes type-safe and expressive:</p> <pre><code># Before - error-prone\ndef create_user(email: str):\n    if \"@\" not in email:  # Duplicate validation everywhere\n        raise ValueError(\"Invalid email\")\n    domain = email.split(\"@\")[1]  # Business logic scattered\n    if domain in CORPORATE_DOMAINS:\n        apply_corporate_settings()\n\n# After - type-safe and expressive\ndef create_user(email: Email):\n    # Email is guaranteed valid by its type\n    if email.is_corporate_email(CORPORATE_DOMAINS):\n        apply_corporate_settings()\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#money-getting-financial-math-right","title":"Money: Getting Financial Math Right","text":"<p>Money is notorious for causing bugs in software systems. Floating-point arithmetic is unsuitable for financial calculations, currency mismatches cause errors, and negative amounts often aren't caught until production.</p> <pre><code># src/shared_kernel/value_objects/money.py\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nfrom ..base.value_object import ValueObject\n\n@dataclass(frozen=True)\nclass Money(ValueObject):\n    \"\"\"Money value object with currency and amount.\"\"\"\n\n    amount: Decimal\n    currency: str\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate money constraints.\"\"\"\n        if self.amount &lt; 0:\n            raise ValueError(\"Amount cannot be negative\")\n\n        if not self.currency:\n            raise ValueError(\"Currency cannot be empty\")\n\n        # Basic currency code validation (3 uppercase letters)\n        if len(self.currency) != 3 or not self.currency.isupper():\n            raise ValueError(f\"Invalid currency code: {self.currency}\")\n\n    def add(self, other: \"Money\") -&gt; \"Money\":\n        \"\"\"Add two money amounts (must have same currency).\"\"\"\n        if self.currency != other.currency:\n            raise ValueError(\n                f\"Cannot add different currencies: {self.currency} and {other.currency}\"\n            )\n\n        return Money(amount=self.amount + other.amount, currency=self.currency)\n\n    def subtract(self, other: \"Money\") -&gt; \"Money\":\n        \"\"\"Subtract two money amounts (must have same currency).\"\"\"\n        if self.currency != other.currency:\n            raise ValueError(\n                f\"Cannot subtract different currencies: {self.currency} and {other.currency}\"\n            )\n\n        result_amount = self.amount - other.amount\n        if result_amount &lt; 0:\n            raise ValueError(\"Subtraction would result in negative amount\")\n\n        return Money(amount=result_amount, currency=self.currency)\n\n    def multiply(self, factor: int | Decimal) -&gt; \"Money\":\n        \"\"\"Multiply money by a factor.\"\"\"\n        if factor &lt; 0:\n            raise ValueError(\"Factor cannot be negative\")\n\n        return Money(\n            amount=self.amount * Decimal(str(factor)), \n            currency=self.currency\n        )\n\n    def is_zero(self) -&gt; bool:\n        \"\"\"Check if the amount is zero.\"\"\"\n        return self.amount == 0\n\n    def is_positive(self) -&gt; bool:\n        \"\"\"Check if the amount is positive.\"\"\"\n        return self.amount &gt; 0\n\n    def format_display(self) -&gt; str:\n        \"\"\"Format money for display.\"\"\"\n        currency_symbols = {\n            \"USD\": \"$\",\n            \"EUR\": \"\u20ac\", \n            \"GBP\": \"\u00a3\",\n            \"JPY\": \"\u00a5\",\n        }\n\n        symbol = currency_symbols.get(self.currency, self.currency)\n        return f\"{symbol}{self.amount:.2f}\"\n\n    def __str__(self) -&gt; str:\n        return f\"{self.amount} {self.currency}\"\n</code></pre> <p>Money becomes much safer to work with:</p> <pre><code># Before - floating point disasters waiting to happen\ndef calculate_total(items: List[dict]):\n    total = 0.0  # Float precision issues\n    for item in items:\n        price = float(item[\"price\"])  # String conversion can fail\n        quantity = int(item[\"quantity\"])\n        total += price * quantity\n\n    if \"USD\" != item[\"currency\"]:  # Currency mismatch caught too late\n        raise ValueError(\"Currency mismatch\")\n\n    return total\n\n# After - precise and type-safe\ndef calculate_total(items: List[OrderItem]) -&gt; Money:\n    total = Money(Decimal(\"0\"), \"USD\")\n\n    for item in items:\n        line_total = item.price.multiply(item.quantity)\n        total = total.add(line_total)  # Currency validation automatic\n\n    return total\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#address-complex-data-with-business-logic","title":"Address: Complex Data with Business Logic","text":"<p>Addresses seem simple until you encounter international variations, validation requirements, and formatting needs:</p> <pre><code># src/shared_kernel/value_objects/address.py\nfrom dataclasses import dataclass\nfrom ..base.value_object import ValueObject\n\n@dataclass(frozen=True)\nclass Address(ValueObject):\n    \"\"\"Physical address value object.\"\"\"\n\n    street: str\n    city: str\n    state: str\n    postal_code: str\n    country: str\n    apartment: str | None = None\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate address fields.\"\"\"\n        if not self.street.strip():\n            raise ValueError(\"Street cannot be empty\")\n\n        if not self.city.strip():\n            raise ValueError(\"City cannot be empty\")\n\n        if not self.state.strip():\n            raise ValueError(\"State cannot be empty\")\n\n        if not self.postal_code.strip():\n            raise ValueError(\"Postal code cannot be empty\")\n\n        if not self.country.strip():\n            raise ValueError(\"Country cannot be empty\")\n\n        # Basic postal code validation (flexible format)\n        if len(self.postal_code) &lt; 3:\n            raise ValueError(\"Postal code too short\")\n\n    @property\n    def full_address(self) -&gt; str:\n        \"\"\"Get formatted full address.\"\"\"\n        address_parts = [self.street]\n\n        if self.apartment:\n            address_parts.append(f\"Apt {self.apartment}\")\n\n        address_parts.extend([\n            f\"{self.city}, {self.state} {self.postal_code}\", \n            self.country\n        ])\n\n        return \"\\n\".join(address_parts)\n\n    def is_us_address(self) -&gt; bool:\n        \"\"\"Check if this is a US address.\"\"\"\n        return self.country.upper() in [\"US\", \"USA\", \"UNITED STATES\"]\n\n    def get_shipping_zone(self) -&gt; str:\n        \"\"\"Determine shipping zone based on address.\"\"\"\n        if self.is_us_address():\n            return \"domestic\"\n        elif self.country.upper() in [\"CA\", \"CANADA\"]:\n            return \"north_america\"\n        elif self.country.upper() in [\"GB\", \"FR\", \"DE\", \"IT\", \"ES\"]:\n            return \"europe\"\n        else:\n            return \"international\"\n\n    def to_dict(self) -&gt; dict[str, str]:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        return {\n            \"street\": self.street,\n            \"city\": self.city,\n            \"state\": self.state,\n            \"postal_code\": self.postal_code,\n            \"country\": self.country,\n            \"apartment\": self.apartment,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict[str, str]) -&gt; \"Address\":\n        \"\"\"Create address from dictionary.\"\"\"\n        return cls(\n            street=data[\"street\"],\n            city=data[\"city\"],\n            state=data[\"state\"],\n            postal_code=data[\"postal_code\"],\n            country=data[\"country\"],\n            apartment=data.get(\"apartment\"),\n        )\n\n    def __str__(self) -&gt; str:\n        return self.full_address\n</code></pre> <p>Address becomes a first-class citizen with business logic:</p> <pre><code># Before - address handling scattered everywhere\ndef calculate_shipping_cost(address_dict: dict) -&gt; float:\n    if address_dict[\"country\"] == \"US\":\n        return 5.99\n    elif address_dict[\"country\"] in [\"CA\", \"CANADA\"]:\n        return 12.99\n    else:\n        return 24.99\n\n# After - address knows its own business rules\ndef calculate_shipping_cost(address: Address) -&gt; Money:\n    base_costs = {\n        \"domestic\": Money(Decimal(\"5.99\"), \"USD\"),\n        \"north_america\": Money(Decimal(\"12.99\"), \"USD\"),\n        \"europe\": Money(Decimal(\"19.99\"), \"USD\"),\n        \"international\": Money(Decimal(\"24.99\"), \"USD\"),\n    }\n\n    zone = address.get_shipping_zone()\n    return base_costs.get(zone, base_costs[\"international\"])\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#strongly-typed-identifiers","title":"Strongly Typed Identifiers","text":"<p>One of the most powerful applications of Value Objects is creating strongly typed identifiers. Instead of passing UUIDs as strings everywhere, create specific types:</p> <pre><code># src/shared_kernel/types/identifiers.py\nfrom dataclasses import dataclass\nfrom uuid import UUID\nfrom ..base.value_object import ValueObject\n\n@dataclass(frozen=True)\nclass CustomerId(ValueObject):\n    \"\"\"Strongly typed customer identifier.\"\"\"\n\n    value: UUID\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate customer ID.\"\"\"\n        # Type is guaranteed by annotation, no validation needed\n        pass\n\n    def __str__(self) -&gt; str:\n        return str(self.value)\n\n@dataclass(frozen=True)\nclass OrderId(ValueObject):\n    \"\"\"Strongly typed order identifier.\"\"\"\n\n    value: UUID\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate order ID.\"\"\"\n        pass\n\n    def __str__(self) -&gt; str:\n        return str(self.value)\n\n@dataclass(frozen=True)\nclass ProductId(ValueObject):\n    \"\"\"Strongly typed product identifier.\"\"\"\n\n    value: UUID\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate product ID.\"\"\"\n        pass\n\n    def __str__(self) -&gt; str:\n        return str(self.value)\n</code></pre> <p>Strongly typed identifiers prevent a class of bugs:</p> <pre><code># Before - easy to mix up parameters\ndef transfer_order(customer_id: str, order_id: str, product_id: str):\n    # What happens if someone passes order_id as customer_id?\n    pass\n\n# After - impossible to mix up parameters\ndef transfer_order(customer_id: CustomerId, order_id: OrderId, product_id: ProductId):\n    # Type system catches parameter mismatches at development time\n    pass\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#complex-value-objects-date-ranges","title":"Complex Value Objects: Date Ranges","text":"<p>Value Objects can represent complex concepts that combine multiple primitives:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import date, timedelta\nfrom typing import Iterator\n\n@dataclass(frozen=True)\nclass DateRange(ValueObject):\n    \"\"\"Value object representing a date range.\"\"\"\n\n    start_date: date\n    end_date: date\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate date range constraints.\"\"\"\n        if self.start_date &gt; self.end_date:\n            raise ValueError(\"Start date cannot be after end date\")\n\n    @property\n    def duration(self) -&gt; timedelta:\n        \"\"\"Get the duration of the date range.\"\"\"\n        return self.end_date - self.start_date\n\n    @property\n    def duration_days(self) -&gt; int:\n        \"\"\"Get duration in days.\"\"\"\n        return self.duration.days\n\n    def contains(self, check_date: date) -&gt; bool:\n        \"\"\"Check if a date falls within this range.\"\"\"\n        return self.start_date &lt;= check_date &lt;= self.end_date\n\n    def overlaps(self, other: \"DateRange\") -&gt; bool:\n        \"\"\"Check if this range overlaps with another.\"\"\"\n        return (self.start_date &lt;= other.end_date and \n                self.end_date &gt;= other.start_date)\n\n    def is_weekend_only(self) -&gt; bool:\n        \"\"\"Check if range contains only weekend days.\"\"\"\n        for single_date in self.date_range():\n            if single_date.weekday() &lt; 5:  # Monday is 0, Friday is 4\n                return False\n        return True\n\n    def date_range(self) -&gt; Iterator[date]:\n        \"\"\"Iterate over all dates in the range.\"\"\"\n        current_date = self.start_date\n        while current_date &lt;= self.end_date:\n            yield current_date\n            current_date += timedelta(days=1)\n\n    def extend_by_days(self, days: int) -&gt; \"DateRange\":\n        \"\"\"Create a new date range extended by the specified days.\"\"\"\n        return DateRange(\n            start_date=self.start_date,\n            end_date=self.end_date + timedelta(days=days)\n        )\n\n    @classmethod\n    def for_month(cls, year: int, month: int) -&gt; \"DateRange\":\n        \"\"\"Create a date range for an entire month.\"\"\"\n        start_date = date(year, month, 1)\n        if month == 12:\n            end_date = date(year + 1, 1, 1) - timedelta(days=1)\n        else:\n            end_date = date(year, month + 1, 1) - timedelta(days=1)\n\n        return cls(start_date=start_date, end_date=end_date)\n\n    def __str__(self) -&gt; str:\n        return f\"{self.start_date} to {self.end_date}\"\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#value-objects-in-business-logic","title":"Value Objects in Business Logic","text":"<p>Value Objects shine when they encapsulate business rules. Consider a discount system:</p> <pre><code>@dataclass(frozen=True)\nclass Discount(ValueObject):\n    \"\"\"Discount value object with business rules.\"\"\"\n\n    percentage: Decimal\n    min_amount: Money\n    max_discount: Money | None = None\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate discount constraints.\"\"\"\n        if self.percentage &lt; 0 or self.percentage &gt; 100:\n            raise ValueError(\"Discount percentage must be between 0 and 100\")\n\n        if self.min_amount.amount &lt; 0:\n            raise ValueError(\"Minimum amount cannot be negative\")\n\n        if self.max_discount and self.max_discount.amount &lt;= 0:\n            raise ValueError(\"Maximum discount must be positive\")\n\n    def applies_to(self, order_total: Money) -&gt; bool:\n        \"\"\"Check if discount applies to an order total.\"\"\"\n        if order_total.currency != self.min_amount.currency:\n            return False\n        return order_total.amount &gt;= self.min_amount.amount\n\n    def calculate_discount_amount(self, order_total: Money) -&gt; Money:\n        \"\"\"Calculate the discount amount for an order.\"\"\"\n        if not self.applies_to(order_total):\n            return Money(Decimal(\"0\"), order_total.currency)\n\n        discount_amount = order_total.multiply(self.percentage / 100)\n\n        if self.max_discount and discount_amount.amount &gt; self.max_discount.amount:\n            return self.max_discount\n\n        return discount_amount\n\n    def apply_to_order(self, order_total: Money) -&gt; Money:\n        \"\"\"Apply discount to an order total.\"\"\"\n        discount_amount = self.calculate_discount_amount(order_total)\n        return order_total.subtract(discount_amount)\n\n    @classmethod\n    def percentage_discount(cls, percentage: Decimal, min_amount: Money) -&gt; \"Discount\":\n        \"\"\"Create a percentage discount.\"\"\"\n        return cls(\n            percentage=percentage,\n            min_amount=min_amount,\n            max_discount=None\n        )\n\n    @classmethod\n    def capped_discount(cls, percentage: Decimal, min_amount: Money, max_discount: Money) -&gt; \"Discount\":\n        \"\"\"Create a capped percentage discount.\"\"\"\n        return cls(\n            percentage=percentage,\n            min_amount=min_amount,\n            max_discount=max_discount\n        )\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#testing-value-objects","title":"Testing Value Objects","text":"<p>Value Objects are inherently easy to test because they have no dependencies and are purely functional:</p> <pre><code># tests/unit/shared_kernel/test_value_objects.py\nimport pytest\nfrom decimal import Decimal\nfrom src.shared_kernel.value_objects import Money, Email, Address\n\nclass TestMoney:\n    def test_create_valid_money(self):\n        \"\"\"Test creating valid money object.\"\"\"\n        money = Money(Decimal(\"10.50\"), \"USD\")\n        assert money.amount == Decimal(\"10.50\")\n        assert money.currency == \"USD\"\n\n    def test_negative_amount_raises_error(self):\n        \"\"\"Test that negative amounts raise validation error.\"\"\"\n        with pytest.raises(ValueError, match=\"Amount cannot be negative\"):\n            Money(Decimal(\"-10.50\"), \"USD\")\n\n    def test_invalid_currency_raises_error(self):\n        \"\"\"Test that invalid currency codes raise validation error.\"\"\"\n        with pytest.raises(ValueError, match=\"Invalid currency code\"):\n            Money(Decimal(\"10.50\"), \"usd\")  # lowercase\n\n        with pytest.raises(ValueError, match=\"Invalid currency code\"):\n            Money(Decimal(\"10.50\"), \"USDD\")  # too long\n\n    def test_add_same_currency(self):\n        \"\"\"Test adding money with same currency.\"\"\"\n        money1 = Money(Decimal(\"10.50\"), \"USD\")\n        money2 = Money(Decimal(\"5.25\"), \"USD\")\n\n        result = money1.add(money2)\n\n        assert result.amount == Decimal(\"15.75\")\n        assert result.currency == \"USD\"\n\n    def test_add_different_currencies_raises_error(self):\n        \"\"\"Test that adding different currencies raises error.\"\"\"\n        usd_money = Money(Decimal(\"10.50\"), \"USD\")\n        eur_money = Money(Decimal(\"5.25\"), \"EUR\")\n\n        with pytest.raises(ValueError, match=\"Cannot add different currencies\"):\n            usd_money.add(eur_money)\n\nclass TestEmail:\n    def test_create_valid_email(self):\n        \"\"\"Test creating valid email object.\"\"\"\n        email = Email(\"test@example.com\")\n        assert email.value == \"test@example.com\"\n        assert email.domain == \"example.com\"\n        assert email.local_part == \"test\"\n\n    def test_invalid_email_raises_error(self):\n        \"\"\"Test that invalid email formats raise validation error.\"\"\"\n        with pytest.raises(ValueError, match=\"Invalid email format\"):\n            Email(\"invalid-email\")\n\n        with pytest.raises(ValueError, match=\"Invalid email format\"):\n            Email(\"@example.com\")\n\n    def test_empty_email_raises_error(self):\n        \"\"\"Test that empty email raises validation error.\"\"\"\n        with pytest.raises(ValueError, match=\"Email cannot be empty\"):\n            Email(\"\")\n\n    def test_is_corporate_email(self):\n        \"\"\"Test corporate email detection.\"\"\"\n        email = Email(\"john@company.com\")\n        corporate_domains = {\"company.com\", \"corporation.org\"}\n\n        assert email.is_corporate_email(corporate_domains)\n        assert not email.is_corporate_email({\"other.com\"})\n\nclass TestAddress:\n    def test_create_valid_address(self):\n        \"\"\"Test creating valid address object.\"\"\"\n        address = Address(\n            street=\"123 Main St\",\n            city=\"Anytown\",\n            state=\"CA\",\n            postal_code=\"12345\",\n            country=\"USA\"\n        )\n\n        assert \"123 Main St\" in address.full_address\n        assert address.is_us_address()\n        assert address.get_shipping_zone() == \"domestic\"\n\n    def test_empty_street_raises_error(self):\n        \"\"\"Test that empty street raises validation error.\"\"\"\n        with pytest.raises(ValueError, match=\"Street cannot be empty\"):\n            Address(\n                street=\"\",\n                city=\"Anytown\",\n                state=\"CA\",\n                postal_code=\"12345\",\n                country=\"USA\"\n            )\n\n    def test_shipping_zones(self):\n        \"\"\"Test shipping zone determination.\"\"\"\n        us_address = Address(\"123 Main St\", \"Anytown\", \"CA\", \"12345\", \"USA\")\n        ca_address = Address(\"456 Maple Ave\", \"Toronto\", \"ON\", \"M1M1M1\", \"CANADA\")\n        uk_address = Address(\"789 High St\", \"London\", \"ENG\", \"SW1A 1AA\", \"GB\")\n\n        assert us_address.get_shipping_zone() == \"domestic\"\n        assert ca_address.get_shipping_zone() == \"north_america\"\n        assert uk_address.get_shipping_zone() == \"europe\"\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#value-objects-and-persistence","title":"Value Objects and Persistence","text":"<p>Value Objects need special handling when persisting to databases. The clean-py repository shows how to handle this with SQLAlchemy:</p> <pre><code># src/infrastructure/database/models/customer_model.py\nfrom sqlalchemy import JSON, String, DateTime\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom typing import Dict, Any, Optional\n\nfrom src.shared_kernel import Address, Email, Money\n\nclass CustomerModel(BaseModel):\n    \"\"\"SQLAlchemy model for customer persistence.\"\"\"\n\n    __tablename__ = \"customers\"\n\n    name: Mapped[str] = mapped_column(String(255), nullable=False)\n    email: Mapped[str] = mapped_column(String(255), nullable=False, unique=True)\n    address_data: Mapped[Optional[Dict[str, Any]]] = mapped_column(\n        JSON, \n        nullable=True, \n        name=\"address\"\n    )\n\n    @classmethod\n    def from_domain(cls, customer: Customer) -&gt; \"CustomerModel\":\n        \"\"\"Convert domain entity to database model.\"\"\"\n        return cls(\n            id=customer.id,\n            name=customer.name,\n            email=str(customer.email),  # Convert Email to string\n            address_data=customer.address.to_dict() if customer.address else None,\n            # ... other fields\n        )\n\n    def to_domain(self) -&gt; Customer:\n        \"\"\"Convert database model to domain entity.\"\"\"\n        address = None\n        if self.address_data:\n            address = Address.from_dict(self.address_data)\n\n        return Customer(\n            id=self.id,\n            customer_id=CustomerId(self.id),\n            name=self.name,\n            email=Email(self.email),  # Convert string back to Email\n            address=address,\n            # ... other fields\n        )\n</code></pre> <p>For JSON APIs, you need similar conversion:</p> <pre><code># src/presentation/schemas/customer_schemas.py\nfrom pydantic import BaseModel, EmailStr, validator\nfrom typing import Dict, Any, Optional\n\nclass CreateCustomerRequest(BaseModel):\n    \"\"\"Request model for creating a customer.\"\"\"\n\n    name: str\n    email: EmailStr  # Pydantic validates email format\n    address: Optional[Dict[str, str]] = None\n\n    def to_domain_command(self) -&gt; CreateCustomerCommand:\n        \"\"\"Convert API request to domain command.\"\"\"\n        return CreateCustomerCommand(\n            name=self.name,\n            email=self.email,  # Will be converted to Email value object in use case\n            address_data=self.address,\n        )\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":"","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#1-overuse-of-value-objects","title":"1. Overuse of Value Objects","text":"<p>Not every concept needs a Value Object. Use them when: - The concept has validation rules - The concept has behavior - You want type safety - The concept appears frequently in your domain</p> <pre><code># Probably overkill\nclass FirstName(ValueObject):\n    value: str\n    def validate(self): pass\n\n# Better - just use str if there's no special behavior\nname: str\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#2-mutable-value-objects","title":"2. Mutable Value Objects","text":"<p>Value Objects must be immutable. Use <code>frozen=True</code> in dataclasses:</p> <pre><code># Bad - mutable value object\n@dataclass\nclass Money:\n    amount: Decimal\n    currency: str\n\n# Good - immutable value object\n@dataclass(frozen=True)\nclass Money:\n    amount: Decimal\n    currency: str\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#3-value-objects-with-identity","title":"3. Value Objects with Identity","text":"<p>If it has identity, it's not a Value Object\u2014it's an Entity:</p> <pre><code># Bad - UserAccount is an entity, not a value object\n@dataclass(frozen=True)\nclass UserAccount(ValueObject):\n    account_id: str  # This gives it identity!\n    balance: Money\n\n# Good - separate entity from value objects\n@dataclass\nclass UserAccount(Entity):\n    account_id: AccountId\n    balance: Money  # Money is the value object\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#4-side-effects-in-value-objects","title":"4. Side Effects in Value Objects","text":"<p>Value Objects should be side-effect free:</p> <pre><code># Bad - side effects in value object\n@dataclass(frozen=True)\nclass Email(ValueObject):\n    value: str\n\n    def send_welcome_email(self):  # \u274c Side effect!\n        email_service.send(...)\n\n# Good - pure value object\n@dataclass(frozen=True)\nclass Email(ValueObject):\n    value: str\n\n    def is_valid_format(self) -&gt; bool:  # \u2705 Pure function\n        return \"@\" in self.value\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#value-objects-in-domain-events","title":"Value Objects in Domain Events","text":"<p>Value Objects work excellently in domain events:</p> <pre><code>@dataclass(frozen=True)\nclass OrderPlaced(DomainEvent):\n    \"\"\"Domain event when an order is placed.\"\"\"\n\n    order_id: OrderId\n    customer_id: CustomerId\n    order_total: Money\n    shipping_address: Address\n    billing_address: Address\n    order_date: date\n\n    # All properties are value objects or primitives\n    # Event is immutable and self-contained\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#performance-considerations","title":"Performance Considerations","text":"<p>Value Objects are generally lightweight, but consider these patterns for high-performance scenarios:</p>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#flyweight-pattern-for-common-values","title":"Flyweight Pattern for Common Values","text":"<pre><code># For frequently used values, consider flyweight pattern\nclass Money:\n    _instances = {}\n\n    def __new__(cls, amount: Decimal, currency: str):\n        key = (amount, currency)\n        if key not in cls._instances:\n            cls._instances[key] = super().__new__(cls)\n        return cls._instances[key]\n\n# Common values are shared\nzero_usd = Money(Decimal(\"0\"), \"USD\")\nanother_zero = Money(Decimal(\"0\"), \"USD\")\nassert zero_usd is another_zero  # Same instance\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#lazy-validation","title":"Lazy Validation","text":"<pre><code>@dataclass(frozen=True)\nclass Email(ValueObject):\n    value: str\n    _validated: bool = field(default=False, init=False)\n\n    def validate(self) -&gt; None:\n        if self._validated:\n            return\n\n        # Expensive validation logic here\n        object.__setattr__(self, '_validated', True)\n</code></pre>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#conclusion","title":"Conclusion","text":"<p>Value Objects are small classes that make a big impact on code quality. They eliminate primitive obsession, centralize validation logic, and make your domain model more expressive. By representing domain concepts as first-class objects rather than primitive types, you create code that is:</p> <ul> <li>Type-safe: The compiler catches parameter mix-ups</li> <li>Self-validating: Invalid states are impossible</li> <li>Expressive: Code reads like business language</li> <li>Testable: Pure functions with no dependencies</li> <li>Maintainable: Business logic is centralized</li> </ul> <p>The clean-py repository demonstrates these patterns in production-ready code. Start with the most problematic primitives in your codebase\u2014usually strings that represent emails, identifiers, or money amounts. Replace them with Value Objects and watch your bugs disappear.</p> <p>In the next post, we'll explore the Factory Pattern in Python, showing how to create complex objects and aggregates while maintaining business invariants and handling validation elegantly.</p>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/12/value-objects-in-python---small-classes-big-impact/#references","title":"References","text":"<ul> <li>Clean-Py Repository - Complete Value Object implementations</li> <li>Domain-Driven Design Book - Eric Evans' original DDD concepts</li> <li>Python Dataclasses - Official dataclasses documentation</li> <li>Pydantic Documentation - Validation and serialization library</li> </ul> <p>Remember: Value Objects are about expressing intent. When you see a string that represents something specific in your domain, that's a Value Object waiting to be born.</p>","tags":["value-objects","python","ddd","clean-py","type-safety"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/","title":"Factory Pattern in Python: Building Complex Objects Right","text":"<p>Object creation seems straightforward until it isn't. You start with simple constructors, then business rules creep in. Validation becomes complex. Initialization requires multiple steps. Dependencies need coordination. Before you know it, your codebase is littered with half-initialized objects, scattered validation logic, and creation code that breaks business rules.</p> <p>I've debugged too many production issues caused by objects in invalid states\u2014customers without required fields, orders with negative totals, aggregates missing domain events. The Factory Pattern solves these problems by centralizing object creation, ensuring consistency, and maintaining business invariants from the moment objects come into existence.</p> <p>The clean-py repository demonstrates factory patterns in Python that go beyond simple object construction. These patterns ensure your domain entities are born valid and remain consistent throughout their lifecycle.</p>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#the-problem-with-direct-construction","title":"The Problem with Direct Construction","text":"<p>Consider a typical Customer entity. At first glance, direct construction seems natural:</p> <pre><code># Direct construction - seems simple\ncustomer = Customer(\n    id=uuid4(),\n    name=\"John Doe\",\n    email=\"john@example.com\",\n    created_at=datetime.now(),\n    updated_at=datetime.now(),\n    is_active=True,\n    preferences={},\n)\n</code></pre> <p>This approach breaks down quickly:</p> <ol> <li>Validation scattered: Email format checking happens elsewhere</li> <li>Missing invariants: No business rule ensures required fields</li> <li>No domain events: Important business events aren't raised</li> <li>Inconsistent creation: Different parts of code create objects differently</li> <li>Complex initialization: Multi-step setup requirements aren't enforced</li> </ol> <p>Real-world creation gets messy:</p> <pre><code># Real-world direct construction - error-prone\ndef create_customer_endpoint(request):\n    # Validation scattered throughout the code\n    if not request.name or not request.name.strip():\n        raise ValueError(\"Name required\")\n\n    if not \"@\" in request.email:\n        raise ValueError(\"Invalid email\")\n\n    if Customer.objects.filter(email=request.email).exists():\n        raise ValueError(\"Email already exists\")\n\n    # Easy to forget steps\n    customer = Customer(\n        id=uuid4(),  # What if we forget this?\n        name=request.name,\n        email=request.email,\n        created_at=datetime.now(),\n        updated_at=datetime.now(),  # Duplicate logic\n        is_active=True,  # What if business rules change?\n        preferences={},  # What if we need defaults?\n    )\n\n    # Domain events forgotten\n    # Audit logging missing\n    # Notification logic scattered\n\n    return customer\n</code></pre>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#factory-methods-domain-centric-creation","title":"Factory Methods: Domain-Centric Creation","text":"<p>Factory methods centralize creation logic within the domain entity. The clean-py repository demonstrates this pattern:</p> <pre><code># src/domain/entities/customer.py\n@dataclass\nclass Customer(AggregateRoot):\n    \"\"\"Customer aggregate root with enhanced value objects and domain events.\"\"\"\n\n    customer_id: CustomerId\n    name: str\n    email: Email\n    address: Address | None = None\n    phone: PhoneNumber | None = None\n    is_active: bool = True\n    preferences: dict[str, Any] = field(default_factory=dict)\n    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))\n    updated_at: datetime = field(default_factory=lambda: datetime.now(UTC))\n\n    @classmethod\n    def create(\n        cls,\n        customer_id: CustomerId,\n        name: str,\n        email: Email,\n        address: Address | None = None,\n        phone: PhoneNumber | None = None,\n        preferences: dict[str, Any] | None = None,\n    ) -&gt; \"Customer\":\n        \"\"\"Factory method to create a new customer with domain event.\"\"\"\n        customer = cls(\n            id=customer_id.value,\n            customer_id=customer_id,\n            name=name,\n            email=email,\n            address=address,\n            phone=phone,\n            preferences=preferences or {},\n        )\n\n        # Raise domain event\n        customer.add_domain_event(\n            CustomerCreated(\n                event_id=uuid4(),\n                occurred_at=datetime.now(UTC),\n                customer_id=customer_id,\n                customer_name=name,\n                customer_email=str(email),\n            )\n        )\n\n        return customer\n</code></pre> <p>The factory method provides several benefits:</p> <ol> <li>Centralized validation: Business rules in one place</li> <li>Consistent domain events: Events raised automatically</li> <li>Immutable creation: Objects are born valid</li> <li>Clear intent: The method name expresses purpose</li> <li>Type safety: Value objects ensure parameter correctness</li> </ol> <p>Usage becomes clean and safe:</p> <pre><code># Clean factory method usage\ndef create_customer_use_case(command: CreateCustomerCommand) -&gt; Customer:\n    # Value objects handle validation\n    customer_id = CustomerId(uuid4())\n    email = Email(command.email)  # Validates format\n\n    # Business rule validation\n    existing = await customer_repo.find_by_email(command.email)\n    if existing:\n        raise ValueError(f\"Customer with email {command.email} already exists\")\n\n    # Factory ensures consistency\n    customer = Customer.create(\n        customer_id=customer_id,\n        name=command.name,\n        email=email,\n        preferences=command.preferences,\n    )\n\n    # Object is guaranteed valid with events raised\n    return await customer_repo.save(customer)\n</code></pre>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#order-factory-complex-business-logic","title":"Order Factory: Complex Business Logic","text":"<p>Orders demonstrate more complex factory requirements. The clean-py repository shows how to handle validation, business rules, and domain events:</p> <pre><code># src/domain/entities/order.py\n@dataclass\nclass Order(AggregateRoot):\n    \"\"\"Order aggregate root with enhanced value objects and domain events.\"\"\"\n\n    order_id: OrderId\n    customer_id: CustomerId\n    total_amount: Money\n    status: OrderStatus = OrderStatus.PENDING\n    details: dict[str, Any] = field(default_factory=dict)\n    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))\n    updated_at: datetime = field(default_factory=lambda: datetime.now(UTC))\n\n    def _validate_business_rules(self) -&gt; None:\n        \"\"\"Validate order business rules.\"\"\"\n        if self.total_amount.amount &lt;= Decimal(\"0\"):\n            raise BusinessRuleViolationError(\n                \"Order total amount must be greater than zero\",\n                rule_name=\"MinimumOrderAmount\",\n            )\n\n    @classmethod\n    def create(\n        cls,\n        order_id: OrderId,\n        customer_id: CustomerId,\n        total_amount: Money,\n        details: dict[str, Any] | None = None,\n    ) -&gt; \"Order\":\n        \"\"\"Factory method to create a new order with domain event.\"\"\"\n        order = cls(\n            id=order_id.value,\n            order_id=order_id,\n            customer_id=customer_id,\n            total_amount=total_amount,\n            details=details or {},\n        )\n\n        # Raise domain event\n        order.add_domain_event(\n            OrderCreated(\n                event_id=uuid4(),\n                occurred_at=datetime.now(UTC),\n                order_id=order_id,\n                customer_id=customer_id,\n                total_amount=total_amount,\n            )\n        )\n\n        return order\n</code></pre> <p>The Order factory demonstrates advanced patterns:</p> <ul> <li>Automatic validation: <code>_validate_business_rules</code> runs on initialization</li> <li>Domain events: Important business events raised automatically</li> <li>Business rule enforcement: Minimum order amount validated</li> <li>Consistent state: Orders are always created in valid state</li> </ul>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#builder-pattern-for-complex-construction","title":"Builder Pattern for Complex Construction","text":"<p>When object creation involves many optional parameters or complex setup, the Builder pattern provides a fluent interface:</p> <pre><code>from dataclasses import dataclass, field\nfrom typing import Optional, List\nfrom decimal import Decimal\n\nclass OrderBuilder:\n    \"\"\"Builder for creating complex orders with validation.\"\"\"\n\n    def __init__(self):\n        self._order_id: Optional[OrderId] = None\n        self._customer_id: Optional[CustomerId] = None\n        self._items: List[OrderItem] = []\n        self._shipping_address: Optional[Address] = None\n        self._billing_address: Optional[Address] = None\n        self._payment_method: Optional[PaymentMethod] = None\n        self._discount_codes: List[str] = []\n        self._special_instructions: Optional[str] = None\n\n    def with_id(self, order_id: OrderId) -&gt; \"OrderBuilder\":\n        \"\"\"Set the order ID.\"\"\"\n        self._order_id = order_id\n        return self\n\n    def for_customer(self, customer_id: CustomerId) -&gt; \"OrderBuilder\":\n        \"\"\"Set the customer ID.\"\"\"\n        self._customer_id = customer_id\n        return self\n\n    def add_item(self, product_id: ProductId, quantity: int, price: Money) -&gt; \"OrderBuilder\":\n        \"\"\"Add an item to the order.\"\"\"\n        if quantity &lt;= 0:\n            raise ValueError(\"Quantity must be positive\")\n\n        item = OrderItem(\n            product_id=product_id,\n            quantity=quantity,\n            unit_price=price,\n        )\n        self._items.append(item)\n        return self\n\n    def with_shipping_address(self, address: Address) -&gt; \"OrderBuilder\":\n        \"\"\"Set the shipping address.\"\"\"\n        self._shipping_address = address\n        return self\n\n    def with_billing_address(self, address: Address) -&gt; \"OrderBuilder\":\n        \"\"\"Set the billing address.\"\"\"\n        self._billing_address = address\n        return self\n\n    def with_payment_method(self, payment_method: PaymentMethod) -&gt; \"OrderBuilder\":\n        \"\"\"Set the payment method.\"\"\"\n        self._payment_method = payment_method\n        return self\n\n    def add_discount_code(self, code: str) -&gt; \"OrderBuilder\":\n        \"\"\"Add a discount code.\"\"\"\n        if code and code not in self._discount_codes:\n            self._discount_codes.append(code)\n        return self\n\n    def with_special_instructions(self, instructions: str) -&gt; \"OrderBuilder\":\n        \"\"\"Add special instructions.\"\"\"\n        self._special_instructions = instructions\n        return self\n\n    def build(self) -&gt; Order:\n        \"\"\"Build the order with validation.\"\"\"\n        # Validate required fields\n        if not self._order_id:\n            raise ValueError(\"Order ID is required\")\n\n        if not self._customer_id:\n            raise ValueError(\"Customer ID is required\")\n\n        if not self._items:\n            raise ValueError(\"Order must have at least one item\")\n\n        if not self._shipping_address:\n            raise ValueError(\"Shipping address is required\")\n\n        if not self._payment_method:\n            raise ValueError(\"Payment method is required\")\n\n        # Calculate total\n        subtotal = sum(item.calculate_total() for item in self._items)\n\n        # Apply discounts (simplified)\n        discount = Money(Decimal(\"0\"), subtotal.currency)\n        for code in self._discount_codes:\n            discount = discount.add(self._calculate_discount(code, subtotal))\n\n        # Calculate taxes and shipping\n        tax = self._calculate_tax(subtotal, self._shipping_address)\n        shipping = self._calculate_shipping(self._items, self._shipping_address)\n\n        total = subtotal.subtract(discount).add(tax).add(shipping)\n\n        # Build order details\n        details = {\n            \"items\": [item.to_dict() for item in self._items],\n            \"shipping_address\": self._shipping_address.to_dict(),\n            \"billing_address\": self._billing_address.to_dict() if self._billing_address else None,\n            \"payment_method\": self._payment_method.to_dict(),\n            \"discount_codes\": self._discount_codes,\n            \"special_instructions\": self._special_instructions,\n            \"subtotal\": str(subtotal),\n            \"discount\": str(discount),\n            \"tax\": str(tax),\n            \"shipping\": str(shipping),\n        }\n\n        # Create order using factory method\n        return Order.create(\n            order_id=self._order_id,\n            customer_id=self._customer_id,\n            total_amount=total,\n            details=details,\n        )\n\n    def _calculate_discount(self, code: str, subtotal: Money) -&gt; Money:\n        \"\"\"Calculate discount for a code (simplified implementation).\"\"\"\n        # In real implementation, this would query discount service\n        discount_rates = {\n            \"SAVE10\": Decimal(\"0.10\"),\n            \"WELCOME\": Decimal(\"0.15\"),\n            \"LOYALTY\": Decimal(\"0.05\"),\n        }\n\n        rate = discount_rates.get(code, Decimal(\"0\"))\n        return subtotal.multiply(rate)\n\n    def _calculate_tax(self, subtotal: Money, address: Address) -&gt; Money:\n        \"\"\"Calculate tax based on shipping address.\"\"\"\n        # Simplified tax calculation\n        tax_rates = {\n            \"CA\": Decimal(\"0.0875\"),  # California\n            \"NY\": Decimal(\"0.08\"),    # New York\n            \"TX\": Decimal(\"0.0625\"),  # Texas\n        }\n\n        rate = tax_rates.get(address.state, Decimal(\"0.05\"))  # Default 5%\n        return subtotal.multiply(rate)\n\n    def _calculate_shipping(self, items: List[OrderItem], address: Address) -&gt; Money:\n        \"\"\"Calculate shipping cost.\"\"\"\n        # Simplified shipping calculation\n        base_shipping = Money(Decimal(\"9.99\"), \"USD\")\n\n        # Free shipping for orders over $100\n        subtotal = sum(item.calculate_total() for item in items)\n        if subtotal.amount &gt;= 100:\n            return Money(Decimal(\"0\"), \"USD\")\n\n        # International shipping\n        if not address.is_us_address():\n            return base_shipping.multiply(2)\n\n        return base_shipping\n\n@dataclass(frozen=True)\nclass OrderItem:\n    \"\"\"Individual order item.\"\"\"\n\n    product_id: ProductId\n    quantity: int\n    unit_price: Money\n\n    def calculate_total(self) -&gt; Money:\n        \"\"\"Calculate total price for this item.\"\"\"\n        return self.unit_price.multiply(self.quantity)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert to dictionary for serialization.\"\"\"\n        return {\n            \"product_id\": str(self.product_id),\n            \"quantity\": self.quantity,\n            \"unit_price\": str(self.unit_price),\n            \"total\": str(self.calculate_total()),\n        }\n</code></pre> <p>The Builder pattern excels for complex creation:</p> <pre><code># Fluent order creation\norder = (OrderBuilder()\n    .with_id(OrderId(uuid4()))\n    .for_customer(customer_id)\n    .add_item(product_id_1, 2, Money(Decimal(\"29.99\"), \"USD\"))\n    .add_item(product_id_2, 1, Money(Decimal(\"49.99\"), \"USD\"))\n    .with_shipping_address(shipping_address)\n    .with_billing_address(billing_address)\n    .with_payment_method(credit_card)\n    .add_discount_code(\"SAVE10\")\n    .with_special_instructions(\"Leave at front door\")\n    .build())\n\n# Order is guaranteed valid with all business rules applied\nassert order.status == OrderStatus.PENDING\nassert len(order.get_domain_events()) == 1  # OrderCreated event\n</code></pre>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#abstract-factory-for-families-of-objects","title":"Abstract Factory for Families of Objects","text":"<p>When you need to create related objects consistently, Abstract Factory provides a solution:</p> <pre><code>from abc import ABC, abstractmethod\nfrom enum import Enum\n\nclass CustomerType(Enum):\n    INDIVIDUAL = \"individual\"\n    BUSINESS = \"business\"\n    PREMIUM = \"premium\"\n\nclass CustomerFactory(ABC):\n    \"\"\"Abstract factory for customer creation.\"\"\"\n\n    @abstractmethod\n    def create_customer(\n        self, \n        customer_id: CustomerId, \n        name: str, \n        email: Email,\n        **kwargs\n    ) -&gt; Customer:\n        \"\"\"Create a customer of the appropriate type.\"\"\"\n        pass\n\n    @abstractmethod\n    def create_account_settings(self, customer: Customer) -&gt; AccountSettings:\n        \"\"\"Create account settings for the customer type.\"\"\"\n        pass\n\n    @abstractmethod\n    def create_notification_preferences(self, customer: Customer) -&gt; NotificationPreferences:\n        \"\"\"Create notification preferences for the customer type.\"\"\"\n        pass\n\nclass IndividualCustomerFactory(CustomerFactory):\n    \"\"\"Factory for individual customers.\"\"\"\n\n    def create_customer(\n        self, \n        customer_id: CustomerId, \n        name: str, \n        email: Email,\n        **kwargs\n    ) -&gt; Customer:\n        \"\"\"Create an individual customer.\"\"\"\n        preferences = {\n            \"customer_type\": \"individual\",\n            \"marketing_emails\": True,\n            \"newsletter\": True,\n            \"account_limit\": Money(Decimal(\"5000\"), \"USD\"),\n        }\n        preferences.update(kwargs.get(\"preferences\", {}))\n\n        return Customer.create(\n            customer_id=customer_id,\n            name=name,\n            email=email,\n            preferences=preferences,\n        )\n\n    def create_account_settings(self, customer: Customer) -&gt; AccountSettings:\n        \"\"\"Create individual account settings.\"\"\"\n        return AccountSettings(\n            customer_id=customer.customer_id,\n            two_factor_required=False,\n            session_timeout_minutes=30,\n            password_expiry_days=90,\n        )\n\n    def create_notification_preferences(self, customer: Customer) -&gt; NotificationPreferences:\n        \"\"\"Create individual notification preferences.\"\"\"\n        return NotificationPreferences(\n            customer_id=customer.customer_id,\n            email_enabled=True,\n            sms_enabled=False,\n            push_enabled=True,\n            marketing_emails=True,\n        )\n\nclass BusinessCustomerFactory(CustomerFactory):\n    \"\"\"Factory for business customers.\"\"\"\n\n    def create_customer(\n        self, \n        customer_id: CustomerId, \n        name: str, \n        email: Email,\n        **kwargs\n    ) -&gt; Customer:\n        \"\"\"Create a business customer.\"\"\"\n        preferences = {\n            \"customer_type\": \"business\",\n            \"marketing_emails\": False,\n            \"newsletter\": False,\n            \"account_limit\": Money(Decimal(\"50000\"), \"USD\"),\n            \"tax_exempt\": kwargs.get(\"tax_exempt\", False),\n            \"net_payment_terms\": kwargs.get(\"payment_terms\", 30),\n        }\n        preferences.update(kwargs.get(\"preferences\", {}))\n\n        return Customer.create(\n            customer_id=customer_id,\n            name=name,\n            email=email,\n            preferences=preferences,\n        )\n\n    def create_account_settings(self, customer: Customer) -&gt; AccountSettings:\n        \"\"\"Create business account settings.\"\"\"\n        return AccountSettings(\n            customer_id=customer.customer_id,\n            two_factor_required=True,\n            session_timeout_minutes=60,\n            password_expiry_days=30,\n            ip_restrictions=True,\n        )\n\n    def create_notification_preferences(self, customer: Customer) -&gt; NotificationPreferences:\n        \"\"\"Create business notification preferences.\"\"\"\n        return NotificationPreferences(\n            customer_id=customer.customer_id,\n            email_enabled=True,\n            sms_enabled=True,\n            push_enabled=False,\n            marketing_emails=False,\n            billing_alerts=True,\n            order_confirmations=True,\n        )\n\nclass PremiumCustomerFactory(CustomerFactory):\n    \"\"\"Factory for premium customers.\"\"\"\n\n    def create_customer(\n        self, \n        customer_id: CustomerId, \n        name: str, \n        email: Email,\n        **kwargs\n    ) -&gt; Customer:\n        \"\"\"Create a premium customer.\"\"\"\n        preferences = {\n            \"customer_type\": \"premium\",\n            \"marketing_emails\": True,\n            \"newsletter\": True,\n            \"account_limit\": Money(Decimal(\"100000\"), \"USD\"),\n            \"concierge_service\": True,\n            \"priority_support\": True,\n            \"free_shipping\": True,\n        }\n        preferences.update(kwargs.get(\"preferences\", {}))\n\n        return Customer.create(\n            customer_id=customer_id,\n            name=name,\n            email=email,\n            preferences=preferences,\n        )\n\n    def create_account_settings(self, customer: Customer) -&gt; AccountSettings:\n        \"\"\"Create premium account settings.\"\"\"\n        return AccountSettings(\n            customer_id=customer.customer_id,\n            two_factor_required=True,\n            session_timeout_minutes=120,\n            password_expiry_days=60,\n            dedicated_support=True,\n        )\n\n    def create_notification_preferences(self, customer: Customer) -&gt; NotificationPreferences:\n        \"\"\"Create premium notification preferences.\"\"\"\n        return NotificationPreferences(\n            customer_id=customer.customer_id,\n            email_enabled=True,\n            sms_enabled=True,\n            push_enabled=True,\n            marketing_emails=True,\n            vip_offers=True,\n            personal_shopper=True,\n        )\n\ndef get_customer_factory(customer_type: CustomerType) -&gt; CustomerFactory:\n    \"\"\"Get the appropriate factory for customer type.\"\"\"\n    factories = {\n        CustomerType.INDIVIDUAL: IndividualCustomerFactory(),\n        CustomerType.BUSINESS: BusinessCustomerFactory(),\n        CustomerType.PREMIUM: PremiumCustomerFactory(),\n    }\n    return factories[customer_type]\n</code></pre> <p>Usage ensures consistency across related objects:</p> <pre><code># Consistent object family creation\ndef onboard_new_customer(\n    customer_type: CustomerType,\n    name: str,\n    email_str: str,\n    **kwargs\n) -&gt; tuple[Customer, AccountSettings, NotificationPreferences]:\n    \"\"\"Onboard a new customer with all related objects.\"\"\"\n\n    factory = get_customer_factory(customer_type)\n\n    customer_id = CustomerId(uuid4())\n    email = Email(email_str)\n\n    # Create related objects consistently\n    customer = factory.create_customer(customer_id, name, email, **kwargs)\n    account_settings = factory.create_account_settings(customer)\n    notifications = factory.create_notification_preferences(customer)\n\n    return customer, account_settings, notifications\n\n# All related objects have consistent configuration for the customer type\nindividual_customer, settings, preferences = onboard_new_customer(\n    CustomerType.INDIVIDUAL,\n    \"John Doe\",\n    \"john@example.com\"\n)\n\nbusiness_customer, biz_settings, biz_preferences = onboard_new_customer(\n    CustomerType.BUSINESS,\n    \"Acme Corp\",\n    \"admin@acme.com\",\n    tax_exempt=True,\n    payment_terms=60\n)\n</code></pre>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#testing-factory-patterns","title":"Testing Factory Patterns","text":"<p>Factory patterns make testing easier by centralizing creation logic:</p> <pre><code># tests/unit/domain/test_customer.py\nclass TestCustomer:\n    def test_customer_creation_with_factory(self):\n        \"\"\"Test creating a customer using the factory method.\"\"\"\n        customer_id = CustomerId(uuid4())\n        email = Email(\"john@example.com\")\n\n        customer = Customer.create(\n            customer_id=customer_id,\n            name=\"John Doe\",\n            email=email,\n            preferences={\"theme\": \"dark\"},\n        )\n\n        assert customer.customer_id == customer_id\n        assert customer.name == \"John Doe\"\n        assert customer.email == email\n        assert customer.is_active is True\n        assert customer.preferences == {\"theme\": \"dark\"}\n\n        # Check domain events\n        events = customer.collect_domain_events()\n        assert len(events) == 1\n        assert isinstance(events[0], CustomerCreated)\n        assert events[0].customer_id == customer_id\n        assert events[0].customer_name == \"John Doe\"\n\nclass TestCustomerFactory:\n    def test_individual_customer_factory(self):\n        \"\"\"Test individual customer factory creates correct objects.\"\"\"\n        factory = IndividualCustomerFactory()\n        customer_id = CustomerId(uuid4())\n        email = Email(\"john@example.com\")\n\n        customer = factory.create_customer(customer_id, \"John Doe\", email)\n        settings = factory.create_account_settings(customer)\n        preferences = factory.create_notification_preferences(customer)\n\n        # Verify customer type-specific configuration\n        assert customer.preferences[\"customer_type\"] == \"individual\"\n        assert customer.preferences[\"marketing_emails\"] == True\n        assert settings.two_factor_required == False\n        assert preferences.marketing_emails == True\n\n    def test_business_customer_factory(self):\n        \"\"\"Test business customer factory creates correct objects.\"\"\"\n        factory = BusinessCustomerFactory()\n        customer_id = CustomerId(uuid4())\n        email = Email(\"admin@business.com\")\n\n        customer = factory.create_customer(\n            customer_id, \n            \"Business Corp\", \n            email,\n            tax_exempt=True\n        )\n        settings = factory.create_account_settings(customer)\n\n        # Verify business-specific configuration\n        assert customer.preferences[\"customer_type\"] == \"business\"\n        assert customer.preferences[\"tax_exempt\"] == True\n        assert settings.two_factor_required == True\n        assert settings.ip_restrictions == True\n\nclass TestOrderBuilder:\n    def test_order_builder_complete_order(self):\n        \"\"\"Test building a complete order.\"\"\"\n        customer_id = CustomerId(uuid4())\n        order_id = OrderId(uuid4())\n        product_id = ProductId(uuid4())\n\n        address = Address(\n            street=\"123 Main St\",\n            city=\"Anytown\", \n            state=\"CA\",\n            postal_code=\"12345\",\n            country=\"USA\"\n        )\n\n        payment_method = PaymentMethod.credit_card(\"4111111111111111\")\n\n        order = (OrderBuilder()\n            .with_id(order_id)\n            .for_customer(customer_id)\n            .add_item(product_id, 2, Money(Decimal(\"29.99\"), \"USD\"))\n            .with_shipping_address(address)\n            .with_payment_method(payment_method)\n            .add_discount_code(\"SAVE10\")\n            .build())\n\n        assert order.order_id == order_id\n        assert order.customer_id == customer_id\n        assert order.total_amount.amount &gt; 0  # Tax and shipping calculated\n        assert \"SAVE10\" in order.details[\"discount_codes\"]\n\n    def test_order_builder_validation_errors(self):\n        \"\"\"Test builder validation catches errors.\"\"\"\n        builder = OrderBuilder()\n\n        with pytest.raises(ValueError, match=\"Order ID is required\"):\n            builder.build()\n\n        builder.with_id(OrderId(uuid4()))\n        with pytest.raises(ValueError, match=\"Customer ID is required\"):\n            builder.build()\n</code></pre>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#factory-patterns-and-dependency-injection","title":"Factory Patterns and Dependency Injection","text":"<p>Factories work well with dependency injection for more complex scenarios:</p> <pre><code>class CustomerCreationService:\n    \"\"\"Service that coordinates customer creation with external dependencies.\"\"\"\n\n    def __init__(\n        self,\n        customer_repo: CustomerRepository,\n        email_service: EmailService,\n        audit_service: AuditService,\n        notification_service: NotificationService,\n    ):\n        self._customer_repo = customer_repo\n        self._email_service = email_service\n        self._audit_service = audit_service\n        self._notification_service = notification_service\n\n    async def create_customer(\n        self, \n        customer_type: CustomerType,\n        name: str,\n        email_str: str,\n        **kwargs\n    ) -&gt; Customer:\n        \"\"\"Create customer with all side effects.\"\"\"\n\n        # Validate email doesn't exist\n        existing = await self._customer_repo.find_by_email(email_str)\n        if existing:\n            raise ValueError(f\"Customer with email {email_str} already exists\")\n\n        # Create customer using factory\n        factory = get_customer_factory(customer_type)\n        customer_id = CustomerId(uuid4())\n        email = Email(email_str)\n\n        customer = factory.create_customer(customer_id, name, email, **kwargs)\n\n        # Save to repository\n        saved_customer = await self._customer_repo.save(customer)\n\n        # Side effects\n        await self._audit_service.log_customer_creation(saved_customer)\n        await self._email_service.send_welcome_email(saved_customer)\n        await self._notification_service.notify_customer_created(saved_customer)\n\n        # Process domain events\n        for event in saved_customer.collect_domain_events():\n            await self._notification_service.publish_event(event)\n\n        return saved_customer\n</code></pre>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#common-factory-pattern-pitfalls","title":"Common Factory Pattern Pitfalls","text":"","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#1-factories-that-do-too-much","title":"1. Factories That Do Too Much","text":"<p>Keep factories focused on object creation:</p> <pre><code># Bad - factory doing too much\nclass CustomerFactory:\n    def create_customer(self, data):\n        customer = Customer.create(...)\n        self.send_email(customer)  # \u274c Side effect\n        self.update_analytics(customer)  # \u274c Not creation\n        return customer\n\n# Good - factory focused on creation\nclass CustomerFactory:\n    def create_customer(self, data):\n        return Customer.create(...)  # \u2705 Pure creation\n</code></pre>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#2-inconsistent-validation","title":"2. Inconsistent Validation","text":"<p>Ensure all factory methods apply the same validation rules:</p> <pre><code># Bad - inconsistent validation\nclass OrderFactory:\n    def create_online_order(self, data):\n        # Different validation logic\n        pass\n\n    def create_phone_order(self, data):\n        # Different validation logic\n        pass\n\n# Good - consistent validation\nclass OrderFactory:\n    def _validate_order_data(self, data):\n        # Shared validation logic\n        pass\n\n    def create_online_order(self, data):\n        self._validate_order_data(data)\n        return Order.create(...)\n\n    def create_phone_order(self, data):\n        self._validate_order_data(data)  # Same validation\n        return Order.create(...)\n</code></pre>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#3-tight-coupling-to-infrastructure","title":"3. Tight Coupling to Infrastructure","text":"<p>Keep factories in the domain layer:</p> <pre><code># Bad - factory coupled to infrastructure\nclass CustomerFactory:\n    def create_customer(self, data):\n        # Direct database access\n        if database.exists(data.email):  # \u274c Infrastructure coupling\n            raise ValueError(\"Email exists\")\n        return Customer.create(...)\n\n# Good - factory uses domain services\nclass CustomerFactory:\n    def __init__(self, customer_repo: CustomerRepository):\n        self._customer_repo = customer_repo\n\n    async def create_customer(self, data):\n        # Repository abstraction\n        if await self._customer_repo.find_by_email(data.email):\n            raise ValueError(\"Email exists\")\n        return Customer.create(...)\n</code></pre>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#advanced-factory-patterns","title":"Advanced Factory Patterns","text":"","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#factory-with-caching","title":"Factory with Caching","text":"<p>For expensive-to-create objects:</p> <pre><code>class CachedCustomerFactory:\n    \"\"\"Factory with caching for expensive customer creation.\"\"\"\n\n    def __init__(self):\n        self._cache: Dict[str, Customer] = {}\n\n    def create_or_get_customer(self, email: str, **kwargs) -&gt; Customer:\n        \"\"\"Create customer or return cached instance.\"\"\"\n        if email in self._cache:\n            return self._cache[email]\n\n        customer = Customer.create(\n            customer_id=CustomerId(uuid4()),\n            name=kwargs[\"name\"],\n            email=Email(email),\n            preferences=kwargs.get(\"preferences\", {}),\n        )\n\n        self._cache[email] = customer\n        return customer\n</code></pre>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#factory-with-strategy-pattern","title":"Factory with Strategy Pattern","text":"<p>For different creation strategies:</p> <pre><code>class OrderCreationStrategy(ABC):\n    \"\"\"Strategy for order creation.\"\"\"\n\n    @abstractmethod\n    def create_order(self, order_data: OrderData) -&gt; Order:\n        \"\"\"Create order using this strategy.\"\"\"\n        pass\n\nclass StandardOrderStrategy(OrderCreationStrategy):\n    \"\"\"Standard order creation strategy.\"\"\"\n\n    def create_order(self, order_data: OrderData) -&gt; Order:\n        return Order.create(\n            order_id=OrderId(uuid4()),\n            customer_id=order_data.customer_id,\n            total_amount=order_data.total,\n        )\n\nclass ExpressOrderStrategy(OrderCreationStrategy):\n    \"\"\"Express order creation with expedited processing.\"\"\"\n\n    def create_order(self, order_data: OrderData) -&gt; Order:\n        details = {\"processing_priority\": \"express\", \"estimated_delivery\": \"next_day\"}\n\n        return Order.create(\n            order_id=OrderId(uuid4()),\n            customer_id=order_data.customer_id,\n            total_amount=order_data.total.add(Money(Decimal(\"15.00\"), \"USD\")),  # Express fee\n            details=details,\n        )\n\nclass OrderFactory:\n    \"\"\"Factory using strategy pattern.\"\"\"\n\n    def __init__(self, strategy: OrderCreationStrategy):\n        self._strategy = strategy\n\n    def create_order(self, order_data: OrderData) -&gt; Order:\n        \"\"\"Create order using current strategy.\"\"\"\n        return self._strategy.create_order(order_data)\n</code></pre>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#conclusion","title":"Conclusion","text":"<p>Factory patterns solve the fundamental problem of object creation in domain-rich applications. By centralizing creation logic, enforcing business rules, and ensuring consistency, factories prevent the bugs and maintenance headaches that come from scattered construction code.</p> <p>The clean-py repository demonstrates that Python's flexibility makes factory patterns both powerful and elegant. From simple factory methods on domain entities to complex abstract factories that create object families, these patterns ensure your objects are born valid and remain consistent throughout their lifecycle.</p> <p>Key takeaways:</p> <ul> <li>Factory Methods: Perfect for single entity creation with domain events</li> <li>Builder Pattern: Ideal for complex objects with many optional parameters</li> <li>Abstract Factory: Essential for creating families of related objects</li> <li>Domain Focus: Keep factories in the domain layer, not infrastructure</li> <li>Validation: Centralize business rules in factory methods</li> <li>Consistency: Ensure all creation paths follow the same rules</li> </ul> <p>In the next post, we'll explore Python Type Hints as your first line of defense against bugs, showing how modern Python's type system can catch errors at development time rather than in production.</p>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/16/factory-pattern-in-python---building-complex-objects-right/#references","title":"References","text":"<ul> <li>Clean-Py Repository - Factory pattern implementations</li> <li>Gang of Four Design Patterns - Original factory pattern concepts</li> <li>Python Factory Pattern Guide - Practical Python factory examples</li> <li>Domain-Driven Design - Context for factory patterns in DDD</li> </ul> <p>Remember: Good factories don't just create objects\u2014they create valid, consistent, and properly initialized objects that are ready to participate in your business domain from the moment they exist.</p>","tags":["factory-pattern","python","object-creation","clean-py","design-patterns"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/","title":"Python Type Hints: Your First Line of Defense","text":"<p>Python without type hints is like driving without headlights\u2014you can do it, but you're bound to hit something eventually. I've spent too many hours debugging runtime errors that could have been caught at development time: <code>AttributeError: 'NoneType' object has no attribute 'value'</code>, <code>TypeError: unsupported operand type(s) for +: 'str' and 'int'</code>, and the classic <code>KeyError: 'customer_id'</code> in production.</p> <p>Type hints transform Python development from a guessing game into a predictable, maintainable experience. They serve as documentation, catch bugs early, and make your code self-explaining. The clean-py repository demonstrates how comprehensive type annotations create robust, professional Python applications.</p>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#the-case-for-type-hints","title":"The Case for Type Hints","text":"<p>Dynamic typing is Python's superpower and its kryptonite. The flexibility that makes Python productive also makes it fragile. Consider this seemingly innocent function:</p> <pre><code># No type hints - runtime disasters waiting to happen\ndef calculate_order_total(items, tax_rate, discount):\n    subtotal = sum(item.price * item.quantity for item in items)\n    discounted = subtotal - discount\n    tax = discounted * tax_rate\n    return discounted + tax\n\n# What happens when someone calls it like this?\ntotal = calculate_order_total(\"not a list\", \"not a number\", None)\n# Runtime explosion guaranteed\n</code></pre> <p>The problems are invisible until runtime: - What type should <code>items</code> be? - Is <code>discount</code> a percentage or absolute amount? - Can any of these parameters be <code>None</code>? - What does the function return?</p> <p>With type hints, these questions have clear answers:</p> <pre><code># Type hints make expectations explicit\nfrom typing import List, Optional\nfrom decimal import Decimal\n\ndef calculate_order_total(\n    items: List[OrderItem], \n    tax_rate: Decimal, \n    discount: Optional[Decimal] = None\n) -&gt; Decimal:\n    \"\"\"Calculate order total with tax and optional discount.\"\"\"\n    subtotal = sum(item.price * item.quantity for item in items)\n\n    if discount is not None:\n        subtotal -= discount\n\n    tax = subtotal * tax_rate\n    return subtotal + tax\n\n# Now it's impossible to misuse\n# calculate_order_total(\"invalid\", \"invalid\", \"invalid\")  # Type checker catches this\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#modern-python-type-system","title":"Modern Python Type System","text":"<p>Python's type system has evolved dramatically since type hints were introduced in Python 3.5. The clean-py repository uses modern Python 3.11+ features for maximum expressiveness:</p>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#union-types-with-operator","title":"Union Types with | Operator","text":"<pre><code># Old style - verbose\nfrom typing import Union, Optional\nuser_id: Union[str, int] = \"user123\"\ncustomer: Optional[Customer] = None\n\n# Modern style - clean and readable\nuser_id: str | int = \"user123\"\ncustomer: Customer | None = None\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#generic-collections","title":"Generic Collections","text":"<pre><code># Built-in collections are generic in Python 3.9+\nfrom typing import Dict, List  # No longer needed\n\n# Modern style\ncustomers: list[Customer] = []\ncustomer_map: dict[str, Customer] = {}\ncoordinates: tuple[float, float] = (1.5, 2.3)\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#advanced-value-object-typing","title":"Advanced Value Object Typing","text":"<p>The repository demonstrates sophisticated typing for value objects:</p> <pre><code># src/shared_kernel/value_objects/money.py\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nfrom typing import Self  # Python 3.11+\n\n@dataclass(frozen=True)\nclass Money(ValueObject):\n    \"\"\"Money value object with currency and amount.\"\"\"\n\n    amount: Decimal\n    currency: str\n\n    def add(self, other: \"Money\") -&gt; \"Money\":\n        \"\"\"Add two money amounts (must have same currency).\"\"\"\n        if self.currency != other.currency:\n            raise ValueError(\n                f\"Cannot add different currencies: {self.currency} and {other.currency}\"\n            )\n        return Money(amount=self.amount + other.amount, currency=self.currency)\n\n    def multiply(self, factor: int | Decimal) -&gt; \"Money\":\n        \"\"\"Multiply money by a factor.\"\"\"\n        if factor &lt; 0:\n            raise ValueError(\"Factor cannot be negative\")\n        return Money(\n            amount=self.amount * Decimal(str(factor)), \n            currency=self.currency\n        )\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#repository-interface-typing","title":"Repository Interface Typing","text":"<p>Complex generics make repository patterns type-safe:</p> <pre><code># src/domain/repositories/customer_repository.py\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom src.domain.entities.customer import Customer\nfrom src.shared_kernel import CustomerId\n\nclass CustomerRepository(ABC):\n    \"\"\"Abstract repository for customer persistence.\"\"\"\n\n    @abstractmethod\n    async def save(self, customer: Customer) -&gt; Customer:\n        \"\"\"Save a customer and return the saved instance.\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_id(self, customer_id: CustomerId) -&gt; Optional[Customer]:\n        \"\"\"Find a customer by their ID.\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_email(self, email: str) -&gt; Optional[Customer]:\n        \"\"\"Find a customer by their email address.\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_all_active(self) -&gt; List[Customer]:\n        \"\"\"Find all active customers.\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete(self, customer_id: CustomerId) -&gt; None:\n        \"\"\"Delete a customer by ID.\"\"\"\n        pass\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#use-case-typing","title":"Use Case Typing","text":"<p>Application layer typing ensures proper dependency injection:</p> <pre><code># src/application/use_cases/commands/create_customer.py\nfrom dataclasses import dataclass\nfrom typing import Any\nfrom uuid import uuid4\n\nfrom src.domain.entities.customer import Customer\nfrom src.domain.repositories.customer_repository import CustomerRepository\nfrom src.shared_kernel import CustomerId, Email\n\n@dataclass\nclass CreateCustomerCommand:\n    name: str\n    email: str\n    preferences: dict[str, Any] | None = None\n\nclass CreateCustomerUseCase:\n    def __init__(self, customer_repository: CustomerRepository) -&gt; None:\n        self._customer_repo = customer_repository\n\n    async def execute(self, command: CreateCustomerCommand) -&gt; Customer:\n        # Check if customer with email already exists\n        existing = await self._customer_repo.find_by_email(command.email)\n        if existing:\n            raise ValueError(f\"Customer with email {command.email} already exists\")\n\n        # Create new customer using factory method\n        customer_id = CustomerId(uuid4())\n        email = Email(command.email)\n\n        customer = Customer.create(\n            customer_id=customer_id,\n            name=command.name,\n            email=email,\n            preferences=command.preferences or {},\n        )\n\n        return await self._customer_repo.save(customer)\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#type-checking-with-pyright","title":"Type Checking with Pyright","text":"<p>The repository uses Pyright for strict type checking. The configuration shows professional-grade type safety:</p> <pre><code>{\n  \"include\": [\"src\", \"tests\"],\n  \"reportMissingImports\": true,\n  \"reportGeneralTypeIssues\": true,\n  \"reportOptionalMemberAccess\": true,\n  \"reportOptionalCall\": true,\n  \"reportPrivateUsage\": true,\n  \"reportUnusedImport\": true,\n  \"reportUnusedClass\": true,\n  \"reportUnusedFunction\": true,\n  \"reportUnusedVariable\": true,\n  \"reportUntypedFunctionDecorator\": true,\n  \"reportMissingParameterType\": true,\n  \"reportMissingReturnType\": true,\n  \"reportUntypedBaseClass\": true,\n  \"pythonVersion\": \"3.11\",\n  \"typeCheckingMode\": \"basic\"\n}\n</code></pre> <p>This configuration catches common issues:</p> <pre><code># Pyright catches these errors at development time:\n\n# Missing return type annotation\ndef process_order(order):  # \u274c reportMissingReturnType\n    return order.total\n\n# Unused imports\nfrom typing import Optional  # \u274c reportUnusedImport\nfrom decimal import Decimal\n\ndef calculate_tax(amount: Decimal) -&gt; Decimal:\n    return amount * Decimal(\"0.08\")\n\n# Optional member access without checking\ncustomer: Customer | None = get_customer()\nprint(customer.name)  # \u274c reportOptionalMemberAccess\n\n# Correct approach\nif customer is not None:\n    print(customer.name)  # \u2705 Safe after None check\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#advanced-type-patterns","title":"Advanced Type Patterns","text":"","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#protocol-classes-for-duck-typing","title":"Protocol Classes for Duck Typing","text":"<p>Sometimes you need the flexibility of duck typing with the safety of type hints:</p> <pre><code>from typing import Protocol, runtime_checkable\n\n@runtime_checkable\nclass PaymentProcessor(Protocol):\n    \"\"\"Protocol for payment processing.\"\"\"\n\n    def charge(self, amount: Money, payment_method: str) -&gt; PaymentResult:\n        \"\"\"Process a payment charge.\"\"\"\n        ...\n\n    def refund(self, transaction_id: str, amount: Money) -&gt; RefundResult:\n        \"\"\"Process a refund.\"\"\"\n        ...\n\nclass StripeProcessor:\n    \"\"\"Stripe implementation of payment processing.\"\"\"\n\n    def charge(self, amount: Money, payment_method: str) -&gt; PaymentResult:\n        # Stripe-specific implementation\n        return PaymentResult(success=True, transaction_id=\"stripe_123\")\n\n    def refund(self, transaction_id: str, amount: Money) -&gt; RefundResult:\n        # Stripe-specific refund\n        return RefundResult(success=True, refund_id=\"refund_456\")\n\nclass PayPalProcessor:\n    \"\"\"PayPal implementation of payment processing.\"\"\"\n\n    def charge(self, amount: Money, payment_method: str) -&gt; PaymentResult:\n        # PayPal-specific implementation\n        return PaymentResult(success=True, transaction_id=\"pp_789\")\n\n    def refund(self, transaction_id: str, amount: Money) -&gt; RefundResult:\n        # PayPal-specific refund\n        return RefundResult(success=True, refund_id=\"pp_refund_101\")\n\n# Both implementations satisfy the protocol\ndef process_payment(\n    processor: PaymentProcessor,  # Any object with charge() and refund() methods\n    amount: Money,\n    payment_method: str\n) -&gt; PaymentResult:\n    return processor.charge(amount, payment_method)\n\n# Works with either implementation\nstripe = StripeProcessor()\npaypal = PayPalProcessor()\n\nresult1 = process_payment(stripe, Money(Decimal(\"100\"), \"USD\"), \"card_123\")\nresult2 = process_payment(paypal, Money(Decimal(\"50\"), \"USD\"), \"paypal_account\")\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#generic-classes-for-repositories","title":"Generic Classes for Repositories","text":"<p>Create type-safe, reusable repository patterns:</p> <pre><code>from typing import TypeVar, Generic, List, Optional\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')  # Type variable for the entity type\nID = TypeVar('ID')  # Type variable for the ID type\n\nclass Repository(ABC, Generic[T, ID]):\n    \"\"\"Generic repository interface.\"\"\"\n\n    @abstractmethod\n    async def save(self, entity: T) -&gt; T:\n        \"\"\"Save an entity.\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_by_id(self, entity_id: ID) -&gt; Optional[T]:\n        \"\"\"Find entity by ID.\"\"\"\n        pass\n\n    @abstractmethod\n    async def find_all(self) -&gt; List[T]:\n        \"\"\"Find all entities.\"\"\"\n        pass\n\n    @abstractmethod\n    async def delete(self, entity_id: ID) -&gt; None:\n        \"\"\"Delete an entity.\"\"\"\n        pass\n\nclass CustomerRepository(Repository[Customer, CustomerId]):\n    \"\"\"Customer-specific repository with additional methods.\"\"\"\n\n    @abstractmethod\n    async def find_by_email(self, email: str) -&gt; Optional[Customer]:\n        \"\"\"Find customer by email address.\"\"\"\n        pass\n\nclass OrderRepository(Repository[Order, OrderId]):\n    \"\"\"Order-specific repository with additional methods.\"\"\"\n\n    @abstractmethod\n    async def find_by_customer(self, customer_id: CustomerId) -&gt; List[Order]:\n        \"\"\"Find orders by customer ID.\"\"\"\n        pass\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#callable-types-for-higher-order-functions","title":"Callable Types for Higher-Order Functions","text":"<p>Type complex function parameters and callbacks:</p> <pre><code>from typing import Callable, Awaitable\n\n# Type aliases for complex callables\nValidationRule = Callable[[Customer], bool]\nAsyncValidationRule = Callable[[Customer], Awaitable[bool]]\nEventHandler = Callable[[DomainEvent], Awaitable[None]]\n\nclass CustomerValidator:\n    \"\"\"Customer validation with typed rules.\"\"\"\n\n    def __init__(self, rules: List[ValidationRule]) -&gt; None:\n        self._rules = rules\n\n    def validate(self, customer: Customer) -&gt; bool:\n        \"\"\"Validate customer against all rules.\"\"\"\n        return all(rule(customer) for rule in self._rules)\n\nclass AsyncCustomerValidator:\n    \"\"\"Async customer validation with typed rules.\"\"\"\n\n    def __init__(self, rules: List[AsyncValidationRule]) -&gt; None:\n        self._rules = rules\n\n    async def validate(self, customer: Customer) -&gt; bool:\n        \"\"\"Validate customer against all async rules.\"\"\"\n        results = await asyncio.gather(*[rule(customer) for rule in self._rules])\n        return all(results)\n\n# Usage with lambda functions and proper typing\nvalidator = CustomerValidator([\n    lambda c: len(c.name) &gt; 0,  # Type inferred as ValidationRule\n    lambda c: c.email.domain not in BLOCKED_DOMAINS,\n    lambda c: c.is_active,\n])\n\nasync_validator = AsyncCustomerValidator([\n    lambda c: check_email_deliverability(c.email),  # Returns Awaitable[bool]\n    lambda c: verify_identity_async(c.customer_id),\n])\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#literal-types-for-constants","title":"Literal Types for Constants","text":"<p>Ensure only valid values are used:</p> <pre><code>from typing import Literal\n\nOrderStatusType = Literal[\"PENDING\", \"CONFIRMED\", \"SHIPPED\", \"DELIVERED\", \"CANCELLED\"]\nCustomerType = Literal[\"INDIVIDUAL\", \"BUSINESS\", \"PREMIUM\"]\nPaymentMethod = Literal[\"CREDIT_CARD\", \"DEBIT_CARD\", \"PAYPAL\", \"BANK_TRANSFER\"]\n\nclass Order:\n    def __init__(\n        self, \n        order_id: OrderId, \n        customer_id: CustomerId,\n        status: OrderStatusType = \"PENDING\"  # Only valid statuses allowed\n    ):\n        self.order_id = order_id\n        self.customer_id = customer_id\n        self.status = status\n\n    def update_status(self, new_status: OrderStatusType) -&gt; None:\n        \"\"\"Update order status with type safety.\"\"\"\n        # Type checker ensures only valid statuses can be passed\n        valid_transitions = {\n            \"PENDING\": [\"CONFIRMED\", \"CANCELLED\"],\n            \"CONFIRMED\": [\"SHIPPED\", \"CANCELLED\"],\n            \"SHIPPED\": [\"DELIVERED\"],\n            \"DELIVERED\": [],\n            \"CANCELLED\": [],\n        }\n\n        if new_status not in valid_transitions[self.status]:\n            raise ValueError(f\"Invalid status transition from {self.status} to {new_status}\")\n\n        self.status = new_status\n\n# Usage - type checker prevents invalid values\norder = Order(OrderId(uuid4()), CustomerId(uuid4()))\norder.update_status(\"CONFIRMED\")  # \u2705 Valid\n# order.update_status(\"INVALID\")    # \u274c Type error\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#typeddict-for-structured-dictionaries","title":"TypedDict for Structured Dictionaries","text":"<p>When you must use dictionaries, make them type-safe:</p> <pre><code>from typing import TypedDict, NotRequired\n\nclass CustomerPreferences(TypedDict):\n    \"\"\"Typed dictionary for customer preferences.\"\"\"\n    theme: str\n    newsletter: bool\n    marketing_emails: bool\n    language: str\n    timezone: str\n    currency: str\n    notifications: NotRequired[dict[str, bool]]  # Optional field\n\nclass OrderDetails(TypedDict):\n    \"\"\"Typed dictionary for order details.\"\"\"\n    items: list[dict[str, Any]]\n    shipping_address: dict[str, str]\n    billing_address: NotRequired[dict[str, str]]\n    payment_method: dict[str, str]\n    discount_codes: list[str]\n    special_instructions: NotRequired[str]\n\ndef process_customer_preferences(preferences: CustomerPreferences) -&gt; None:\n    \"\"\"Process customer preferences with type safety.\"\"\"\n    # Type checker knows these keys exist\n    theme = preferences[\"theme\"]\n    newsletter = preferences[\"newsletter\"]\n\n    # Optional fields need checking\n    if \"notifications\" in preferences:\n        notifications = preferences[\"notifications\"]\n\ndef create_order_from_dict(order_data: OrderDetails) -&gt; Order:\n    \"\"\"Create order from typed dictionary.\"\"\"\n    # Required fields are guaranteed to exist\n    items = order_data[\"items\"]\n    shipping = order_data[\"shipping_address\"]\n    payment = order_data[\"payment_method\"]\n\n    # Optional fields need safe access\n    billing = order_data.get(\"billing_address\")\n    instructions = order_data.get(\"special_instructions\")\n\n    return Order.create(...)\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#type-safety-in-testing","title":"Type Safety in Testing","text":"<p>Type hints make tests more reliable and expressive:</p> <pre><code># tests/unit/domain/test_customer.py\nfrom typing import List\nimport pytest\nfrom src.domain.entities.customer import Customer, CustomerCreated\nfrom src.shared_kernel import CustomerId, Email, Address\n\nclass TestCustomer:\n    def test_customer_creation_with_factory(self) -&gt; None:\n        \"\"\"Test creating a customer using the factory method.\"\"\"\n        customer_id = CustomerId(uuid4())\n        email = Email(\"john@example.com\")\n\n        customer = Customer.create(\n            customer_id=customer_id,\n            name=\"John Doe\",\n            email=email,\n            preferences={\"theme\": \"dark\"},\n        )\n\n        # Type hints ensure correct assertions\n        assert customer.customer_id == customer_id\n        assert customer.name == \"John Doe\"\n        assert customer.email == email\n        assert customer.is_active is True\n        assert customer.preferences == {\"theme\": \"dark\"}\n\n        # Type-safe event checking\n        events: List[DomainEvent] = customer.collect_domain_events()\n        assert len(events) == 1\n\n        # Type narrowing with isinstance\n        event = events[0]\n        assert isinstance(event, CustomerCreated)\n        # Now event is known to be CustomerCreated\n        assert event.customer_id == customer_id\n        assert event.customer_name == \"John Doe\"\n\n@pytest.fixture\ndef sample_customer() -&gt; Customer:\n    \"\"\"Create a sample customer for testing.\"\"\"\n    return Customer.create(\n        customer_id=CustomerId(uuid4()),\n        name=\"Test Customer\",\n        email=Email(\"test@example.com\"),\n    )\n\ndef test_customer_operations(sample_customer: Customer) -&gt; None:\n    \"\"\"Test customer operations with typed fixture.\"\"\"\n    # Type hints ensure correct usage\n    assert sample_customer.is_active\n\n    deactivated = sample_customer.deactivate(\"Testing\")\n    assert not deactivated.is_active\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#gradual-typing-strategy","title":"Gradual Typing Strategy","text":"<p>Don't try to add type hints everywhere at once. Use a gradual approach:</p>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#phase-1-core-domain-models","title":"Phase 1: Core Domain Models","text":"<p>Start with your most important business logic:</p> <pre><code># Phase 1: Domain entities and value objects\n@dataclass\nclass Customer:\n    customer_id: CustomerId  # Strong typing for identifiers\n    name: str\n    email: Email  # Value object with validation\n    is_active: bool = True\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#phase-2-repository-interfaces","title":"Phase 2: Repository Interfaces","text":"<p>Add types to your abstraction boundaries:</p> <pre><code># Phase 2: Repository and service interfaces\nclass CustomerRepository(ABC):\n    @abstractmethod\n    async def save(self, customer: Customer) -&gt; Customer:\n        pass\n\n    @abstractmethod \n    async def find_by_id(self, customer_id: CustomerId) -&gt; Customer | None:\n        pass\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#phase-3-use-cases-and-application-layer","title":"Phase 3: Use Cases and Application Layer","text":"<p>Type your application workflows:</p> <pre><code># Phase 3: Use cases and application services\nclass CreateCustomerUseCase:\n    def __init__(self, customer_repo: CustomerRepository) -&gt; None:\n        self._customer_repo = customer_repo\n\n    async def execute(self, command: CreateCustomerCommand) -&gt; Customer:\n        # Typed implementation\n        pass\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#phase-4-infrastructure-and-presentation","title":"Phase 4: Infrastructure and Presentation","text":"<p>Finally, type your outer layers:</p> <pre><code># Phase 4: FastAPI endpoints with full typing\n@router.post(\"/customers\", response_model=CustomerResponse)\nasync def create_customer(\n    request: CreateCustomerRequest,\n    customer_repo: CustomerRepository = Depends(get_customer_repository),\n) -&gt; CustomerResponse:\n    use_case = CreateCustomerUseCase(customer_repo)\n    customer = await use_case.execute(CreateCustomerCommand(...))\n    return CustomerResponse.from_domain(customer)\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#common-type-hint-mistakes","title":"Common Type Hint Mistakes","text":"","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#1-overusing-any","title":"1. Overusing <code>Any</code>","text":"<p><code>Any</code> defeats the purpose of type hints:</p> <pre><code># Bad - Any provides no type safety\ndef process_data(data: Any) -&gt; Any:\n    return data.some_method()\n\n# Good - Use specific types or generics\nfrom typing import TypeVar\nT = TypeVar('T')\n\ndef process_data(data: ProcessableData) -&gt; ProcessedResult:\n    return data.process()\n\n# Or use Protocol for duck typing\nclass Processable(Protocol):\n    def process(self) -&gt; ProcessedResult: ...\n\ndef process_data(data: Processable) -&gt; ProcessedResult:\n    return data.process()\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#2-ignoring-none-values","title":"2. Ignoring None Values","text":"<p>The most common runtime error in Python:</p> <pre><code># Bad - ignoring potential None\ndef get_customer_email(customer_id: str) -&gt; str:\n    customer = find_customer(customer_id)  # Returns Customer | None\n    return customer.email  # \u274c AttributeError if customer is None\n\n# Good - handling None explicitly\ndef get_customer_email(customer_id: str) -&gt; str | None:\n    customer = find_customer(customer_id)  # Returns Customer | None\n    if customer is None:\n        return None\n    return str(customer.email)\n\n# Even better - use Optional handling patterns\ndef get_customer_email_safe(customer_id: str) -&gt; str:\n    customer = find_customer(customer_id)\n    if customer is None:\n        raise ValueError(f\"Customer {customer_id} not found\")\n    return str(customer.email)\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#3-mutable-default-arguments","title":"3. Mutable Default Arguments","text":"<p>A classic Python gotcha made visible by type hints:</p> <pre><code># Bad - mutable default argument\ndef create_customer(\n    name: str, \n    preferences: dict[str, Any] = {}  # \u274c Shared mutable default\n) -&gt; Customer:\n    # All customers share the same preferences dict!\n    return Customer(name=name, preferences=preferences)\n\n# Good - use None with factory\ndef create_customer(\n    name: str,\n    preferences: dict[str, Any] | None = None\n) -&gt; Customer:\n    if preferences is None:\n        preferences = {}  # New dict for each call\n    return Customer(name=name, preferences=preferences)\n\n# Best - use factory pattern from dataclass\nfrom dataclasses import field\n\n@dataclass\nclass Customer:\n    name: str\n    preferences: dict[str, Any] = field(default_factory=dict)  # \u2705 New dict per instance\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#type-hints-and-performance","title":"Type Hints and Performance","text":"<p>Type hints have minimal runtime overhead but provide development-time benefits:</p> <pre><code>import timeit\nfrom typing import List, Optional\n\n# Function without type hints\ndef process_items_untyped(items, threshold):\n    return [item for item in items if item &gt; threshold]\n\n# Function with type hints\ndef process_items_typed(items: List[int], threshold: int) -&gt; List[int]:\n    return [item for item in items if item &gt; threshold]\n\n# Performance is identical at runtime\nitems = list(range(10000))\nthreshold = 5000\n\ntime_untyped = timeit.timeit(\n    lambda: process_items_untyped(items, threshold), \n    number=1000\n)\n\ntime_typed = timeit.timeit(\n    lambda: process_items_typed(items, threshold),\n    number=1000\n)\n\nprint(f\"Untyped: {time_untyped:.4f}s\")\nprint(f\"Typed: {time_typed:.4f}s\")\n# Performance difference is negligible\n</code></pre> <p>The real performance benefit comes from catching bugs early:</p> <pre><code># Type hints catch bugs at development time that would cause\n# expensive runtime errors in production\n\ndef calculate_discount(\n    order_total: Money,\n    discount_percentage: Decimal\n) -&gt; Money:\n    # Type checker ensures Money and Decimal are used correctly\n    # Prevents runtime TypeError that could crash in production\n    return order_total.multiply(discount_percentage / 100)\n\n# Without type hints, this error only appears at runtime:\n# calculate_discount(\"100.00\", \"10\")  # TypeError in production\n# With type hints, caught immediately during development\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#integration-with-development-tools","title":"Integration with Development Tools","text":"<p>Modern Python development tools understand type hints:</p>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#vs-code-integration","title":"VS Code Integration","text":"<pre><code>// .vscode/settings.json\n{\n    \"python.linting.enabled\": true,\n    \"python.linting.pylintEnabled\": false,\n    \"python.linting.pycodestyleEnabled\": false,\n    \"python.analysis.typeCheckingMode\": \"basic\",\n    \"python.analysis.autoImportCompletions\": true,\n    \"python.analysis.completeFunctionParens\": true\n}\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#pre-commit-hook-for-type-checking","title":"Pre-commit Hook for Type Checking","text":"<pre><code># .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.5.1\n    hooks:\n      - id: mypy\n        additional_dependencies: [types-requests]\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#cicd-integration","title":"CI/CD Integration","text":"<pre><code># GitHub Actions workflow\nname: Type Check\non: [push, pull_request]\njobs:\n  type-check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n      - run: pip install -r requirements.txt\n      - run: pyright src/ tests/\n</code></pre>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#conclusion","title":"Conclusion","text":"<p>Type hints transform Python from a \"hope it works\" language into a \"know it works\" language. They serve as executable documentation, catch bugs before they reach production, and make code self-explanatory to both humans and tools.</p> <p>The clean-py repository demonstrates that comprehensive typing doesn't sacrifice Python's expressiveness\u2014it enhances it. By making implicit assumptions explicit, type hints create more reliable, maintainable, and professional Python applications.</p> <p>Key benefits of comprehensive type hints:</p> <ul> <li>Early Bug Detection: Catch errors during development, not production</li> <li>Better IDE Support: Auto-completion, refactoring, and navigation</li> <li>Self-Documenting Code: Types explain intent better than comments</li> <li>Refactoring Safety: Large-scale changes become less risky  </li> <li>Team Communication: Clear contracts between code components</li> </ul> <p>Start small with your most critical domain models and gradually expand coverage. Modern Python's type system is powerful enough to express complex domain logic while remaining readable and maintainable.</p> <p>In the next post, we'll explore comprehensive testing strategies for Python microservices, showing how to build confidence in your typed, well-architected applications through systematic testing approaches.</p>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/22/python-type-hints---your-first-line-of-defense/#references","title":"References","text":"<ul> <li>Clean-Py Repository - Complete type hint implementations</li> <li>Python Type Hints Documentation - Official typing module guide</li> <li>MyPy Documentation - Static type checker for Python</li> <li>Pydantic V2 - Runtime type validation and serialization</li> </ul> <p>Remember: Type hints are not about restricting Python's flexibility\u2014they're about making that flexibility safer and more predictable.</p>","tags":["python","type-hints","type-safety","clean-py","code-quality"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/","title":"Testing Strategy for Python Microservices: Building Confidence Through Systematic Testing","text":"<p>Testing microservices isn't just about writing tests\u2014it's about building systems you can trust. I've debugged too many production incidents that could have been prevented by the right testing strategy. A missing edge case in a payment processor. A race condition in an order system. An integration failure that brought down the entire checkout flow.</p> <p>The difference between brittle and robust microservices isn't the absence of bugs\u2014it's having the confidence to catch them before they reach production. The clean-py repository demonstrates a comprehensive testing strategy that builds this confidence through systematic testing at multiple levels.</p>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#the-testing-pyramid-for-microservices","title":"The Testing Pyramid for Microservices","text":"<p>Traditional testing pyramids don't fully capture the complexity of microservices. You need a strategy that addresses the unique challenges: distributed systems, eventual consistency, external dependencies, and deployment complexity.</p> <p>Here's a refined pyramid for microservices:</p> <pre><code>                    \u25b2\n                 E2E Tests\n               (Expensive, Slow)\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n             \u2502  Contract Tests  \u2502\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502 Integration Tests    \u2502\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502     Component Tests       \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502        Unit Tests               \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           (Cheap, Fast, Many)\n</code></pre> <p>Each level serves a distinct purpose and catches different classes of errors.</p>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#unit-tests-domain-logic-verification","title":"Unit Tests: Domain Logic Verification","text":"<p>Unit tests verify your business logic in isolation. With Clean Architecture, your domain layer has no external dependencies, making it naturally testable.</p> <p>The clean-py repository demonstrates comprehensive unit testing:</p>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#testing-value-objects","title":"Testing Value Objects","text":"<pre><code># tests/unit/shared_kernel/test_value_objects.py\nclass TestEmail:\n    \"\"\"Test cases for Email value object.\"\"\"\n\n    def test_valid_email_creation(self):\n        \"\"\"Test creating a valid email.\"\"\"\n        email = Email(\"test@example.com\")\n        assert email.value == \"test@example.com\"\n        assert email.domain == \"example.com\"\n        assert email.local_part == \"test\"\n        assert str(email) == \"test@example.com\"\n\n    def test_invalid_email_format_raises_error(self):\n        \"\"\"Test that invalid email format raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Invalid email format\"):\n            Email(\"invalid-email\")\n\n        with pytest.raises(ValueError, match=\"Invalid email format\"):\n            Email(\"test@\")\n\n        with pytest.raises(ValueError, match=\"Invalid email format\"):\n            Email(\"@example.com\")\n\n    def test_empty_email_raises_error(self):\n        \"\"\"Test that empty email raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Email cannot be empty\"):\n            Email(\"\")\n\nclass TestMoney:\n    \"\"\"Test cases for Money value object.\"\"\"\n\n    def test_valid_money_creation(self):\n        \"\"\"Test creating valid money.\"\"\"\n        money = Money(Decimal(\"100.50\"), \"USD\")\n        assert money.amount == Decimal(\"100.50\")\n        assert money.currency == \"USD\"\n        assert str(money) == \"100.50 USD\"\n\n    def test_negative_amount_raises_error(self):\n        \"\"\"Test that negative amount raises ValueError.\"\"\"\n        with pytest.raises(ValueError, match=\"Amount cannot be negative\"):\n            Money(Decimal(\"-10.00\"), \"USD\")\n\n    def test_money_addition(self):\n        \"\"\"Test adding money with same currency.\"\"\"\n        money1 = Money(Decimal(\"100.00\"), \"USD\")\n        money2 = Money(Decimal(\"50.00\"), \"USD\")\n        result = money1.add(money2)\n\n        assert result.amount == Decimal(\"150.00\")\n        assert result.currency == \"USD\"\n\n    def test_money_addition_different_currency_raises_error(self):\n        \"\"\"Test that adding different currencies raises ValueError.\"\"\"\n        money1 = Money(Decimal(\"100.00\"), \"USD\")\n        money2 = Money(Decimal(\"50.00\"), \"EUR\")\n\n        with pytest.raises(ValueError, match=\"Cannot add different currencies\"):\n            money1.add(money2)\n</code></pre>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#testing-domain-entities","title":"Testing Domain Entities","text":"<pre><code># tests/unit/domain/test_customer.py\nclass TestCustomer:\n    def test_customer_creation_with_factory(self):\n        \"\"\"Test creating a customer using the factory method.\"\"\"\n        customer_id = CustomerId(uuid4())\n        email = Email(\"john@example.com\")\n\n        customer = Customer.create(\n            customer_id=customer_id,\n            name=\"John Doe\",\n            email=email,\n            preferences={\"theme\": \"dark\"},\n        )\n\n        assert customer.customer_id == customer_id\n        assert customer.name == \"John Doe\"\n        assert customer.email == email\n        assert customer.is_active is True\n        assert customer.preferences == {\"theme\": \"dark\"}\n\n        # Check domain events\n        events = customer.collect_domain_events()\n        assert len(events) == 1\n        assert isinstance(events[0], CustomerCreated)\n        assert events[0].customer_id == customer_id\n        assert events[0].customer_name == \"John Doe\"\n\n    def test_customer_deactivate(self):\n        \"\"\"Test customer deactivation business rule.\"\"\"\n        customer_id = CustomerId(uuid4())\n        email = Email(\"john@example.com\")\n\n        customer = Customer.create(customer_id=customer_id, name=\"John Doe\", email=email)\n\n        # Clear the creation event for cleaner testing\n        customer.collect_domain_events()\n\n        deactivated = customer.deactivate(\"Business closure\")\n\n        # Original customer unchanged (immutable)\n        assert customer.is_active is True\n\n        # New customer is deactivated\n        assert deactivated.is_active is False\n        assert deactivated.name == customer.name\n        assert deactivated.email == customer.email\n        assert deactivated.updated_at &gt; customer.updated_at\n\n        # Check domain events\n        events = deactivated.collect_domain_events()\n        assert len(events) == 1\n        assert isinstance(events[0], CustomerDeactivated)\n        assert events[0].customer_id == customer_id\n        assert events[0].reason == \"Business closure\"\n\n    def test_customer_deactivate_already_inactive_raises_error(self):\n        \"\"\"Test that deactivating an inactive customer raises error.\"\"\"\n        customer_id = CustomerId(uuid4())\n        email = Email(\"john@example.com\")\n\n        customer = Customer.create(customer_id=customer_id, name=\"John Doe\", email=email)\n        deactivated = customer.deactivate(\"Manual deactivation\")\n\n        # Try to deactivate again should raise error\n        with pytest.raises(ValueError, match=\"already deactivated\"):\n            deactivated.deactivate(\"Test reason\")\n</code></pre>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#testing-use-cases-with-mocks","title":"Testing Use Cases with Mocks","text":"<p>Application layer tests verify orchestration logic without external dependencies:</p> <pre><code># tests/unit/application/commands/test_create_customer.py\n@pytest.mark.asyncio\nclass TestCreateCustomerUseCase:\n    async def test_create_customer_success(self):\n        \"\"\"Test successful customer creation.\"\"\"\n        # Mock repository\n        mock_repo = AsyncMock()\n        mock_repo.find_by_email.return_value = None  # No existing customer\n        mock_repo.save.side_effect = lambda c: c  # Return saved customer\n\n        # Create use case\n        use_case = CreateCustomerUseCase(mock_repo)\n\n        # Execute command\n        command = CreateCustomerCommand(\n            name=\"John Doe\", \n            email=\"john@example.com\", \n            preferences={\"theme\": \"dark\"}\n        )\n\n        result = await use_case.execute(command)\n\n        # Assertions\n        assert result.name == \"John Doe\"\n        assert str(result.email) == \"john@example.com\"\n        assert result.preferences == {\"theme\": \"dark\"}\n        assert result.is_active is True\n\n        # Verify repository interactions\n        mock_repo.find_by_email.assert_called_once_with(\"john@example.com\")\n        mock_repo.save.assert_called_once()\n\n    async def test_create_customer_duplicate_email(self):\n        \"\"\"Test customer creation with duplicate email.\"\"\"\n        # Mock repository with existing customer\n        existing_customer = Customer.create(\n            customer_id=CustomerId(uuid4()),\n            name=\"Existing User\",\n            email=Email(\"john@example.com\"),\n            preferences={},\n        )\n\n        mock_repo = AsyncMock()\n        mock_repo.find_by_email.return_value = existing_customer\n\n        # Create use case\n        use_case = CreateCustomerUseCase(mock_repo)\n\n        # Execute command and expect error\n        command = CreateCustomerCommand(\n            name=\"John Doe\", \n            email=\"john@example.com\", \n            preferences={}\n        )\n\n        with pytest.raises(ValueError, match=\"already exists\"):\n            await use_case.execute(command)\n\n        # Verify repository called but save was not\n        mock_repo.find_by_email.assert_called_once_with(\"john@example.com\")\n        mock_repo.save.assert_not_called()\n</code></pre>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#component-tests-service-level-integration","title":"Component Tests: Service-Level Integration","text":"<p>Component tests verify that your service works as a whole, but with external dependencies mocked or stubbed. They test the integration between layers within your service.</p> <pre><code># tests/component/test_customer_service_component.py\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import AsyncMock, patch\n\nfrom src.presentation.main import app\nfrom src.domain.entities.customer import Customer\nfrom src.shared_kernel import CustomerId, Email\n\nclass TestCustomerServiceComponent:\n    \"\"\"Component tests for customer service functionality.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Set up test client and mocks.\"\"\"\n        self.client = TestClient(app)\n\n    @patch('src.presentation.repositories.get_customer_repository')\n    def test_create_customer_endpoint_success(self, mock_repo_factory):\n        \"\"\"Test customer creation through HTTP endpoint.\"\"\"\n        # Mock repository\n        mock_repo = AsyncMock()\n        mock_repo.find_by_email.return_value = None\n        mock_repo.save.side_effect = lambda c: c\n        mock_repo_factory.return_value = mock_repo\n\n        # Make request\n        response = self.client.post(\"/api/v1/customers/\", json={\n            \"name\": \"John Doe\",\n            \"email\": \"john@example.com\",\n            \"preferences\": {\"theme\": \"dark\"}\n        })\n\n        # Verify response\n        assert response.status_code == 201\n        data = response.json()\n        assert data[\"name\"] == \"John Doe\"\n        assert data[\"email\"] == \"john@example.com\"\n        assert data[\"is_active\"] is True\n        assert data[\"preferences\"] == {\"theme\": \"dark\"}\n\n        # Verify repository interaction\n        mock_repo.find_by_email.assert_called_once_with(\"john@example.com\")\n        mock_repo.save.assert_called_once()\n\n    @patch('src.presentation.repositories.get_customer_repository')\n    def test_create_customer_duplicate_email_error(self, mock_repo_factory):\n        \"\"\"Test customer creation with duplicate email returns error.\"\"\"\n        # Mock repository with existing customer\n        existing_customer = Customer.create(\n            customer_id=CustomerId(uuid4()),\n            name=\"Existing\",\n            email=Email(\"john@example.com\"),\n        )\n\n        mock_repo = AsyncMock()\n        mock_repo.find_by_email.return_value = existing_customer\n        mock_repo_factory.return_value = mock_repo\n\n        # Make request\n        response = self.client.post(\"/api/v1/customers/\", json={\n            \"name\": \"John Doe\",\n            \"email\": \"john@example.com\"\n        })\n\n        # Verify error response\n        assert response.status_code == 400\n        assert \"already exists\" in response.json()[\"detail\"]\n\n    @patch('src.presentation.repositories.get_customer_repository')\n    def test_get_customer_success(self, mock_repo_factory):\n        \"\"\"Test getting customer by ID.\"\"\"\n        # Mock customer\n        customer_id = CustomerId(uuid4())\n        customer = Customer.create(\n            customer_id=customer_id,\n            name=\"John Doe\",\n            email=Email(\"john@example.com\"),\n        )\n\n        mock_repo = AsyncMock()\n        mock_repo.find_by_id.return_value = customer\n        mock_repo_factory.return_value = mock_repo\n\n        # Make request\n        response = self.client.get(f\"/api/v1/customers/{customer_id.value}\")\n\n        # Verify response\n        assert response.status_code == 200\n        data = response.json()\n        assert data[\"name\"] == \"John Doe\"\n        assert data[\"email\"] == \"john@example.com\"\n\n    @patch('src.presentation.repositories.get_customer_repository')\n    def test_get_customer_not_found(self, mock_repo_factory):\n        \"\"\"Test getting non-existent customer returns 404.\"\"\"\n        mock_repo = AsyncMock()\n        mock_repo.find_by_id.return_value = None\n        mock_repo_factory.return_value = mock_repo\n\n        customer_id = uuid4()\n        response = self.client.get(f\"/api/v1/customers/{customer_id}\")\n\n        assert response.status_code == 404\n        assert \"not found\" in response.json()[\"detail\"]\n\n    def test_invalid_request_data_validation(self):\n        \"\"\"Test request validation for invalid data.\"\"\"\n        # Missing required fields\n        response = self.client.post(\"/api/v1/customers/\", json={\n            \"email\": \"john@example.com\"\n            # Missing name\n        })\n        assert response.status_code == 422\n\n        # Invalid email format\n        response = self.client.post(\"/api/v1/customers/\", json={\n            \"name\": \"John Doe\",\n            \"email\": \"invalid-email\"\n        })\n        assert response.status_code == 422\n\n        # Empty name\n        response = self.client.post(\"/api/v1/customers/\", json={\n            \"name\": \"\",\n            \"email\": \"john@example.com\"\n        })\n        assert response.status_code == 422\n</code></pre>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#integration-tests-real-infrastructure","title":"Integration Tests: Real Infrastructure","text":"<p>Integration tests verify that your service works with real infrastructure components like databases, message queues, and external services. They're slower and more complex but catch issues that mocks can't.</p> <pre><code># tests/integration/test_customer_repository_integration.py\nimport pytest\nimport asyncio\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker\nfrom testcontainers.postgres import PostgresContainer\n\nfrom src.domain.entities.customer import Customer\nfrom src.infrastructure.database.repositories.customer_repository_impl import (\n    CustomerRepositoryImpl,\n)\nfrom src.infrastructure.database.models.base import BaseModel\nfrom src.shared_kernel import CustomerId, Email, Address\n\nclass TestCustomerRepositoryIntegration:\n    \"\"\"Integration tests for customer repository with real database.\"\"\"\n\n    @pytest.fixture(scope=\"class\")\n    def postgres_container(self):\n        \"\"\"Create and manage PostgreSQL test container.\"\"\"\n        with PostgresContainer(\"postgres:15\") as postgres:\n            yield postgres\n\n    @pytest.fixture(scope=\"class\")\n    async def db_engine(self, postgres_container):\n        \"\"\"Create database engine for testing.\"\"\"\n        connection_url = postgres_container.get_connection_url().replace(\n            \"postgresql://\", \"postgresql+asyncpg://\"\n        )\n\n        engine = create_async_engine(connection_url)\n\n        # Create tables\n        async with engine.begin() as conn:\n            await conn.run_sync(BaseModel.metadata.create_all)\n\n        yield engine\n\n        await engine.dispose()\n\n    @pytest.fixture\n    async def db_session(self, db_engine):\n        \"\"\"Create database session for each test.\"\"\"\n        async_session = async_sessionmaker(db_engine)\n        session = async_session()\n\n        yield session\n\n        # Cleanup\n        await session.rollback()\n        await session.close()\n\n    @pytest.fixture\n    def repository(self, db_session):\n        \"\"\"Create repository instance.\"\"\"\n        return CustomerRepositoryImpl(db_session)\n\n    @pytest.mark.asyncio\n    async def test_save_and_find_customer(self, repository):\n        \"\"\"Test saving and finding a customer.\"\"\"\n        # Create customer\n        customer_id = CustomerId(uuid4())\n        email = Email(\"test@example.com\")\n        customer = Customer.create(\n            customer_id=customer_id,\n            name=\"John Doe\",\n            email=email,\n            preferences={\"theme\": \"dark\"},\n        )\n\n        # Save customer\n        saved_customer = await repository.save(customer)\n\n        # Verify save worked\n        assert saved_customer.customer_id == customer_id\n        assert saved_customer.name == \"John Doe\"\n        assert saved_customer.email == email\n        assert saved_customer.preferences == {\"theme\": \"dark\"}\n\n        # Find customer by ID\n        found_customer = await repository.find_by_id(customer_id)\n\n        # Verify find worked\n        assert found_customer is not None\n        assert found_customer.customer_id == customer_id\n        assert found_customer.name == \"John Doe\"\n        assert found_customer.email == email\n        assert found_customer.preferences == {\"theme\": \"dark\"}\n\n    @pytest.mark.asyncio\n    async def test_find_by_email(self, repository):\n        \"\"\"Test finding customer by email.\"\"\"\n        # Create and save customer\n        customer_id = CustomerId(uuid4())\n        email = Email(\"email-test@example.com\")\n        customer = Customer.create(\n            customer_id=customer_id,\n            name=\"Email Test\",\n            email=email,\n        )\n\n        await repository.save(customer)\n\n        # Find by email\n        found_customer = await repository.find_by_email(\"email-test@example.com\")\n\n        assert found_customer is not None\n        assert found_customer.customer_id == customer_id\n        assert found_customer.name == \"Email Test\"\n\n        # Test non-existent email\n        not_found = await repository.find_by_email(\"nonexistent@example.com\")\n        assert not_found is None\n\n    @pytest.mark.asyncio\n    async def test_find_all_active(self, repository):\n        \"\"\"Test finding all active customers.\"\"\"\n        # Create multiple customers\n        customers = []\n        for i in range(3):\n            customer_id = CustomerId(uuid4())\n            email = Email(f\"active-test-{i}@example.com\")\n            customer = Customer.create(\n                customer_id=customer_id,\n                name=f\"Active Customer {i}\",\n                email=email,\n            )\n            customers.append(customer)\n            await repository.save(customer)\n\n        # Deactivate one customer\n        deactivated = customers[0].deactivate(\"Test deactivation\")\n        await repository.save(deactivated)\n\n        # Find all active customers\n        active_customers = await repository.find_all_active()\n\n        # Should have 2 active customers (3 created, 1 deactivated)\n        assert len(active_customers) == 2\n\n        # Verify only active customers returned\n        for customer in active_customers:\n            assert customer.is_active is True\n\n    @pytest.mark.asyncio\n    async def test_customer_with_address(self, repository):\n        \"\"\"Test saving and retrieving customer with address.\"\"\"\n        # Create customer with address\n        customer_id = CustomerId(uuid4())\n        email = Email(\"address-test@example.com\")\n        address = Address(\n            street=\"123 Test St\",\n            city=\"Test City\",\n            state=\"TS\",\n            postal_code=\"12345\",\n            country=\"Test Country\",\n        )\n\n        customer = Customer.create(\n            customer_id=customer_id,\n            name=\"Address Test\",\n            email=email,\n            address=address,\n        )\n\n        # Save and retrieve\n        await repository.save(customer)\n        found_customer = await repository.find_by_id(customer_id)\n\n        # Verify address preserved\n        assert found_customer is not None\n        assert found_customer.address is not None\n        assert found_customer.address.street == \"123 Test St\"\n        assert found_customer.address.city == \"Test City\"\n        assert found_customer.address.country == \"Test Country\"\n\n    @pytest.mark.asyncio\n    async def test_concurrent_operations(self, repository):\n        \"\"\"Test concurrent repository operations.\"\"\"\n        # Create customers concurrently\n        async def create_customer(index):\n            customer_id = CustomerId(uuid4())\n            email = Email(f\"concurrent-{index}@example.com\")\n            customer = Customer.create(\n                customer_id=customer_id,\n                name=f\"Concurrent Customer {index}\",\n                email=email,\n            )\n            return await repository.save(customer)\n\n        # Create 10 customers concurrently\n        tasks = [create_customer(i) for i in range(10)]\n        created_customers = await asyncio.gather(*tasks)\n\n        # Verify all customers created\n        assert len(created_customers) == 10\n\n        # Verify all customers can be found\n        for customer in created_customers:\n            found = await repository.find_by_id(customer.customer_id)\n            assert found is not None\n            assert found.customer_id == customer.customer_id\n</code></pre>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#contract-tests-service-boundary-verification","title":"Contract Tests: Service Boundary Verification","text":"<p>Contract tests ensure that the interfaces between services remain compatible. They're particularly important in microservices architectures where services are developed by different teams.</p> <pre><code># tests/contract/test_customer_api_contract.py\nimport pytest\nfrom pact import Consumer, Provider, Like, Format\nfrom fastapi.testclient import TestClient\n\nfrom src.presentation.main import app\n\nclass TestCustomerAPIContract:\n    \"\"\"Contract tests for Customer API.\"\"\"\n\n    @pytest.fixture\n    def pact(self):\n        \"\"\"Set up Pact consumer.\"\"\"\n        return Consumer(\"customer-service\").has_pact_with(\n            Provider(\"customer-api\"),\n            host_name=\"localhost\",\n            port=1234\n        )\n\n    def test_create_customer_contract(self, pact):\n        \"\"\"Test customer creation API contract.\"\"\"\n        # Define expected interaction\n        (pact\n         .given(\"customer service is available\")\n         .upon_receiving(\"a request to create a customer\")\n         .with_request(\n             method=\"POST\",\n             path=\"/api/v1/customers/\",\n             headers={\"Content-Type\": \"application/json\"},\n             body={\n                 \"name\": \"John Doe\",\n                 \"email\": Format().email,\n                 \"preferences\": Like({\"theme\": \"dark\"})\n             }\n         )\n         .will_respond_with(\n             status=201,\n             headers={\"Content-Type\": \"application/json\"},\n             body={\n                 \"id\": Format().uuid,\n                 \"name\": \"John Doe\",\n                 \"email\": Format().email,\n                 \"is_active\": True,\n                 \"preferences\": Like({\"theme\": \"dark\"}),\n                 \"created_at\": Format().timestamp,\n                 \"updated_at\": Format().timestamp\n             }\n         ))\n\n        # Execute test\n        with pact:\n            client = TestClient(app)\n            response = client.post(\"/api/v1/customers/\", json={\n                \"name\": \"John Doe\",\n                \"email\": \"john@example.com\",\n                \"preferences\": {\"theme\": \"dark\"}\n            })\n\n            # Verify contract fulfilled\n            assert response.status_code == 201\n            data = response.json()\n            assert \"id\" in data\n            assert data[\"name\"] == \"John Doe\"\n            assert data[\"is_active\"] is True\n\n    def test_get_customer_contract(self, pact):\n        \"\"\"Test get customer API contract.\"\"\"\n        customer_id = \"550e8400-e29b-41d4-a716-446655440000\"\n\n        (pact\n         .given(f\"customer {customer_id} exists\")\n         .upon_receiving(\"a request to get a customer\")\n         .with_request(\n             method=\"GET\",\n             path=f\"/api/v1/customers/{customer_id}\"\n         )\n         .will_respond_with(\n             status=200,\n             headers={\"Content-Type\": \"application/json\"},\n             body={\n                 \"id\": Format().uuid,\n                 \"name\": Like(\"John Doe\"),\n                 \"email\": Format().email,\n                 \"is_active\": True,\n                 \"preferences\": Like({}),\n                 \"created_at\": Format().timestamp,\n                 \"updated_at\": Format().timestamp\n             }\n         ))\n\n        # Execute test\n        with pact:\n            client = TestClient(app)\n            response = client.get(f\"/api/v1/customers/{customer_id}\")\n\n            assert response.status_code == 200\n            data = response.json()\n            assert \"id\" in data\n            assert \"name\" in data\n            assert \"email\" in data\n</code></pre>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#infrastructure-testing-external-dependencies","title":"Infrastructure Testing: External Dependencies","text":"<p>Test your infrastructure components and external integrations:</p> <pre><code># tests/infrastructure/test_logging_integration.py\nclass TestLoggingInfrastructure:\n    \"\"\"Test logging infrastructure functionality.\"\"\"\n\n    @patch(\"src.infrastructure.logging.config._is_running_locally\")\n    def test_get_logger_default_config(self, mock_is_local: Any) -&gt; None:\n        \"\"\"Test getting logger with default configuration.\"\"\"\n        # Force AWS environment detection for consistent test behavior\n        mock_is_local.return_value = False\n\n        logger = get_logger(\"test.module\")\n\n        assert isinstance(logger, logging.Logger)\n        assert logger.name == \"test.module\"\n        assert logger.level == logging.INFO  # Default level\n\n    def test_get_logger_custom_config(self):\n        \"\"\"Test getting logger with custom configuration.\"\"\"\n        config = LogConfig(level=LogLevel.DEBUG, service_name=\"custom-service\")\n\n        logger = get_logger(\"test.module\", config)\n\n        assert logger.level == logging.DEBUG\n\n    def test_correlation_id_in_logs(self):\n        \"\"\"Test that correlation IDs appear in formatted logs.\"\"\"\n        from src.infrastructure.logging.correlation import CorrelationContext\n\n        # Configure logging\n        configure_logging()\n        logger = get_application_logger(\"correlation.test\")\n\n        # Set correlation ID\n        test_correlation_id = \"integration-correlation-123\"\n        CorrelationContext.set(test_correlation_id)\n\n        # Capture log output\n        with patch(\"sys.stdout\"):\n            logger.info(\"Test message with correlation\")\n\n        # Verify correlation ID is included\n        assert logger is not None\n\n        # Clean up\n        CorrelationContext.set(None)\n\n    @patch(\"src.infrastructure.logging.logger.get_cloudwatch_handler\")\n    def test_configure_logging_with_cloudwatch(self, mock_cloudwatch_handler: Any) -&gt; None:\n        \"\"\"Test logging configuration with CloudWatch enabled.\"\"\"\n        # Mock CloudWatch handler\n        mock_handler = Mock(spec=logging.Handler)\n        mock_handler.level = logging.INFO\n        mock_cloudwatch_handler.return_value = mock_handler\n\n        config = LogConfig(\n            environment=Environment.PRODUCTION,\n            cloudwatch_enabled=True,\n            cloudwatch_log_group=\"/test/logs\",\n        )\n\n        configure_logging(config)\n\n        # CloudWatch handler should have been requested\n        assert mock_cloudwatch_handler.call_count &gt;= 1\n\n        # Root logger should have both console and CloudWatch handlers\n        root_logger = logging.getLogger()\n        assert len(root_logger.handlers) &gt;= 2\n</code></pre>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#end-to-end-tests-full-system-verification","title":"End-to-End Tests: Full System Verification","text":"<p>E2E tests verify complete user workflows across all services:</p> <pre><code># tests/e2e/test_customer_workflow.py\nimport pytest\nimport asyncio\nfrom httpx import AsyncClient\nfrom testcontainers.compose import DockerCompose\n\nclass TestCustomerWorkflowE2E:\n    \"\"\"End-to-end tests for customer workflows.\"\"\"\n\n    @pytest.fixture(scope=\"class\")\n    async def test_environment(self):\n        \"\"\"Set up complete test environment with Docker Compose.\"\"\"\n        compose = DockerCompose(\n            filepath=\".\", \n            compose_file_name=\"docker-compose.test.yml\"\n        )\n\n        with compose:\n            # Wait for services to be ready\n            await asyncio.sleep(10)\n\n            # Get service URLs\n            customer_service_url = f\"http://localhost:{compose.get_service_port('customer-service', 8000)}\"\n\n            yield {\n                \"customer_service\": customer_service_url\n            }\n\n    @pytest.mark.asyncio\n    async def test_complete_customer_lifecycle(self, test_environment):\n        \"\"\"Test complete customer lifecycle end-to-end.\"\"\"\n        base_url = test_environment[\"customer_service\"]\n\n        async with AsyncClient(base_url=base_url) as client:\n            # 1. Create customer\n            create_response = await client.post(\"/api/v1/customers/\", json={\n                \"name\": \"E2E Test Customer\",\n                \"email\": \"e2e-test@example.com\",\n                \"preferences\": {\"theme\": \"dark\", \"newsletter\": True}\n            })\n\n            assert create_response.status_code == 201\n            customer_data = create_response.json()\n            customer_id = customer_data[\"id\"]\n\n            # Verify customer created correctly\n            assert customer_data[\"name\"] == \"E2E Test Customer\"\n            assert customer_data[\"email\"] == \"e2e-test@example.com\"\n            assert customer_data[\"is_active\"] is True\n            assert customer_data[\"preferences\"][\"theme\"] == \"dark\"\n\n            # 2. Retrieve customer\n            get_response = await client.get(f\"/api/v1/customers/{customer_id}\")\n\n            assert get_response.status_code == 200\n            retrieved_customer = get_response.json()\n            assert retrieved_customer[\"id\"] == customer_id\n            assert retrieved_customer[\"name\"] == \"E2E Test Customer\"\n\n            # 3. Search for customer\n            search_response = await client.get(\n                \"/api/v1/customers/\", \n                params={\"email\": \"e2e-test\"}\n            )\n\n            assert search_response.status_code == 200\n            search_results = search_response.json()\n            assert len(search_results) &gt;= 1\n\n            # Find our customer in results\n            found_customer = next(\n                (c for c in search_results if c[\"id\"] == customer_id), \n                None\n            )\n            assert found_customer is not None\n\n            # 4. Update customer preferences\n            update_response = await client.put(\n                f\"/api/v1/customers/{customer_id}\", \n                json={\n                    \"preferences\": {\"theme\": \"light\", \"newsletter\": False}\n                }\n            )\n\n            assert update_response.status_code == 200\n            updated_customer = update_response.json()\n            assert updated_customer[\"preferences\"][\"theme\"] == \"light\"\n            assert updated_customer[\"preferences\"][\"newsletter\"] is False\n\n            # 5. Deactivate customer\n            deactivate_response = await client.post(\n                f\"/api/v1/customers/{customer_id}/deactivate\",\n                json={\"reason\": \"E2E test cleanup\"}\n            )\n\n            assert deactivate_response.status_code == 200\n            deactivated_customer = deactivate_response.json()\n            assert deactivated_customer[\"is_active\"] is False\n\n            # 6. Verify deactivated customer not in active search\n            active_search_response = await client.get(\n                \"/api/v1/customers/\",\n                params={\"active_only\": True}\n            )\n\n            assert active_search_response.status_code == 200\n            active_customers = active_search_response.json()\n\n            # Our deactivated customer should not be in active results\n            deactivated_found = any(\n                c[\"id\"] == customer_id for c in active_customers\n            )\n            assert deactivated_found is False\n\n    @pytest.mark.asyncio\n    async def test_customer_order_integration(self, test_environment):\n        \"\"\"Test customer and order service integration.\"\"\"\n        customer_base_url = test_environment[\"customer_service\"]\n        order_base_url = test_environment.get(\"order_service\", customer_base_url)\n\n        async with AsyncClient() as client:\n            # 1. Create customer\n            customer_response = await client.post(\n                f\"{customer_base_url}/api/v1/customers/\",\n                json={\n                    \"name\": \"Order Test Customer\",\n                    \"email\": \"order-test@example.com\"\n                }\n            )\n\n            assert customer_response.status_code == 201\n            customer_id = customer_response.json()[\"id\"]\n\n            # 2. Create order for customer\n            order_response = await client.post(\n                f\"{order_base_url}/api/v1/orders/\",\n                json={\n                    \"customer_id\": customer_id,\n                    \"total_amount\": {\"amount\": \"99.99\", \"currency\": \"USD\"},\n                    \"details\": {\n                        \"items\": [\n                            {\"product\": \"Test Product\", \"quantity\": 1, \"price\": \"99.99\"}\n                        ]\n                    }\n                }\n            )\n\n            assert order_response.status_code == 201\n            order_data = order_response.json()\n            order_id = order_data[\"id\"]\n\n            # 3. Get customer orders\n            customer_orders_response = await client.get(\n                f\"{order_base_url}/api/v1/customers/{customer_id}/orders\"\n            )\n\n            assert customer_orders_response.status_code == 200\n            customer_orders = customer_orders_response.json()\n            assert len(customer_orders) &gt;= 1\n\n            # Find our order\n            found_order = next(\n                (o for o in customer_orders if o[\"id\"] == order_id),\n                None\n            )\n            assert found_order is not None\n            assert found_order[\"customer_id\"] == customer_id\n</code></pre>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#test-data-management","title":"Test Data Management","text":"<p>Effective testing requires proper test data management:</p> <pre><code># tests/factories/customer_factory.py\nfrom factory import Factory, Sequence, SubFactory, LazyFunction\nfrom factory.fuzzy import FuzzyChoice, FuzzyDecimal\nfrom decimal import Decimal\nfrom uuid import uuid4\n\nfrom src.domain.entities.customer import Customer\nfrom src.shared_kernel import CustomerId, Email, Address, Money\n\nclass AddressFactory(Factory):\n    \"\"\"Factory for creating test addresses.\"\"\"\n\n    class Meta:\n        model = Address\n\n    street = Sequence(lambda n: f\"{n} Test Street\")\n    city = FuzzyChoice([\"New York\", \"Los Angeles\", \"Chicago\", \"Houston\"])\n    state = FuzzyChoice([\"NY\", \"CA\", \"IL\", \"TX\"])\n    postal_code = Sequence(lambda n: f\"{n:05d}\")\n    country = \"USA\"\n    apartment = FuzzyChoice([None, \"1A\", \"2B\", \"3C\"])\n\nclass EmailFactory(Factory):\n    \"\"\"Factory for creating test emails.\"\"\"\n\n    class Meta:\n        model = Email\n\n    value = Sequence(lambda n: f\"test-user-{n}@example.com\")\n\nclass MoneyFactory(Factory):\n    \"\"\"Factory for creating test money values.\"\"\"\n\n    class Meta:\n        model = Money\n\n    amount = FuzzyDecimal(1, 1000, 2)\n    currency = FuzzyChoice([\"USD\", \"EUR\", \"GBP\"])\n\nclass CustomerFactory(Factory):\n    \"\"\"Factory for creating test customers.\"\"\"\n\n    class Meta:\n        model = Customer\n\n    customer_id = LazyFunction(lambda: CustomerId(uuid4()))\n    name = Sequence(lambda n: f\"Test Customer {n}\")\n    email = SubFactory(EmailFactory)\n    address = SubFactory(AddressFactory)\n    is_active = True\n    preferences = {\"theme\": \"light\", \"newsletter\": True}\n\n# Usage in tests\ndef test_customer_with_factory():\n    \"\"\"Test using factory-created customer.\"\"\"\n    customer = CustomerFactory()\n\n    assert customer.name.startswith(\"Test Customer\")\n    assert \"@example.com\" in str(customer.email)\n    assert customer.is_active is True\n\ndef test_customer_with_custom_attributes():\n    \"\"\"Test factory with custom attributes.\"\"\"\n    customer = CustomerFactory(\n        name=\"Custom Customer\",\n        preferences={\"theme\": \"dark\"}\n    )\n\n    assert customer.name == \"Custom Customer\"\n    assert customer.preferences[\"theme\"] == \"dark\"\n\ndef test_multiple_customers():\n    \"\"\"Test creating multiple customers.\"\"\"\n    customers = CustomerFactory.create_batch(5)\n\n    assert len(customers) == 5\n    # All should have unique emails\n    emails = [str(c.email) for c in customers]\n    assert len(set(emails)) == 5\n</code></pre>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#testing-configuration-and-best-practices","title":"Testing Configuration and Best Practices","text":"","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#pytest-configuration","title":"Pytest Configuration","text":"<pre><code># pytest.ini\n[tool:pytest]\nminversion = 6.0\naddopts = \n    -v\n    --strict-markers\n    --strict-config\n    --cov=src\n    --cov-report=term-missing\n    --cov-report=html\n    --cov-fail-under=80\ntestpaths = tests\nmarkers =\n    unit: Unit tests\n    integration: Integration tests  \n    component: Component tests\n    e2e: End-to-end tests\n    slow: Slow running tests\n    contract: Contract tests\nasyncio_mode = auto\n</code></pre>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#test-organization","title":"Test Organization","text":"<pre><code># conftest.py - Shared test configuration\nimport pytest\nimport asyncio\nfrom typing import AsyncGenerator\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    \"\"\"Create event loop for async tests.\"\"\"\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n@pytest.fixture\nasync def clean_database():\n    \"\"\"Ensure clean database state for each test.\"\"\"\n    # Setup\n    await cleanup_test_data()\n\n    yield\n\n    # Teardown\n    await cleanup_test_data()\n\n@pytest.fixture\ndef mock_external_services():\n    \"\"\"Mock all external service dependencies.\"\"\"\n    with patch('src.infrastructure.services.payment_service') as payment_mock, \\\n         patch('src.infrastructure.services.email_service') as email_mock:\n\n        payment_mock.charge.return_value = {\"success\": True, \"transaction_id\": \"test_123\"}\n        email_mock.send_email.return_value = True\n\n        yield {\n            \"payment\": payment_mock,\n            \"email\": email_mock\n        }\n</code></pre>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#performance-testing","title":"Performance Testing","text":"<pre><code># tests/performance/test_customer_performance.py\nimport pytest\nimport asyncio\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass TestCustomerPerformance:\n    \"\"\"Performance tests for customer operations.\"\"\"\n\n    @pytest.mark.slow\n    async def test_customer_creation_performance(self, repository):\n        \"\"\"Test customer creation performance under load.\"\"\"\n        start_time = time.time()\n\n        # Create 100 customers concurrently\n        tasks = []\n        for i in range(100):\n            customer = CustomerFactory()\n            tasks.append(repository.save(customer))\n\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n\n        end_time = time.time()\n        duration = end_time - start_time\n\n        # Verify performance\n        assert duration &lt; 5.0, f\"Customer creation took {duration}s, expected &lt; 5s\"\n\n        # Verify all succeeded\n        errors = [r for r in results if isinstance(r, Exception)]\n        assert len(errors) == 0, f\"Had {len(errors)} errors during creation\"\n\n    @pytest.mark.slow\n    def test_customer_search_performance(self, repository):\n        \"\"\"Test customer search performance.\"\"\"\n        # Setup: Create many customers\n        customers = CustomerFactory.create_batch(1000)\n        for customer in customers:\n            repository.save(customer)\n\n        # Test search performance\n        start_time = time.time()\n\n        # Perform 100 searches\n        with ThreadPoolExecutor(max_workers=10) as executor:\n            futures = []\n            for i in range(100):\n                future = executor.submit(repository.find_all_active)\n                futures.append(future)\n\n            results = [f.result() for f in futures]\n\n        end_time = time.time()\n        duration = end_time - start_time\n\n        # Verify performance\n        assert duration &lt; 10.0, f\"Search operations took {duration}s, expected &lt; 10s\"\n\n        # Verify results\n        assert all(len(r) &gt;= 1000 for r in results)\n</code></pre>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#continuous-testing-strategy","title":"Continuous Testing Strategy","text":"","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<pre><code># .github/workflows/test.yml\nname: Test Suite\non: [push, pull_request]\n\njobs:\n  unit-tests:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n      - name: Install dependencies\n        run: |\n          pip install -r requirements.txt\n          pip install -r requirements-dev.txt\n      - name: Run unit tests\n        run: pytest tests/unit -m \"not slow\" --cov=src --cov-report=xml\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n\n  integration-tests:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_PASSWORD: test\n        options: &gt;-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n      - name: Install dependencies\n        run: |\n          pip install -r requirements.txt\n          pip install -r requirements-dev.txt\n      - name: Run integration tests\n        run: pytest tests/integration\n        env:\n          DATABASE_URL: postgresql://postgres:test@localhost:5432/test\n\n  component-tests:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n      - name: Install dependencies\n        run: |\n          pip install -r requirements.txt\n          pip install -r requirements-dev.txt\n      - name: Run component tests\n        run: pytest tests/component\n\n  e2e-tests:\n    runs-on: ubuntu-latest\n    if: github.event_name == 'push' &amp;&amp; github.ref == 'refs/heads/main'\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v2\n      - name: Run E2E tests\n        run: |\n          docker-compose -f docker-compose.test.yml up --build --abort-on-container-exit\n          docker-compose -f docker-compose.test.yml down\n</code></pre>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#conclusion","title":"Conclusion","text":"<p>A comprehensive testing strategy for microservices isn't just about writing tests\u2014it's about building confidence in your system at every level. The clean-py repository demonstrates how Clean Architecture naturally supports testing by creating clear boundaries and minimizing dependencies.</p> <p>Key principles for effective microservice testing:</p> <ul> <li>Fast Feedback: Unit tests provide immediate feedback during development</li> <li>Isolated Testing: Each layer can be tested independently with appropriate mocks</li> <li>Real Integration: Integration tests catch issues mocks can't reveal</li> <li>Contract Verification: Contract tests ensure service compatibility</li> <li>End-to-End Validation: E2E tests verify complete user workflows</li> <li>Performance Monitoring: Performance tests catch degradation early</li> <li>Continuous Validation: Automated testing in CI/CD pipelines</li> </ul> <p>The testing pyramid for microservices emphasizes having many fast, cheap unit tests at the base, with fewer expensive integration and E2E tests at the top. This approach maximizes confidence while minimizing execution time and maintenance overhead.</p> <p>In the next post, we'll explore Code Quality Automation, showing how to automate code quality checks, formatting, and static analysis to maintain high standards across your Python microservices.</p>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/26/testing-strategy-for-python-microservices---building-confidence-through-systematic-testing/#references","title":"References","text":"<ul> <li>Clean-Py Repository - Complete testing strategy implementation</li> <li>PyTest Documentation - Python testing framework</li> <li>Testing Pyramid - Martin Fowler's testing guide</li> <li>Testcontainers Python - Integration testing with Docker</li> </ul> <p>Remember: Tests aren't just about finding bugs\u2014they're about building confidence to change and deploy your code safely.</p>","tags":["testing","microservices","python","clean-py","test-strategy"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/","title":"Code Quality Automation: Pre-commit Hooks and CI/CD","text":"<p>Code quality isn't about perfection\u2014it's about consistency. I've worked on teams where every developer had their own formatting style, their own import organization, their own naming conventions. Code reviews devolved into style debates instead of logic discussions. Time was wasted on manual formatting instead of solving problems.</p> <p>The clean-py repository demonstrates how automation eliminates these issues entirely. Quality checks run automatically. Formatting happens without thinking. Security scans catch vulnerabilities before they reach production. This isn't about replacing human judgment\u2014it's about freeing humans to focus on what matters.</p>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#the-cost-of-manual-quality-control","title":"The Cost of Manual Quality Control","text":"<p>Let me paint a familiar picture. A developer submits a pull request. The reviewer spots inconsistent formatting. \"Please run Black,\" they comment. The developer formats the code, pushes again. Now there's a linting error. Another round trip. Then someone notices the imports aren't sorted. Another push. Finally, the actual logic review begins\u2014but everyone's already frustrated.</p> <p>I've seen this pattern waste days per sprint. Worse, when developers are tired or rushed, quality checks get skipped. \"We'll fix it later,\" becomes technical debt that never gets paid.</p> <p>Manual quality control has hidden costs: - Context switching: Developers break flow to run quality tools - Inconsistent application: Some files get checked, others don't - Review fatigue: Reviewers waste energy on mechanical issues - Delayed feedback: Problems found late in the process are expensive to fix - Knowledge silos: Only certain developers know all the quality rules</p>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#pre-commit-hooks-your-first-line-of-defense","title":"Pre-commit Hooks: Your First Line of Defense","text":"<p>Pre-commit hooks solve these problems by running quality checks automatically before code enters the repository. The clean-py repository uses a comprehensive pre-commit configuration:</p> <pre><code># .pre-commit-config.yaml\ndefault_language_version:\n  python: python3.11\n\nrepos:\n  # General file fixes\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.5.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n        args: ['--unsafe']  # Allow custom tags\n      - id: check-json\n      - id: check-toml\n      - id: check-added-large-files\n        args: ['--maxkb=1000']\n      - id: check-case-conflict\n      - id: check-merge-conflict\n      - id: detect-private-key\n      - id: debug-statements\n      - id: mixed-line-ending\n        args: ['--fix=lf']\n\n  # Python code formatting\n  - repo: https://github.com/psf/black\n    rev: 23.11.0\n    hooks:\n      - id: black\n        language_version: python3.11\n        args: ['--line-length=88']\n\n  # Python import sorting\n  - repo: https://github.com/pycqa/isort\n    rev: 5.12.0\n    hooks:\n      - id: isort\n        args: [\"--profile\", \"black\", \"--line-length\", \"88\"]\n\n  # Python linting with Ruff (fast!)\n  - repo: https://github.com/charliermarsh/ruff-pre-commit\n    rev: v0.1.6\n    hooks:\n      - id: ruff\n        args: [--fix, --exit-non-zero-on-fix]\n\n  # Security scanning\n  - repo: https://github.com/PyCQA/bandit\n    rev: 1.7.5\n    hooks:\n      - id: bandit\n        args: ['-r', 'src', '-ll', '--skip', 'B101']\n        exclude: tests/\n\n  # Type checking\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.7.1\n    hooks:\n      - id: mypy\n        additional_dependencies: [\n          types-requests,\n          types-redis,\n          types-python-jose,\n          types-passlib\n        ]\n        args: [--strict, --ignore-missing-imports]\n        exclude: tests/\n\n  # Upgrade Python syntax\n  - repo: https://github.com/asottile/pyupgrade\n    rev: v3.15.0\n    hooks:\n      - id: pyupgrade\n        args: [--py311-plus]\n\n  # Check for common security issues\n  - repo: https://github.com/Lucas-C/pre-commit-hooks-safety\n    rev: v1.3.2\n    hooks:\n      - id: python-safety-dependencies-check\n        files: pyproject.toml\n\n  # Custom local hooks\n  - repo: local\n    hooks:\n      - id: no-print-statements\n        name: Check for print statements\n        entry: '(?&lt;!def )print\\('\n        language: pygrep\n        types: [python]\n        exclude: (scripts/|examples/)\n\n      - id: no-fixme-comments\n        name: Check for FIXME comments\n        entry: '(FIXME|TODO|HACK|XXX):'\n        language: pygrep\n        types: [python]\n        pass_filenames: true\n\n      - id: pytest-check\n        name: Run fast unit tests\n        entry: pytest\n        language: system\n        pass_filenames: false\n        always_run: true\n        args: [tests/unit, -x, --tb=short, --quiet]\n</code></pre> <p>Setting up pre-commit is straightforward:</p> <pre><code># Install pre-commit\npip install pre-commit\n\n# Install the git hooks\npre-commit install\n\n# Run against all files (useful for initial setup)\npre-commit run --all-files\n\n# Update hook versions\npre-commit autoupdate\n</code></pre> <p>Now every commit automatically: - Formats code with Black - Sorts imports with isort - Fixes file issues (whitespace, line endings) - Runs security scans - Checks types - Runs fast unit tests</p> <p>If any check fails, the commit is blocked with clear feedback:</p> <pre><code>$ git commit -m \"Add new feature\"\nblack....................................................................Passed\nisort....................................................................Passed\nruff.....................................................................Failed\n- hook id: ruff\n- exit code: 1\n\nsrc/api/endpoints.py:45:80: E501 Line too long (92 &gt; 88 characters)\n\nmypy.....................................................................Failed\n- hook id: mypy\n- exit code: 1\n\nsrc/services/order.py:23: error: Argument 1 to \"process\" has incompatible type \"str\"; expected \"UUID\"\n</code></pre>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#ruff-the-fast-python-linter","title":"Ruff: The Fast Python Linter","text":"<p>Ruff has revolutionized Python linting by being 10-100x faster than traditional tools. The clean-py repository uses Ruff extensively:</p> <pre><code># pyproject.toml\n[tool.ruff]\ntarget-version = \"py311\"\nline-length = 88\nselect = [\n    \"E\",   # pycodestyle errors\n    \"W\",   # pycodestyle warnings\n    \"F\",   # pyflakes\n    \"I\",   # isort\n    \"B\",   # flake8-bugbear\n    \"C4\",  # flake8-comprehensions\n    \"UP\",  # pyupgrade\n    \"ARG\", # flake8-unused-arguments\n    \"SIM\", # flake8-simplify\n    \"TCH\", # flake8-type-checking\n    \"DTZ\", # flake8-datetimez\n    \"ERA\", # flake8-eradicate\n    \"PTH\", # flake8-use-pathlib\n    \"RUF\", # Ruff-specific rules\n]\nignore = [\n    \"E501\",   # line too long (handled by black)\n    \"B008\",   # do not perform function calls in argument defaults\n    \"C901\",   # too complex\n    \"W191\",   # indentation contains tabs\n]\n\n[tool.ruff.per-file-ignores]\n\"tests/*\" = [\"S101\", \"ARG\", \"PLR2004\"]  # Allow assert, unused args, magic values in tests\n\"scripts/*\" = [\"T201\"]  # Allow print statements in scripts\n\n[tool.ruff.isort]\nknown-first-party = [\"src\"]\n\n[tool.ruff.mccabe]\nmax-complexity = 10\n\n[tool.ruff.flake8-bugbear]\nextend-immutable-calls = [\"fastapi.Depends\", \"fastapi.Query\"]\n\n[tool.ruff.flake8-type-checking]\nstrict = true\n</code></pre> <p>Ruff catches real issues fast:</p> <pre><code># Before Ruff\ndef process_order(order_id, customer_id, items=[]):  # B006: mutable default\n    if not len(items):  # SIM108: Use 'if not items'\n        return None\n\n    total = 0\n    for item in items:\n        total = total + item.price  # SIM113: Use += operator\n\n    # Create datetime without timezone (DTZ001)\n    created = datetime.datetime.now()\n\n    # Using os.path instead of pathlib (PTH118)\n    import os\n    config_file = os.path.join(os.path.dirname(__file__), \"config.json\")\n\n# After Ruff fixes\nfrom pathlib import Path\nfrom datetime import datetime, timezone\n\ndef process_order(order_id, customer_id, items=None):\n    if items is None:\n        items = []\n\n    if not items:\n        return None\n\n    total = sum(item.price for item in items)\n\n    created = datetime.now(timezone.utc)\n\n    config_file = Path(__file__).parent / \"config.json\"\n</code></pre>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#github-actions-cicd-pipeline","title":"GitHub Actions: CI/CD Pipeline","text":"<p>Pre-commit hooks are great, but they can be bypassed. CI/CD provides the final quality gate. Here's a comprehensive GitHub Actions workflow:</p> <pre><code># .github/workflows/ci.yml\nname: CI Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n  schedule:\n    - cron: '0 0 * * 0'  # Weekly security scan\n\nenv:\n  PYTHON_VERSION: \"3.11\"\n  POETRY_VERSION: \"1.6.1\"\n\njobs:\n  quality:\n    name: Code Quality Checks\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0  # Full history for better analysis\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n\n      - name: Cache dependencies\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.cache/pip\n            ~/.cache/pre-commit\n          key: ${{ runner.os }}-pip-${{ hashFiles('pyproject.toml') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -e \".[dev]\"\n\n      - name: Run pre-commit hooks\n        run: pre-commit run --all-files --show-diff-on-failure\n\n      - name: Run Black check\n        run: black --check src tests\n\n      - name: Run Ruff linting\n        run: ruff check src tests\n\n      - name: Run MyPy type checking\n        run: mypy src --strict\n\n  security:\n    name: Security Scanning\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n\n      - name: Install dependencies\n        run: |\n          pip install -e \".[dev]\"\n          pip install bandit safety pip-audit\n\n      - name: Run Bandit security linter\n        run: bandit -r src -f json -o bandit-report.json\n\n      - name: Upload Bandit report\n        uses: actions/upload-artifact@v3\n        with:\n          name: bandit-report\n          path: bandit-report.json\n\n      - name: Run Safety check\n        run: safety check --json &gt; safety-report.json\n        continue-on-error: true\n\n      - name: Run pip-audit\n        run: pip-audit --desc\n\n      - name: Run Trivy vulnerability scanner\n        uses: aquasecurity/trivy-action@master\n        with:\n          scan-type: 'fs'\n          scan-ref: '.'\n          format: 'sarif'\n          output: 'trivy-results.sarif'\n\n      - name: Upload Trivy results to GitHub Security\n        uses: github/codeql-action/upload-sarif@v2\n        with:\n          sarif_file: 'trivy-results.sarif'\n\n  test:\n    name: Test Suite\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"3.11\", \"3.12\"]\n\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_PASSWORD: postgres\n          POSTGRES_DB: test_db\n        options: &gt;-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 5432:5432\n\n      redis:\n        image: redis:7\n        options: &gt;-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 6379:6379\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Install dependencies\n        run: |\n          pip install -e \".[dev]\"\n\n      - name: Run unit tests\n        run: |\n          pytest tests/unit \\\n            --cov=src \\\n            --cov-report=xml \\\n            --cov-report=term-missing \\\n            --junit-xml=unit-test-results.xml\n\n      - name: Run integration tests\n        env:\n          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db\n          REDIS_URL: redis://localhost:6379\n        run: |\n          pytest tests/integration \\\n            --junit-xml=integration-test-results.xml\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          file: ./coverage.xml\n          fail_ci_if_error: true\n\n      - name: Upload test results\n        uses: actions/upload-artifact@v3\n        if: always()\n        with:\n          name: test-results-${{ matrix.python-version }}\n          path: |\n            unit-test-results.xml\n            integration-test-results.xml\n\n  build:\n    name: Build and Push Docker Image\n    needs: [quality, security, test]\n    runs-on: ubuntu-latest\n    if: github.event_name == 'push' &amp;&amp; github.ref == 'refs/heads/main'\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@v3\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Extract metadata\n        id: meta\n        uses: docker/metadata-action@v5\n        with:\n          images: ${{ secrets.DOCKER_USERNAME }}/clean-py\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            type=sha\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v5\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n</code></pre>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#make-unified-task-runner","title":"Make: Unified Task Runner","text":"<p>Make provides a consistent interface for all quality tasks:</p> <pre><code># Makefile\n.PHONY: quality\nquality: format lint type-check security test ## Run all quality checks\n\n.PHONY: format\nformat: ## Format code with black and isort\n    @echo \"\ud83c\udfa8 Formatting code...\"\n    black src tests\n    isort src tests\n    ruff check --fix src tests\n\n.PHONY: lint\nlint: ## Run linting checks\n    @echo \"\ud83d\udd0d Running linting checks...\"\n    ruff check src tests\n    pylint src --rcfile=.pylintrc\n\n.PHONY: type-check\ntype-check: ## Run type checking with mypy\n    @echo \"\ud83d\udcdd Running type checks...\"\n    mypy src --strict\n\n.PHONY: security\nsecurity: ## Run security checks\n    @echo \"\ud83d\udd12 Running security checks...\"\n    bandit -r src -ll\n    safety check\n    pip-audit\n\n.PHONY: test\ntest: ## Run tests with coverage\n    @echo \"\ud83e\uddea Running tests...\"\n    pytest tests/unit --cov=src --cov-report=term-missing\n\n.PHONY: test-watch\ntest-watch: ## Run tests in watch mode\n    ptw tests/unit -- -x --tb=short\n\n.PHONY: ci\nci: ## Run CI pipeline locally\n    @echo \"\ud83d\ude80 Running CI pipeline...\"\n    pre-commit run --all-files\n    $(MAKE) quality\n\n.PHONY: update-deps\nupdate-deps: ## Update dependencies\n    @echo \"\ud83d\udce6 Updating dependencies...\"\n    pip install --upgrade pip setuptools wheel\n    pip install --upgrade -e \".[dev]\"\n    pre-commit autoupdate\n    safety check\n\n.PHONY: clean\nclean: ## Clean temporary files\n    @echo \"\ud83e\uddf9 Cleaning up...\"\n    find . -type d -name \"__pycache__\" -exec rm -rf {} +\n    find . -type f -name \"*.pyc\" -delete\n    rm -rf .pytest_cache .mypy_cache .ruff_cache\n    rm -rf htmlcov .coverage coverage.xml\n</code></pre>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#advanced-quality-patterns","title":"Advanced Quality Patterns","text":"","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#1-complexity-analysis","title":"1. Complexity Analysis","text":"<p>Monitor code complexity to prevent unmaintainable code:</p> <pre><code># .github/workflows/complexity.yml\n- name: Run complexity analysis\n  run: |\n    radon cc src --min B --show-complexity --total-average\n    radon mi src --min B --show\n    xenon --max-absolute B --max-modules B --max-average A src\n</code></pre>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#2-documentation-coverage","title":"2. Documentation Coverage","text":"<p>Ensure code is properly documented:</p> <pre><code># pyproject.toml\n[tool.interrogate]\nignore-init-method = true\nignore-init-module = false\nignore-magic = false\nignore-semiprivate = false\nignore-private = false\nignore-property-decorators = false\nignore-module = false\nfail-under = 80\nexclude = [\"setup.py\", \"docs\", \"build\", \"tests\"]\nverbose = 0\nquiet = false\nwhitelist-regex = []\ncolor = true\n</code></pre>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#3-dependency-license-checking","title":"3. Dependency License Checking","text":"<p>Ensure dependencies have compatible licenses:</p> <pre><code># .github/workflows/license-check.yml\n- name: Check dependency licenses\n  run: |\n    pip install pip-licenses\n    pip-licenses --with-license-file --format=json &gt; licenses.json\n    python scripts/check_licenses.py licenses.json\n</code></pre>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#4-performance-regression-detection","title":"4. Performance Regression Detection","text":"<p>Catch performance issues before production:</p> <pre><code># tests/performance/test_benchmarks.py\nimport pytest\nfrom pytest_benchmark.plugin import benchmark\n\ndef test_order_processing_performance(benchmark):\n    result = benchmark(process_large_order, order_data)\n    assert result.total &lt; 1000  # Must process in under 1 second\n</code></pre>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#quality-metrics-and-reporting","title":"Quality Metrics and Reporting","text":"<p>Track quality metrics over time:</p> <pre><code># scripts/quality_report.py\nimport json\nimport subprocess\nfrom pathlib import Path\n\ndef generate_quality_report():\n    report = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"metrics\": {}\n    }\n\n    # Code coverage\n    coverage_result = subprocess.run(\n        [\"coverage\", \"report\", \"--format=json\"],\n        capture_output=True,\n        text=True\n    )\n    report[\"metrics\"][\"coverage\"] = json.loads(coverage_result.stdout)\n\n    # Complexity\n    radon_result = subprocess.run(\n        [\"radon\", \"cc\", \"src\", \"--json\"],\n        capture_output=True,\n        text=True\n    )\n    report[\"metrics\"][\"complexity\"] = json.loads(radon_result.stdout)\n\n    # Security issues\n    bandit_result = subprocess.run(\n        [\"bandit\", \"-r\", \"src\", \"-f\", \"json\"],\n        capture_output=True,\n        text=True\n    )\n    report[\"metrics\"][\"security\"] = json.loads(bandit_result.stdout)\n\n    # Save report\n    reports_dir = Path(\"quality-reports\")\n    reports_dir.mkdir(exist_ok=True)\n\n    report_file = reports_dir / f\"report-{datetime.now():%Y%m%d-%H%M%S}.json\"\n    report_file.write_text(json.dumps(report, indent=2))\n\n    return report\n\nif __name__ == \"__main__\":\n    report = generate_quality_report()\n    print(f\"Quality report generated: {report['timestamp']}\")\n    print(f\"Coverage: {report['metrics']['coverage']['percent_covered']}%\")\n</code></pre>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#team-adoption-strategies","title":"Team Adoption Strategies","text":"<p>Getting a team to adopt quality automation requires more than just tools:</p> <ol> <li>Start Small: Begin with formatting (Black) before adding complex checks</li> <li>Make It Fast: Keep pre-commit hooks under 10 seconds</li> <li>Provide Escape Hatches: Allow <code>--no-verify</code> for emergencies</li> <li>Document Everything: Create a quality guide with examples</li> <li>Celebrate Improvements: Share metrics showing reduced bugs</li> <li>Automate Fixes: Use <code>--fix</code> flags where possible</li> <li>Integrate with IDEs: Configure VS Code/PyCharm to run checks</li> </ol>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#conclusion","title":"Conclusion","text":"<p>Quality automation isn't about perfection\u2014it's about consistency and catching issues early. The clean-py repository shows how pre-commit hooks, CI/CD pipelines, and modern tools like Ruff create a safety net that lets developers move fast without breaking things.</p> <p>The investment in setting up quality automation pays off immediately. Code reviews focus on logic instead of style. Bugs are caught before production. New team members follow standards automatically. The codebase remains maintainable as it grows.</p> <p>In the next post, we'll explore production-ready logging, showing how to build observability into your Python applications from development to AWS CloudWatch. Quality code is just the beginning\u2014you also need to know what it's doing in production.</p> <p>Remember: Automation isn't about replacing human judgment. It's about freeing humans to focus on problems that actually require judgment.</p>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/06/30/code-quality-automation---pre-commit-hooks-and-cicd/#references","title":"References","text":"<ul> <li>Clean-Py Repository - Complete automation setup</li> <li>Ruff Documentation - Fast Python linter</li> <li>Pre-commit Hooks - Community hook collection</li> <li>GitHub Actions Python - CI/CD for Python</li> </ul>","tags":["code-quality","automation","pre-commit","ci-cd","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/","title":"Production-Ready Logging: From Local Debug to AWS CloudWatch","text":"<p>Logging is often an afterthought in application development. Developers add print statements during debugging, maybe upgrade to the Python logging module for production, and call it done. But when your application hits production and things go wrong at 3 AM, you'll quickly discover that logging isn't just about debugging anymore\u2014it's about understanding system behavior, tracking user actions, monitoring performance, and maintaining compliance.</p> <p>The clean-py repository demonstrates a comprehensive logging infrastructure that automatically adapts from local development to AWS production environments. This isn't just logging; it's observability engineering.</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#the-production-logging-reality-check","title":"The Production Logging Reality Check","text":"<p>I've debugged enough production incidents to know the pain of inadequate logging. Picture this: your e-commerce API is experiencing intermittent 500 errors, affecting 5% of checkout attempts. Revenue is bleeding. The logs show:</p> <pre><code>ERROR: Something went wrong\nERROR: Database error\nERROR: Internal server error\n</code></pre> <p>No correlation IDs. No context. No structured data. No way to trace a specific user's journey through the system. Each error could be related, or they could be completely different issues manifesting at the same time.</p> <p>Now imagine having logs like this instead:</p> <pre><code>{\n  \"timestamp\": \"2024-08-20T10:30:45.123Z\",\n  \"level\": \"ERROR\",\n  \"message\": \"Order creation failed: insufficient inventory\",\n  \"correlation_id\": \"req_abc123def456\",\n  \"user_id\": \"user_789\",\n  \"trace_id\": \"trace_xyz789\",\n  \"span_id\": \"span_456\",\n  \"order_id\": \"order_12345\",\n  \"product_id\": \"prod_67890\",\n  \"requested_quantity\": 3,\n  \"available_quantity\": 1,\n  \"error_code\": \"INSUFFICIENT_INVENTORY\",\n  \"duration_ms\": 234,\n  \"endpoint\": \"/api/orders\",\n  \"method\": \"POST\",\n  \"status_code\": 409\n}\n</code></pre> <p>The difference between debugging a critical production issue in 10 minutes versus 10 hours often comes down to logging quality.</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#environment-aware-logging-architecture","title":"Environment-Aware Logging Architecture","text":"<p>The challenge with logging infrastructure is that your needs differ dramatically between environments:</p> <p>Local Development: - Human-readable console output - DEBUG level verbosity - Real-time feedback - Simple configuration</p> <p>Production AWS: - Structured JSON for automated processing - INFO level with selective DEBUG - CloudWatch integration - Performance optimization - Compliance requirements</p> <p>The clean-py logging system solves this with automatic environment detection:</p> <pre><code>from src.infrastructure.logging import configure_logging, get_logger\n\n# Automatically detects environment and configures appropriately\nconfigure_logging()\nlogger = get_logger(__name__)\n\n# Local: \ud83c\udfe0 Local environment detected - using console logging (Level: DEBUG)\n# AWS:   \u2601\ufe0f AWS environment detected - using structured logging (CloudWatch: True)\n</code></pre> <p>This single line of configuration handles all the complexity behind the scenes.</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#structured-logging-for-production-systems","title":"Structured Logging for Production Systems","text":"<p>Structured logging transforms logs from human-readable text into machine-processable data. Instead of parsing log messages with regex patterns, you can query, filter, and aggregate log data like a database.</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#traditional-logging-approach","title":"Traditional Logging Approach","text":"<pre><code>logger.info(f\"User {user_id} created order {order_id} with {len(items)} items for ${total}\")\n</code></pre> <p>This creates a log message that's hard to parse programmatically: <pre><code>User 12345 created order ORD-789 with 3 items for $45.99\n</code></pre></p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#structured-logging-approach","title":"Structured Logging Approach","text":"<pre><code>logger.info(\n    \"Order created successfully\",\n    extra={\n        \"user_id\": user_id,\n        \"order_id\": order_id,\n        \"item_count\": len(items),\n        \"total_amount\": float(total),\n        \"currency\": \"USD\",\n        \"payment_method\": payment_method,\n        \"shipping_address\": {\n            \"city\": address.city,\n            \"state\": address.state,\n            \"country\": address.country\n        }\n    }\n)\n</code></pre> <p>This produces queryable JSON: <pre><code>{\n  \"timestamp\": \"2024-08-20T10:30:45.123Z\",\n  \"level\": \"INFO\",\n  \"message\": \"Order created successfully\",\n  \"user_id\": \"12345\",\n  \"order_id\": \"ORD-789\",\n  \"item_count\": 3,\n  \"total_amount\": 45.99,\n  \"currency\": \"USD\",\n  \"payment_method\": \"credit_card\",\n  \"shipping_address\": {\n    \"city\": \"Seattle\",\n    \"state\": \"WA\",\n    \"country\": \"US\"\n  }\n}\n</code></pre></p> <p>Now you can query CloudWatch Insights to find all orders over $100 from Washington state users who paid with credit cards.</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#correlation-and-tracing","title":"Correlation and Tracing","text":"<p>One of the most powerful features of the clean-py logging system is automatic correlation tracking. Every request gets a unique correlation ID that follows the request through your entire system.</p> <pre><code>from fastapi import FastAPI\nfrom src.infrastructure.logging import LoggingMiddleware, CorrelationMiddleware\n\napp = FastAPI()\n\n# Order matters: Correlation first, then Logging\napp.add_middleware(CorrelationMiddleware)\napp.add_middleware(LoggingMiddleware)\n</code></pre> <p>The middleware automatically: - Generates correlation IDs for new requests - Extracts correlation IDs from incoming headers - Adds correlation context to all log messages - Includes request/response timing and metadata</p> <p>This enables you to trace a single user request across multiple services, database calls, and external API interactions. In CloudWatch, you can filter by correlation_id and see the complete request journey.</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#aws-cloudwatch-integration","title":"AWS CloudWatch Integration","text":"<p>The logging system provides seamless CloudWatch integration with several deployment patterns:</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#ecs-fargate-deployment","title":"ECS Fargate Deployment","text":"<p>For ECS Fargate, logs are automatically sent to CloudWatch Logs through the AWS logs driver:</p> <pre><code># Automatic CloudWatch integration in AWS environments\nconfigure_logging()  # Detects ECS and uses JSON formatting\n\nlogger.info(\"Application started\", extra={\n    \"service_name\": \"order-service\",\n    \"version\": \"1.2.3\",\n    \"environment\": \"production\"\n})\n</code></pre> <p>The system automatically configures: - JSON formatting for CloudWatch Insights compatibility - Appropriate log levels for production - Error and exception handling - Performance-optimized output</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#lambda-function-logging","title":"Lambda Function Logging","text":"<p>Lambda functions have special logging requirements due to their execution model:</p> <pre><code>from src.infrastructure.logging.lambda_utils import (\n    configure_lambda_logging,\n    lambda_request_logger,\n    lambda_response_logger\n)\n\nconfigure_lambda_logging()\nlogger = get_logger(__name__)\n\ndef lambda_handler(event, context):\n    # Automatic request logging with Lambda context\n    lambda_request_logger(event, context)\n\n    try:\n        # Your business logic\n        result = process_order(event)\n\n        # Automatic response logging with timing\n        lambda_response_logger(result, context, duration_ms)\n        return result\n\n    except Exception as e:\n        # Structured error logging\n        lambda_error_logger(e, event, context)\n        raise\n</code></pre> <p>This provides Lambda-specific context including request ID, remaining execution time, and memory usage.</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#performance-considerations","title":"Performance Considerations","text":"<p>Logging can significantly impact application performance if not implemented carefully. The clean-py logging system includes several optimizations:</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#lazy-evaluation","title":"Lazy Evaluation","text":"<pre><code># Bad: String formatting happens even if log level is filtered\nlogger.debug(f\"Processing order {expensive_computation()}\")\n\n# Good: Lazy evaluation with extra parameters\nlogger.debug(\"Processing order\", extra={\"order_id\": order_id})\n\n# Good: Conditional logging for expensive operations\nif logger.isEnabledFor(logging.DEBUG):\n    logger.debug(\"Debug info\", extra=expensive_debug_context())\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#asynchronous-logging","title":"Asynchronous Logging","text":"<p>For high-throughput applications, consider asynchronous logging to prevent I/O blocking:</p> <pre><code>import asyncio\nfrom src.infrastructure.logging import AsyncLogHandler\n\n# Configure async logging for performance-critical paths\nasync_handler = AsyncLogHandler()\nlogger.addHandler(async_handler)\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#log-level-management","title":"Log Level Management","text":"<p>The system automatically adjusts log levels based on environment: - Local development: DEBUG level for detailed feedback - Production: INFO level to reduce noise - Critical paths: WARN/ERROR only for minimal overhead</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#security-and-compliance","title":"Security and Compliance","text":"<p>Production logging must handle sensitive data carefully:</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#pii-protection","title":"PII Protection","text":"<pre><code>from src.infrastructure.logging.security import sanitize_pii\n\nlogger.info(\n    \"User login successful\",\n    extra={\n        \"user_id\": user_id,\n        \"email\": sanitize_pii(user.email),  # user@*****.com\n        \"ip_address\": sanitize_pii(request.client.host),\n        \"user_agent\": request.headers.get(\"user-agent\")\n    }\n)\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#audit-logging","title":"Audit Logging","text":"<p>Critical business actions require audit trails:</p> <pre><code>def create_order(user_id: str, order_data: dict):\n    audit_logger.info(\n        \"Order creation attempted\",\n        extra={\n            \"action\": \"CREATE_ORDER\",\n            \"actor\": user_id,\n            \"resource\": \"order\",\n            \"resource_id\": order_id,\n            \"outcome\": \"SUCCESS\",\n            \"risk_level\": \"HIGH\",\n            \"compliance_tags\": [\"PCI\", \"SOX\"]\n        }\n    )\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#data-retention","title":"Data Retention","text":"<p>Configure CloudWatch log retention based on compliance requirements:</p> <pre><code># Configure in your infrastructure as code\nlog_retention_days = {\n    \"application_logs\": 30,      # General application logs\n    \"audit_logs\": 2555,          # 7 years for compliance\n    \"security_logs\": 365,        # 1 year for security events\n    \"debug_logs\": 7              # Short retention for debugging\n}\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#monitoring-and-alerting","title":"Monitoring and Alerting","text":"<p>Effective logging enables proactive monitoring through CloudWatch alarms and dashboards:</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#error-rate-monitoring","title":"Error Rate Monitoring","text":"<pre><code>-- CloudWatch Insights query for error rate\nfields @timestamp, @message, level, correlation_id\n| filter level = \"ERROR\"\n| stats count() by bin(5m)\n| sort @timestamp desc\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code>-- Find slow requests\nfields @timestamp, correlation_id, duration_ms, endpoint\n| filter duration_ms &gt; 1000\n| sort duration_ms desc\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#business-metrics","title":"Business Metrics","text":"<pre><code>-- Track order creation trends\nfields @timestamp, order_id, total_amount\n| filter @message = \"Order created successfully\"\n| stats sum(total_amount) by bin(1h)\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#troubleshooting-production-issues","title":"Troubleshooting Production Issues","text":"<p>With structured logging, debugging production issues becomes systematic:</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#finding-related-logs","title":"Finding Related Logs","text":"<pre><code>-- Trace a specific user's session\nfields @timestamp, @message, level, user_id, correlation_id\n| filter user_id = \"user_12345\"\n| sort @timestamp asc\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#error-analysis","title":"Error Analysis","text":"<pre><code>-- Analyze error patterns\nfields @timestamp, @message, error_code, endpoint\n| filter level = \"ERROR\"\n| stats count() by error_code, endpoint\n| sort count desc\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#performance-analysis","title":"Performance Analysis","text":"<pre><code>-- Find performance bottlenecks\nfields @timestamp, endpoint, duration_ms\n| filter duration_ms &gt; 500\n| stats avg(duration_ms), max(duration_ms), count() by endpoint\n| sort avg desc\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#best-practices-for-production-logging","title":"Best Practices for Production Logging","text":"","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#1-log-at-the-right-level","title":"1. Log at the Right Level","text":"<pre><code># Use appropriate log levels\nlogger.debug(\"Variable state for debugging\")     # Development only\nlogger.info(\"Normal business operations\")        # Production events\nlogger.warning(\"Recoverable issues\")             # Potential problems\nlogger.error(\"Application errors\")               # Needs attention\nlogger.critical(\"System-level failures\")        # Immediate action required\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#2-include-context","title":"2. Include Context","text":"<pre><code># Always provide context\nlogger.error(\n    \"Payment processing failed\",\n    extra={\n        \"order_id\": order_id,\n        \"payment_provider\": provider.name,\n        \"amount\": order.total,\n        \"error_code\": error.code,\n        \"retry_attempt\": attempt_number\n    }\n)\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#3-use-consistent-structure","title":"3. Use Consistent Structure","text":"<pre><code># Establish logging patterns across your team\nclass OrderService:\n    def __init__(self):\n        self.logger = get_logger(f\"{__name__}.{self.__class__.__name__}\")\n\n    def create_order(self, user_id: str, order_data: dict):\n        self.logger.info(\n            \"Order creation started\",\n            extra={\n                \"operation\": \"create_order\",\n                \"user_id\": user_id,\n                \"order_data_keys\": list(order_data.keys())\n            }\n        )\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#4-handle-exceptions-properly","title":"4. Handle Exceptions Properly","text":"<pre><code>try:\n    order = await order_service.create_order(user_id, order_data)\n    logger.info(\"Order created successfully\", extra={\"order_id\": order.id})\n\nexcept InsufficientInventoryError as e:\n    logger.warning(\n        \"Order creation failed due to inventory\",\n        extra={\n            \"user_id\": user_id,\n            \"requested_items\": order_data.get(\"items\", []),\n            \"error_details\": str(e)\n        }\n    )\n    raise\n\nexcept Exception as e:\n    logger.error(\n        \"Unexpected error during order creation\",\n        extra={\n            \"user_id\": user_id,\n            \"error_type\": type(e).__name__,\n            \"error_message\": str(e)\n        },\n        exc_info=True  # Include stack trace\n    )\n    raise\n</code></pre>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#getting-started-with-production-logging","title":"Getting Started with Production Logging","text":"<p>The clean-py repository makes it easy to implement production-ready logging:</p> <ol> <li> <p>Install Dependencies: <pre><code>pip install boto3 watchtower structlog\n</code></pre></p> </li> <li> <p>Configure Your Application: <pre><code>from src.infrastructure.logging import configure_logging\n\n# One line configuration - handles everything\nconfigure_logging()\n</code></pre></p> </li> <li> <p>Use Structured Logging: <pre><code>from src.infrastructure.logging import get_logger\n\nlogger = get_logger(__name__)\nlogger.info(\"Event occurred\", extra={\"key\": \"value\"})\n</code></pre></p> </li> <li> <p>Add Middleware: <pre><code>from fastapi import FastAPI\nfrom src.infrastructure.logging import LoggingMiddleware, CorrelationMiddleware\n\napp = FastAPI()\napp.add_middleware(CorrelationMiddleware)\napp.add_middleware(LoggingMiddleware)\n</code></pre></p> </li> </ol> <p>The logging system automatically handles environment detection, CloudWatch integration, correlation tracking, and performance optimization.</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#conclusion","title":"Conclusion","text":"<p>Production-ready logging is not just about capturing errors\u2014it's about building observability into your system from day one. The clean-py logging infrastructure demonstrates how to create a system that scales from local development to AWS production environments while maintaining consistency, performance, and security.</p> <p>When your next production incident occurs, you'll be grateful for the investment in proper logging. The difference between \"I don't know what happened\" and \"Here's exactly what happened and why\" is often the difference between hours of downtime and minutes of targeted fixes.</p> <p>Start with structured logging, add correlation tracking, integrate with CloudWatch, and build monitoring on top. Your future self (and your team) will thank you when you're debugging at 3 AM with clear, searchable, contextual logs that tell the complete story of what went wrong.</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/05/production-ready-logging---from-local-debug-to-aws-cloudwatch/#references","title":"References","text":"<ul> <li>Clean-Py Repository - Complete logging implementation</li> <li>Python Logging Documentation - Official logging guide</li> <li>AWS CloudWatch Logs - AWS logging service</li> <li>Structured Logging Best Practices - Structured logging library</li> </ul> <p>The foundation is already built in the clean-py repository. The question is: are you ready to leave print statements behind and embrace production-ready observability?</p>","tags":["logging","observability","aws","cloudwatch","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/","title":"Securing Python Applications: Beyond OWASP","text":"<p>Security isn't a feature you add at the end of development\u2014it's a foundation you build from the beginning. Too many Python applications treat security as an afterthought, implementing basic input validation and calling it done. But modern application security requires defense in depth, from secure coding practices to infrastructure hardening, from data protection to monitoring and incident response.</p> <p>The clean-py repository demonstrates a comprehensive security framework that goes beyond the OWASP Top 10, implementing production-ready security patterns for Python applications deployed on AWS. This isn't just about preventing common vulnerabilities\u2014it's about building security into the DNA of your application architecture.</p>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#the-modern-threat-landscape","title":"The Modern Threat Landscape","text":"<p>Application security has evolved far beyond SQL injection and cross-site scripting. Modern attackers target:</p> <ul> <li>Supply chain vulnerabilities through compromised dependencies</li> <li>Infrastructure misconfigurations in cloud deployments  </li> <li>Data exfiltration through API abuse and privilege escalation</li> <li>Business logic flaws that bypass technical controls</li> <li>Social engineering targeting developers and operations teams</li> </ul> <p>I recently worked with a company that had \"secured\" their application according to OWASP guidelines\u2014input validation, parameterized queries, secure headers. They felt confident until an attacker discovered they could manipulate business logic to transfer money between accounts by sending negative amounts, effectively reversing transactions. No SQL injection required.</p> <p>This incident reinforced a critical lesson: comprehensive security requires securing the entire stack, not just the web layer.</p>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#security-by-design-the-clean-architecture-advantage","title":"Security by Design: The Clean Architecture Advantage","text":"<p>Clean Architecture provides natural security boundaries through its layered approach. Security concerns are isolated and can be implemented systematically:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Presentation Layer                       \u2502\n\u2502  \u2022 Input validation \u2022 Rate limiting \u2022 Authentication       \u2502\n\u2502  \u2022 CORS policies   \u2022 Security headers \u2022 Request sanitization\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Application Layer                        \u2502\n\u2502  \u2022 Authorization  \u2022 Audit logging \u2022 Business rule validation\u2502\n\u2502  \u2022 Command/Query separation \u2022 Input sanitization           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Domain Layer                            \u2502\n\u2502  \u2022 Business invariants \u2022 Domain validation \u2022 Entity integrity\u2502\n\u2502  \u2022 Pure business logic \u2022 No external dependencies          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Infrastructure Layer                       \u2502\n\u2502  \u2022 Data encryption \u2022 Secure storage \u2022 Network security     \u2502\n\u2502  \u2022 Key management \u2022 Secrets handling \u2022 Monitoring          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Each layer has specific security responsibilities that work together to create defense in depth.</p>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#input-validation-and-sanitization","title":"Input Validation and Sanitization","text":"<p>The first line of defense is comprehensive input validation. The clean-py repository uses Pydantic for both validation and sanitization:</p>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#secure-input-models","title":"Secure Input Models","text":"<pre><code>from pydantic import BaseModel, Field, validator, EmailStr\nfrom typing import Optional\nimport re\n\nclass SecureUserRegistration(BaseModel):\n    email: EmailStr\n    username: str = Field(\n        min_length=3,\n        max_length=30,\n        regex=r'^[a-zA-Z0-9_-]+$'\n    )\n    password: str = Field(min_length=12, max_length=128)\n    first_name: str = Field(max_length=50)\n    last_name: str = Field(max_length=50)\n    phone: Optional[str] = Field(regex=r'^\\+?1?[0-9]{10,15}$')\n\n    @validator('first_name', 'last_name')\n    def sanitize_names(cls, v):\n        # Remove potential script injection\n        sanitized = re.sub(r'[&lt;&gt;\"\\']', '', v)\n        return sanitized.strip()\n\n    @validator('password')\n    def validate_password_strength(cls, v):\n        if not re.search(r'[A-Z]', v):\n            raise ValueError('Password must contain uppercase letter')\n        if not re.search(r'[a-z]', v):\n            raise ValueError('Password must contain lowercase letter')\n        if not re.search(r'\\d', v):\n            raise ValueError('Password must contain digit')\n        if not re.search(r'[!@#$%^&amp;*(),.?\":{}|&lt;&gt;]', v):\n            raise ValueError('Password must contain special character')\n        return v\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#advanced-validation-patterns","title":"Advanced Validation Patterns","text":"<pre><code>from decimal import Decimal, InvalidOperation\n\nclass SecureOrderRequest(BaseModel):\n    items: list[OrderItem] = Field(min_items=1, max_items=50)\n    shipping_address: Address\n    payment_method: PaymentMethod\n    discount_code: Optional[str] = Field(max_length=20)\n\n    @validator('items')\n    def validate_order_items(cls, items):\n        # Business logic validation\n        total_quantity = sum(item.quantity for item in items)\n        if total_quantity &gt; 100:\n            raise ValueError('Order exceeds maximum quantity limit')\n\n        # Check for suspicious patterns\n        unique_items = set(item.product_id for item in items)\n        if len(unique_items) != len(items):\n            raise ValueError('Duplicate items detected')\n\n        return items\n\n    @validator('discount_code')\n    def sanitize_discount_code(cls, v):\n        if v is None:\n            return v\n        # Allow only alphanumeric and common symbols\n        sanitized = re.sub(r'[^a-zA-Z0-9\\-_]', '', v)\n        return sanitized.upper()\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#authentication-and-authorization","title":"Authentication and Authorization","text":"<p>The clean-py repository implements a comprehensive authentication and authorization system with JWT tokens and role-based access control.</p>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#jwt-token-security","title":"JWT Token Security","text":"<pre><code>from datetime import datetime, timedelta\nfrom typing import Optional, Dict, Any\nimport jwt\nfrom cryptography.hazmat.primitives import serialization\n\nclass JWTSecurityManager:\n    def __init__(self, private_key: str, public_key: str, algorithm: str = \"RS256\"):\n        self.private_key = serialization.load_pem_private_key(\n            private_key.encode(),\n            password=None\n        )\n        self.public_key = serialization.load_pem_public_key(\n            public_key.encode()\n        )\n        self.algorithm = algorithm\n\n    def create_access_token(\n        self,\n        user_id: str,\n        roles: list[str],\n        scopes: list[str],\n        expires_delta: Optional[timedelta] = None\n    ) -&gt; str:\n        if expires_delta is None:\n            expires_delta = timedelta(minutes=15)  # Short-lived access tokens\n\n        now = datetime.utcnow()\n        payload = {\n            \"sub\": user_id,\n            \"iat\": now,\n            \"exp\": now + expires_delta,\n            \"iss\": \"https://auth.yourapp.com\",\n            \"aud\": \"https://api.yourapp.com\",\n            \"roles\": roles,\n            \"scopes\": scopes,\n            \"token_type\": \"access\"\n        }\n\n        return jwt.encode(payload, self.private_key, algorithm=self.algorithm)\n\n    def validate_token(self, token: str) -&gt; Dict[str, Any]:\n        try:\n            payload = jwt.decode(\n                token,\n                self.public_key,\n                algorithms=[self.algorithm],\n                audience=\"https://api.yourapp.com\",\n                issuer=\"https://auth.yourapp.com\"\n            )\n            return payload\n        except jwt.ExpiredSignatureError:\n            raise AuthenticationError(\"Token has expired\")\n        except jwt.InvalidTokenError as e:\n            raise AuthenticationError(f\"Invalid token: {str(e)}\")\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#role-based-authorization","title":"Role-Based Authorization","text":"<pre><code>from functools import wraps\nfrom typing import Callable, List\n\ndef require_permissions(required_permissions: List[str]):\n    def decorator(func: Callable):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            # Extract current user context from request\n            current_user = kwargs.get('current_user')\n            if not current_user:\n                raise AuthorizationError(\"Authentication required\")\n\n            # Check permissions\n            user_permissions = set(current_user.permissions)\n            required_perms = set(required_permissions)\n\n            if not required_perms.issubset(user_permissions):\n                missing_perms = required_perms - user_permissions\n                raise AuthorizationError(\n                    f\"Missing permissions: {', '.join(missing_perms)}\"\n                )\n\n            return await func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n# Usage in use cases\nclass OrderService:\n    @require_permissions([\"orders:create\", \"payments:process\"])\n    async def create_order(self, order_data: dict, current_user: User):\n        # Implementation with guaranteed authorization\n        pass\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#data-protection-and-encryption","title":"Data Protection and Encryption","text":"<p>Protecting sensitive data requires encryption at multiple levels:</p>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#field-level-encryption","title":"Field-Level Encryption","text":"<pre><code>from cryptography.fernet import Fernet\nfrom typing import Optional\nimport base64\n\nclass FieldEncryption:\n    def __init__(self, encryption_key: str):\n        self.cipher = Fernet(encryption_key.encode())\n\n    def encrypt_field(self, value: str) -&gt; str:\n        \"\"\"Encrypt sensitive field data\"\"\"\n        if not value:\n            return value\n\n        encrypted_bytes = self.cipher.encrypt(value.encode())\n        return base64.b64encode(encrypted_bytes).decode()\n\n    def decrypt_field(self, encrypted_value: str) -&gt; str:\n        \"\"\"Decrypt sensitive field data\"\"\"\n        if not encrypted_value:\n            return encrypted_value\n\n        encrypted_bytes = base64.b64decode(encrypted_value.encode())\n        decrypted_bytes = self.cipher.decrypt(encrypted_bytes)\n        return decrypted_bytes.decode()\n\n# Use in domain entities\nclass Customer:\n    def __init__(self, email: str, phone: str, encryption_service: FieldEncryption):\n        self.email = email  # Store in plain text for queries\n        self.encrypted_phone = encryption_service.encrypt_field(phone)\n        self.encryption_service = encryption_service\n\n    @property\n    def phone(self) -&gt; str:\n        return self.encryption_service.decrypt_field(self.encrypted_phone)\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#database-encryption","title":"Database Encryption","text":"<pre><code># Hybrid approach: searchable fields + encrypted sensitive data\nclass CustomerRepository:\n    async def create_customer(self, customer_data: dict) -&gt; Customer:\n        # Encrypt PII before storage\n        encrypted_data = {\n            \"email\": customer_data[\"email\"],  # Searchable\n            \"email_hash\": hash_for_search(customer_data[\"email\"]),\n            \"encrypted_phone\": self.encrypt_field(customer_data[\"phone\"]),\n            \"encrypted_address\": self.encrypt_field(customer_data[\"address\"]),\n            \"created_at\": datetime.utcnow()\n        }\n\n        result = await self.db.execute(\n            \"INSERT INTO customers (...) VALUES (...)\",\n            encrypted_data\n        )\n        return Customer.from_db(result)\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#api-security-patterns","title":"API Security Patterns","text":"","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#rate-limiting-and-throttling","title":"Rate Limiting and Throttling","text":"<pre><code>from fastapi import Request, HTTPException\nfrom typing import Dict\nimport time\nimport asyncio\n\nclass RateLimiter:\n    def __init__(self):\n        self.requests: Dict[str, list] = {}\n        self.cleanup_task = asyncio.create_task(self._cleanup_old_requests())\n\n    async def check_rate_limit(\n        self,\n        identifier: str,\n        max_requests: int = 100,\n        window_seconds: int = 60\n    ) -&gt; bool:\n        now = time.time()\n        window_start = now - window_seconds\n\n        # Clean old requests\n        if identifier in self.requests:\n            self.requests[identifier] = [\n                req_time for req_time in self.requests[identifier]\n                if req_time &gt; window_start\n            ]\n        else:\n            self.requests[identifier] = []\n\n        # Check if limit exceeded\n        if len(self.requests[identifier]) &gt;= max_requests:\n            return False\n\n        # Record this request\n        self.requests[identifier].append(now)\n        return True\n\n    async def _cleanup_old_requests(self):\n        while True:\n            await asyncio.sleep(300)  # Cleanup every 5 minutes\n            now = time.time()\n            for identifier in list(self.requests.keys()):\n                self.requests[identifier] = [\n                    req_time for req_time in self.requests[identifier]\n                    if now - req_time &lt; 3600  # Keep last hour\n                ]\n                if not self.requests[identifier]:\n                    del self.requests[identifier]\n\n# Middleware implementation\nasync def rate_limiting_middleware(request: Request, call_next):\n    rate_limiter = request.app.state.rate_limiter\n\n    # Use IP + user ID for identification\n    user_id = getattr(request.state, 'user_id', 'anonymous')\n    identifier = f\"{request.client.host}:{user_id}\"\n\n    if not await rate_limiter.check_rate_limit(identifier):\n        raise HTTPException(\n            status_code=429,\n            detail=\"Rate limit exceeded\"\n        )\n\n    response = await call_next(request)\n    return response\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#requestresponse-security","title":"Request/Response Security","text":"<pre><code>from fastapi import FastAPI, Request, Response\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp = FastAPI()\n\n# Secure CORS configuration\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"https://yourapp.com\", \"https://admin.yourapp.com\"],\n    allow_credentials=True,\n    allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    allow_headers=[\"Authorization\", \"Content-Type\", \"X-Correlation-ID\"],\n    expose_headers=[\"X-Correlation-ID\"]\n)\n\n@app.middleware(\"http\")\nasync def security_headers_middleware(request: Request, call_next):\n    response = await call_next(request)\n\n    # Security headers\n    response.headers[\"X-Content-Type-Options\"] = \"nosniff\"\n    response.headers[\"X-Frame-Options\"] = \"DENY\"\n    response.headers[\"X-XSS-Protection\"] = \"1; mode=block\"\n    response.headers[\"Strict-Transport-Security\"] = \"max-age=31536000; includeSubDomains\"\n    response.headers[\"Content-Security-Policy\"] = \"default-src 'self'\"\n    response.headers[\"Referrer-Policy\"] = \"strict-origin-when-cross-origin\"\n\n    # Remove server information\n    response.headers.pop(\"Server\", None)\n\n    return response\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#aws-security-integration","title":"AWS Security Integration","text":"","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#secrets-management","title":"Secrets Management","text":"<pre><code>import boto3\nfrom functools import lru_cache\nimport json\n\nclass AWSSecretsManager:\n    def __init__(self, region_name: str = \"us-west-2\"):\n        self.client = boto3.client('secretsmanager', region_name=region_name)\n\n    @lru_cache(maxsize=128)\n    def get_secret(self, secret_name: str) -&gt; dict:\n        try:\n            response = self.client.get_secret_value(SecretId=secret_name)\n            return json.loads(response['SecretString'])\n        except Exception as e:\n            raise SecurityError(f\"Failed to retrieve secret {secret_name}: {str(e)}\")\n\n    def get_database_credentials(self) -&gt; dict:\n        return self.get_secret(\"clean-py/database/credentials\")\n\n    def get_jwt_keys(self) -&gt; dict:\n        return self.get_secret(\"clean-py/jwt/keys\")\n\n    def get_encryption_keys(self) -&gt; dict:\n        return self.get_secret(\"clean-py/encryption/keys\")\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#iam-and-resource-based-security","title":"IAM and Resource-Based Security","text":"<pre><code># Environment-specific security configuration\nclass SecurityConfig:\n    def __init__(self, environment: str):\n        self.environment = environment\n        self.secrets_manager = AWSSecretsManager()\n\n    @property\n    def jwt_config(self) -&gt; dict:\n        keys = self.secrets_manager.get_jwt_keys()\n        return {\n            \"private_key\": keys[\"private_key\"],\n            \"public_key\": keys[\"public_key\"],\n            \"algorithm\": \"RS256\",\n            \"access_token_expire_minutes\": 15 if self.environment == \"production\" else 60,\n            \"refresh_token_expire_days\": 30\n        }\n\n    @property\n    def cors_origins(self) -&gt; list:\n        if self.environment == \"production\":\n            return [\"https://yourapp.com\", \"https://admin.yourapp.com\"]\n        elif self.environment == \"staging\":\n            return [\"https://staging.yourapp.com\"]\n        else:\n            return [\"http://localhost:3000\", \"http://localhost:8080\"]\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#security-monitoring-and-incident-response","title":"Security Monitoring and Incident Response","text":"","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#audit-logging","title":"Audit Logging","text":"<pre><code>from enum import Enum\nfrom src.infrastructure.logging import get_logger\n\nclass SecurityEventType(Enum):\n    LOGIN_SUCCESS = \"login_success\"\n    LOGIN_FAILURE = \"login_failure\"\n    PERMISSION_DENIED = \"permission_denied\"\n    DATA_ACCESS = \"data_access\"\n    DATA_MODIFICATION = \"data_modification\"\n    SUSPICIOUS_ACTIVITY = \"suspicious_activity\"\n\nclass SecurityAuditLogger:\n    def __init__(self):\n        self.logger = get_logger(\"security.audit\")\n\n    def log_security_event(\n        self,\n        event_type: SecurityEventType,\n        user_id: Optional[str] = None,\n        resource: Optional[str] = None,\n        details: Optional[dict] = None,\n        risk_level: str = \"LOW\"\n    ):\n        self.logger.info(\n            f\"Security event: {event_type.value}\",\n            extra={\n                \"event_type\": event_type.value,\n                \"user_id\": user_id,\n                \"resource\": resource,\n                \"risk_level\": risk_level,\n                \"details\": details or {},\n                \"timestamp\": datetime.utcnow().isoformat(),\n                \"source_ip\": self._get_client_ip(),\n                \"user_agent\": self._get_user_agent()\n            }\n        )\n\n    def log_data_access(self, user_id: str, resource: str, operation: str):\n        self.log_security_event(\n            SecurityEventType.DATA_ACCESS,\n            user_id=user_id,\n            resource=resource,\n            details={\"operation\": operation},\n            risk_level=\"MEDIUM\" if operation in [\"UPDATE\", \"DELETE\"] else \"LOW\"\n        )\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#anomaly-detection","title":"Anomaly Detection","text":"<pre><code>class SecurityMonitor:\n    def __init__(self):\n        self.audit_logger = SecurityAuditLogger()\n        self.user_activity: Dict[str, list] = {}\n\n    async def track_user_activity(self, user_id: str, activity: str, context: dict):\n        now = datetime.utcnow()\n\n        # Track activity patterns\n        if user_id not in self.user_activity:\n            self.user_activity[user_id] = []\n\n        self.user_activity[user_id].append({\n            \"activity\": activity,\n            \"timestamp\": now,\n            \"context\": context\n        })\n\n        # Check for suspicious patterns\n        await self._check_for_anomalies(user_id)\n\n    async def _check_for_anomalies(self, user_id: str):\n        recent_activities = [\n            activity for activity in self.user_activity[user_id]\n            if datetime.utcnow() - activity[\"timestamp\"] &lt; timedelta(minutes=5)\n        ]\n\n        # Multiple failed logins\n        failed_logins = [a for a in recent_activities if a[\"activity\"] == \"login_failure\"]\n        if len(failed_logins) &gt;= 5:\n            self.audit_logger.log_security_event(\n                SecurityEventType.SUSPICIOUS_ACTIVITY,\n                user_id=user_id,\n                details={\"anomaly_type\": \"multiple_failed_logins\", \"count\": len(failed_logins)},\n                risk_level=\"HIGH\"\n            )\n\n        # Unusual data access patterns\n        data_access = [a for a in recent_activities if a[\"activity\"] == \"data_access\"]\n        if len(data_access) &gt;= 50:  # Too many data accesses in 5 minutes\n            self.audit_logger.log_security_event(\n                SecurityEventType.SUSPICIOUS_ACTIVITY,\n                user_id=user_id,\n                details={\"anomaly_type\": \"excessive_data_access\", \"count\": len(data_access)},\n                risk_level=\"HIGH\"\n            )\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#dependency-security","title":"Dependency Security","text":"","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#supply-chain-security","title":"Supply Chain Security","text":"<pre><code># security/dependency_scanner.py\nimport subprocess\nimport json\nfrom typing import List, Dict\n\nclass DependencySecurityScanner:\n    def scan_dependencies(self) -&gt; Dict[str, List[str]]:\n        \"\"\"Scan for known vulnerabilities in dependencies\"\"\"\n        try:\n            # Use pip-audit or safety\n            result = subprocess.run(\n                [\"pip-audit\", \"--format\", \"json\"],\n                capture_output=True,\n                text=True,\n                check=True\n            )\n\n            vulnerabilities = json.loads(result.stdout)\n            return self._process_vulnerabilities(vulnerabilities)\n\n        except subprocess.CalledProcessError as e:\n            print(f\"Security scan failed: {e}\")\n            return {}\n\n    def _process_vulnerabilities(self, vulns: dict) -&gt; Dict[str, List[str]]:\n        \"\"\"Process vulnerability data into actionable format\"\"\"\n        issues = {}\n        for vuln in vulns.get(\"vulnerabilities\", []):\n            package = vuln[\"package\"]\n            if package not in issues:\n                issues[package] = []\n            issues[package].append({\n                \"id\": vuln[\"id\"],\n                \"description\": vuln[\"description\"],\n                \"fixed_version\": vuln.get(\"fixed_version\"),\n                \"severity\": vuln.get(\"severity\", \"unknown\")\n            })\n        return issues\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#security-testing-integration","title":"Security Testing Integration","text":"<pre><code># tests/security/test_security_patterns.py\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom src.presentation.main import app\n\nclass TestSecurityPatterns:\n    def test_sql_injection_protection(self):\n        \"\"\"Test SQL injection prevention\"\"\"\n        client = TestClient(app)\n\n        # Attempt SQL injection\n        malicious_payload = \"'; DROP TABLE users; --\"\n        response = client.post(\"/users\", json={\n            \"username\": malicious_payload,\n            \"email\": \"test@example.com\"\n        })\n\n        # Should be rejected by validation\n        assert response.status_code == 422\n\n    def test_xss_protection(self):\n        \"\"\"Test XSS prevention\"\"\"\n        client = TestClient(app)\n\n        malicious_script = \"&lt;script&gt;alert('xss')&lt;/script&gt;\"\n        response = client.post(\"/users\", json={\n            \"first_name\": malicious_script,\n            \"email\": \"test@example.com\"\n        })\n\n        # Should sanitize or reject\n        if response.status_code == 200:\n            user_data = response.json()\n            assert \"&lt;script&gt;\" not in user_data[\"first_name\"]\n\n    def test_rate_limiting(self):\n        \"\"\"Test rate limiting functionality\"\"\"\n        client = TestClient(app)\n\n        # Make multiple rapid requests\n        responses = []\n        for _ in range(110):  # Exceed rate limit\n            response = client.get(\"/api/public\")\n            responses.append(response.status_code)\n\n        # Should eventually return 429\n        assert 429 in responses\n\n    def test_authentication_required(self):\n        \"\"\"Test that protected endpoints require authentication\"\"\"\n        client = TestClient(app)\n\n        response = client.get(\"/api/orders\")\n        assert response.status_code == 401\n\n    def test_authorization_enforcement(self):\n        \"\"\"Test that authorization is properly enforced\"\"\"\n        client = TestClient(app)\n\n        # Login as regular user\n        login_response = client.post(\"/auth/login\", json={\n            \"email\": \"user@example.com\",\n            \"password\": \"password123\"\n        })\n        token = login_response.json()[\"access_token\"]\n\n        # Try to access admin endpoint\n        response = client.get(\"/api/admin/users\", headers={\n            \"Authorization\": f\"Bearer {token}\"\n        })\n        assert response.status_code == 403\n</code></pre>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#security-checklist-for-production","title":"Security Checklist for Production","text":"<p>Before deploying to production, ensure you've implemented:</p>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#application-security","title":"Application Security","text":"<ul> <li>[ ] Input validation and sanitization on all endpoints</li> <li>[ ] Parameterized queries for database operations</li> <li>[ ] JWT token validation with proper expiration</li> <li>[ ] Role-based authorization on all protected resources</li> <li>[ ] Rate limiting and request throttling</li> <li>[ ] Security headers in all responses</li> <li>[ ] Error handling that doesn't leak sensitive information</li> </ul>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#data-protection","title":"Data Protection","text":"<ul> <li>[ ] Encryption at rest for sensitive data</li> <li>[ ] Field-level encryption for PII</li> <li>[ ] Secure key management with AWS Secrets Manager</li> <li>[ ] Data retention and deletion policies</li> <li>[ ] Audit logging for all data access</li> </ul>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#infrastructure-security","title":"Infrastructure Security","text":"<ul> <li>[ ] TLS 1.2+ for all communications</li> <li>[ ] WAF rules configured for common attacks</li> <li>[ ] VPC isolation and security groups</li> <li>[ ] IAM roles with least-privilege access</li> <li>[ ] Regular security updates and patches</li> </ul>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#monitoring-and-response","title":"Monitoring and Response","text":"<ul> <li>[ ] Security event logging and alerting</li> <li>[ ] Anomaly detection for user behavior</li> <li>[ ] Incident response procedures</li> <li>[ ] Regular security assessments</li> <li>[ ] Dependency vulnerability scanning</li> </ul>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#conclusion","title":"Conclusion","text":"<p>Security is not a destination\u2014it's a continuous journey. The clean-py repository provides a solid foundation with defense-in-depth security patterns, but security must be maintained and evolved as your application grows.</p> <p>The key principles to remember:</p> <ol> <li>Security by Design: Build security into your architecture from day one</li> <li>Defense in Depth: Multiple layers of protection, not single points of failure</li> <li>Least Privilege: Grant only the minimum access required</li> <li>Continuous Monitoring: Watch for threats and respond quickly</li> <li>Regular Updates: Keep dependencies and infrastructure current</li> </ol> <p>Modern applications face sophisticated threats that go far beyond the OWASP Top 10. By implementing comprehensive security patterns throughout your stack\u2014from input validation to infrastructure hardening\u2014you create a robust defense that can adapt to emerging threats.</p> <p>The investment in security infrastructure pays dividends when you're not the company in the headlines for a data breach. Start with the patterns in clean-py, adapt them to your specific needs, and build security into your development culture from day one.</p>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/09/securing-python-applications---beyond-owasp/#references","title":"References","text":"<ul> <li>Clean-Py Repository - Complete security implementation</li> <li>OWASP Top 10 - Web application security risks</li> <li>NIST Cybersecurity Framework - Comprehensive security guidance</li> <li>AWS Security Best Practices - Cloud security patterns</li> </ul> <p>Your users trust you with their data. Honor that trust with security that goes beyond compliance to true protection.</p>","tags":["security","python","aws","owasp","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/","title":"JWT Authentication in AWS: From Development to Production","text":"<p>Authentication is the foundation of application security, but implementing JWT tokens correctly in AWS environments presents unique challenges. You need to handle token lifecycle, key rotation, validation performance, and AWS service integration while maintaining security best practices across development, staging, and production environments.</p> <p>The clean-py repository demonstrates a production-ready JWT authentication system designed specifically for AWS deployments. This isn't just about generating tokens\u2014it's about building a comprehensive authentication infrastructure that scales from local development to enterprise production environments.</p>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#the-jwt-authentication-journey","title":"The JWT Authentication Journey","text":"<p>I've seen too many applications implement JWT authentication as an afterthought. They generate tokens with HS256 and a hardcoded secret, validate them with a simple middleware, and assume they're secure. Then production hits:</p> <ul> <li>Tokens can't be revoked when users are compromised</li> <li>Key rotation brings down the entire system</li> <li>Performance degrades under load due to expensive validation</li> <li>Integration with AWS services becomes a nightmare</li> <li>Compliance audits reveal security gaps</li> </ul> <p>A recent consulting client had exactly this problem. Their JWT implementation worked fine with 100 users, but when they scaled to 10,000 users, token validation became a bottleneck. Every request required expensive cryptographic operations, and they had no way to invalidate compromised tokens without changing the global secret key.</p> <p>The solution required rebuilding their entire authentication system with production-grade patterns.</p>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#jwt-architecture-for-aws","title":"JWT Architecture for AWS","text":"<p>A robust JWT system in AWS requires several components working together:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Client App    \u2502    \u2502  API Gateway    \u2502    \u2502  ECS/Lambda     \u2502\n\u2502                 \u2502    \u2502                 \u2502    \u2502  Services       \u2502\n\u2502 \u2022 Token storage \u2502\u2500\u2500\u2500\u25b6\u2502 \u2022 JWT validation\u2502\u2500\u2500\u2500\u25b6\u2502 \u2022 Claims extraction\u2502\n\u2502 \u2022 Auto refresh  \u2502    \u2502 \u2022 Rate limiting \u2502    \u2502 \u2022 Authorization  \u2502\n\u2502 \u2022 Secure trans  \u2502    \u2502 \u2022 Custom auth   \u2502    \u2502 \u2022 Business logic\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502                       \u2502\n         \u2502                       \u25bc                       \u2502\n         \u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n         \u2502              \u2502  AWS Cognito    \u2502              \u2502\n         \u2502              \u2502                 \u2502              \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 \u2022 User pools    \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502 \u2022 Token issuing \u2502\n                        \u2502 \u2022 Key rotation  \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u2502\n                                 \u25bc\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502 AWS Secrets     \u2502\n                        \u2502 Manager         \u2502\n                        \u2502                 \u2502\n                        \u2502 \u2022 Signing keys  \u2502\n                        \u2502 \u2022 Certificates  \u2502\n                        \u2502 \u2022 Auto rotation \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>This architecture provides several advantages: - Centralized key management with automatic rotation - High-performance token validation - Integration with AWS services - Scalable to millions of users - Compliance-ready audit trails</p>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#jwt-token-design","title":"JWT Token Design","text":"","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#token-structure-and-claims","title":"Token Structure and Claims","text":"<p>The clean-py JWT implementation uses RS256 signing with carefully designed claims:</p> <pre><code>from datetime import datetime, timedelta\nfrom typing import Optional, Dict, Any, List\nimport jwt\nimport uuid\nfrom cryptography.hazmat.primitives import serialization\n\nclass JWTTokenManager:\n    def __init__(self, private_key_pem: str, public_key_pem: str):\n        self.private_key = serialization.load_pem_private_key(\n            private_key_pem.encode(),\n            password=None\n        )\n        self.public_key = serialization.load_pem_public_key(\n            public_key_pem.encode()\n        )\n        self.algorithm = \"RS256\"\n\n    def create_access_token(\n        self,\n        user_id: str,\n        email: str,\n        roles: List[str],\n        permissions: List[str],\n        tenant_id: Optional[str] = None,\n        expires_delta: Optional[timedelta] = None\n    ) -&gt; str:\n        \"\"\"Create a comprehensive access token with all necessary claims\"\"\"\n\n        if expires_delta is None:\n            expires_delta = timedelta(minutes=15)  # Short-lived for security\n\n        now = datetime.utcnow()\n        jti = str(uuid.uuid4())  # Unique token ID for revocation\n\n        payload = {\n            # Standard claims\n            \"iss\": \"https://auth.yourapp.com\",       # Issuer\n            \"sub\": user_id,                          # Subject (user ID)\n            \"aud\": [\"https://api.yourapp.com\"],      # Audience\n            \"exp\": now + expires_delta,              # Expiration\n            \"iat\": now,                              # Issued at\n            \"nbf\": now,                              # Not before\n            \"jti\": jti,                              # JWT ID for revocation\n\n            # Custom claims\n            \"email\": email,\n            \"roles\": roles,\n            \"permissions\": permissions,\n            \"token_type\": \"access\",\n            \"version\": \"1.0\"\n        }\n\n        # Add tenant context for multi-tenant applications\n        if tenant_id:\n            payload[\"tenant_id\"] = tenant_id\n            payload[\"aud\"].append(f\"https://api.{tenant_id}.yourapp.com\")\n\n        return jwt.encode(payload, self.private_key, algorithm=self.algorithm)\n\n    def create_refresh_token(\n        self,\n        user_id: str,\n        session_id: str,\n        expires_delta: Optional[timedelta] = None\n    ) -&gt; str:\n        \"\"\"Create a refresh token for token renewal\"\"\"\n\n        if expires_delta is None:\n            expires_delta = timedelta(days=30)  # Longer-lived\n\n        now = datetime.utcnow()\n\n        payload = {\n            \"iss\": \"https://auth.yourapp.com\",\n            \"sub\": user_id,\n            \"aud\": \"https://auth.yourapp.com\",  # Only for auth service\n            \"exp\": now + expires_delta,\n            \"iat\": now,\n            \"jti\": str(uuid.uuid4()),\n            \"session_id\": session_id,\n            \"token_type\": \"refresh\",\n            \"version\": \"1.0\"\n        }\n\n        return jwt.encode(payload, self.private_key, algorithm=self.algorithm)\n</code></pre>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#token-validation-with-performance-optimization","title":"Token Validation with Performance Optimization","text":"<pre><code>import asyncio\nfrom typing import Optional\nimport aioredis\nfrom functools import lru_cache\n\nclass JWTValidator:\n    def __init__(\n        self,\n        public_key_pem: str,\n        redis_client: Optional[aioredis.Redis] = None\n    ):\n        self.public_key = serialization.load_pem_public_key(\n            public_key_pem.encode()\n        )\n        self.algorithm = \"RS256\"\n        self.redis = redis_client\n\n        # In-memory cache for high-frequency validation\n        self._validation_cache = {}\n        self._cache_size = 1000\n\n    async def validate_token(self, token: str) -&gt; Dict[str, Any]:\n        \"\"\"Validate JWT token with caching for performance\"\"\"\n\n        # Check revocation list first (fastest check)\n        if await self._is_token_revoked(token):\n            raise AuthenticationError(\"Token has been revoked\")\n\n        # Check in-memory cache\n        if token in self._validation_cache:\n            cached_result = self._validation_cache[token]\n            if cached_result[\"exp\"] &gt; datetime.utcnow().timestamp():\n                return cached_result\n            else:\n                del self._validation_cache[token]\n\n        try:\n            # Decode and validate token\n            payload = jwt.decode(\n                token,\n                self.public_key,\n                algorithms=[self.algorithm],\n                audience=\"https://api.yourapp.com\",\n                issuer=\"https://auth.yourapp.com\",\n                options={\n                    \"verify_exp\": True,\n                    \"verify_nbf\": True,\n                    \"verify_iat\": True,\n                    \"verify_aud\": True,\n                    \"verify_iss\": True\n                }\n            )\n\n            # Additional business logic validation\n            await self._validate_business_rules(payload)\n\n            # Cache valid token (manage cache size)\n            if len(self._validation_cache) &gt;= self._cache_size:\n                # Remove oldest entries\n                oldest_key = min(\n                    self._validation_cache.keys(),\n                    key=lambda k: self._validation_cache[k].get(\"iat\", 0)\n                )\n                del self._validation_cache[oldest_key]\n\n            self._validation_cache[token] = payload\n            return payload\n\n        except jwt.ExpiredSignatureError:\n            raise AuthenticationError(\"Token has expired\")\n        except jwt.InvalidAudienceError:\n            raise AuthenticationError(\"Invalid token audience\")\n        except jwt.InvalidIssuerError:\n            raise AuthenticationError(\"Invalid token issuer\")\n        except jwt.InvalidTokenError as e:\n            raise AuthenticationError(f\"Invalid token: {str(e)}\")\n\n    async def _is_token_revoked(self, token: str) -&gt; bool:\n        \"\"\"Check if token is in revocation list\"\"\"\n        if not self.redis:\n            return False\n\n        try:\n            # Extract JTI from token without validation\n            unverified_payload = jwt.decode(\n                token, options={\"verify_signature\": False}\n            )\n            jti = unverified_payload.get(\"jti\")\n\n            if jti:\n                return await self.redis.exists(f\"revoked:{jti}\")\n            return False\n\n        except Exception:\n            return False  # If we can't extract JTI, let full validation handle it\n\n    async def _validate_business_rules(self, payload: Dict[str, Any]):\n        \"\"\"Additional business logic validation\"\"\"\n\n        # Check user is still active\n        user_id = payload.get(\"sub\")\n        if user_id and self.redis:\n            is_active = await self.redis.get(f\"user:active:{user_id}\")\n            if is_active == b\"false\":\n                raise AuthenticationError(\"User account is deactivated\")\n\n        # Validate tenant access for multi-tenant applications\n        tenant_id = payload.get(\"tenant_id\")\n        if tenant_id:\n            # Check if user still has access to this tenant\n            has_access = await self._check_tenant_access(user_id, tenant_id)\n            if not has_access:\n                raise AuthenticationError(\"Access to tenant revoked\")\n</code></pre>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#aws-integration-patterns","title":"AWS Integration Patterns","text":"","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#aws-secrets-manager-for-key-management","title":"AWS Secrets Manager for Key Management","text":"<pre><code>import boto3\nimport json\nfrom functools import lru_cache\nfrom typing import Dict\n\nclass AWSJWTKeyManager:\n    def __init__(self, region_name: str = \"us-west-2\"):\n        self.secrets_client = boto3.client('secretsmanager', region_name=region_name)\n        self.current_key_version = None\n\n    @lru_cache(maxsize=10)\n    def get_current_keys(self) -&gt; Dict[str, str]:\n        \"\"\"Get current JWT signing keys from AWS Secrets Manager\"\"\"\n        try:\n            response = self.secrets_client.get_secret_value(\n                SecretId=\"clean-py/jwt/current-keys\"\n            )\n            keys = json.loads(response['SecretString'])\n            return {\n                \"private_key\": keys[\"private_key\"],\n                \"public_key\": keys[\"public_key\"],\n                \"key_id\": keys[\"key_id\"],\n                \"created_at\": keys[\"created_at\"]\n            }\n        except Exception as e:\n            raise SecurityError(f\"Failed to retrieve JWT keys: {str(e)}\")\n\n    def get_public_keys_jwks(self) -&gt; Dict:\n        \"\"\"Get public keys in JWKS format for token validation\"\"\"\n        keys = self.get_current_keys()\n\n        # In production, you'd have multiple keys for rotation\n        jwks = {\n            \"keys\": [\n                {\n                    \"kty\": \"RSA\",\n                    \"kid\": keys[\"key_id\"],\n                    \"use\": \"sig\",\n                    \"alg\": \"RS256\",\n                    \"n\": self._extract_modulus(keys[\"public_key\"]),\n                    \"e\": \"AQAB\"  # Standard RSA exponent\n                }\n            ]\n        }\n        return jwks\n\n    async def rotate_keys(self) -&gt; str:\n        \"\"\"Rotate JWT signing keys\"\"\"\n        # Generate new key pair\n        new_keys = self._generate_key_pair()\n\n        # Store old keys as previous version\n        current_keys = self.get_current_keys()\n        await self._store_previous_keys(current_keys)\n\n        # Store new keys as current\n        await self._store_current_keys(new_keys)\n\n        # Clear cache to force reload\n        self.get_current_keys.cache_clear()\n\n        return new_keys[\"key_id\"]\n</code></pre>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#api-gateway-custom-authorizer","title":"API Gateway Custom Authorizer","text":"<pre><code># lambda/jwt_authorizer.py\nimport json\nimport boto3\nfrom typing import Dict, Any\n\ndef lambda_handler(event: Dict[str, Any], context) -&gt; Dict[str, Any]:\n    \"\"\"AWS API Gateway custom authorizer for JWT validation\"\"\"\n\n    try:\n        # Extract token from Authorization header\n        token = extract_token_from_event(event)\n        if not token:\n            raise AuthenticationError(\"No token provided\")\n\n        # Validate token\n        key_manager = AWSJWTKeyManager()\n        validator = JWTValidator(key_manager.get_current_keys()[\"public_key\"])\n        payload = await validator.validate_token(token)\n\n        # Generate IAM policy\n        policy = generate_iam_policy(payload, event[\"methodArn\"])\n\n        return {\n            \"principalId\": payload[\"sub\"],\n            \"policyDocument\": policy,\n            \"context\": {\n                \"user_id\": payload[\"sub\"],\n                \"email\": payload.get(\"email\", \"\"),\n                \"roles\": \",\".join(payload.get(\"roles\", [])),\n                \"permissions\": \",\".join(payload.get(\"permissions\", [])),\n                \"tenant_id\": payload.get(\"tenant_id\", \"\")\n            }\n        }\n\n    except AuthenticationError as e:\n        # Return 401 Unauthorized\n        raise Exception(\"Unauthorized\")\n    except Exception as e:\n        # Return 500 Internal Server Error\n        print(f\"Authorizer error: {str(e)}\")\n        raise Exception(\"Unauthorized\")\n\ndef generate_iam_policy(payload: Dict[str, Any], method_arn: str) -&gt; Dict[str, Any]:\n    \"\"\"Generate IAM policy based on JWT claims\"\"\"\n\n    user_permissions = payload.get(\"permissions\", [])\n\n    # Extract resource and method from ARN\n    # arn:aws:execute-api:region:account:api-id/stage/METHOD/resource-path\n    arn_parts = method_arn.split(\":\")\n    api_gateway_arn = \":\".join(arn_parts[:5])\n\n    statements = []\n\n    # Check permissions and generate appropriate policy\n    if \"orders:read\" in user_permissions:\n        statements.append({\n            \"Action\": \"execute-api:Invoke\",\n            \"Effect\": \"Allow\",\n            \"Resource\": f\"{api_gateway_arn}/*/GET/orders*\"\n        })\n\n    if \"orders:write\" in user_permissions:\n        statements.append({\n            \"Action\": \"execute-api:Invoke\",\n            \"Effect\": \"Allow\",\n            \"Resource\": f\"{api_gateway_arn}/*/POST/orders*\"\n        })\n\n    # Default deny for unmatched resources\n    statements.append({\n        \"Action\": \"execute-api:Invoke\",\n        \"Effect\": \"Deny\",\n        \"Resource\": \"*\"\n    })\n\n    return {\n        \"Version\": \"2012-10-17\",\n        \"Statement\": statements\n    }\n</code></pre>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#ecsfargate-jwt-middleware","title":"ECS/Fargate JWT Middleware","text":"<pre><code>from fastapi import Request, HTTPException, Depends\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom typing import Optional\n\nsecurity = HTTPBearer()\n\nclass JWTAuthenticationMiddleware:\n    def __init__(self):\n        self.key_manager = AWSJWTKeyManager()\n        self.validator = None\n        self._initialize_validator()\n\n    def _initialize_validator(self):\n        \"\"\"Initialize JWT validator with current keys\"\"\"\n        keys = self.key_manager.get_current_keys()\n        self.validator = JWTValidator(\n            keys[\"public_key\"],\n            redis_client=get_redis_client()\n        )\n\n    async def __call__(self, request: Request, call_next):\n        \"\"\"Middleware to validate JWT tokens\"\"\"\n\n        # Skip authentication for public endpoints\n        if self._is_public_endpoint(request.url.path):\n            response = await call_next(request)\n            return response\n\n        # Extract token\n        auth_header = request.headers.get(\"Authorization\")\n        if not auth_header or not auth_header.startswith(\"Bearer \"):\n            raise HTTPException(status_code=401, detail=\"Authentication required\")\n\n        token = auth_header.split(\" \")[1]\n\n        try:\n            # Validate token\n            payload = await self.validator.validate_token(token)\n\n            # Add user context to request\n            request.state.user_id = payload[\"sub\"]\n            request.state.user_email = payload.get(\"email\")\n            request.state.user_roles = payload.get(\"roles\", [])\n            request.state.user_permissions = payload.get(\"permissions\", [])\n            request.state.tenant_id = payload.get(\"tenant_id\")\n\n            response = await call_next(request)\n            return response\n\n        except AuthenticationError as e:\n            raise HTTPException(status_code=401, detail=str(e))\n        except Exception as e:\n            raise HTTPException(status_code=500, detail=\"Authentication service error\")\n\n    def _is_public_endpoint(self, path: str) -&gt; bool:\n        \"\"\"Check if endpoint is public and doesn't require authentication\"\"\"\n        public_paths = [\n            \"/health\",\n            \"/docs\",\n            \"/openapi.json\",\n            \"/auth/login\",\n            \"/auth/register\",\n            \"/auth/refresh\"\n        ]\n        return any(path.startswith(public_path) for public_path in public_paths)\n\n# Dependency for endpoint-level authentication\nasync def get_current_user(\n    credentials: HTTPAuthorizationCredentials = Depends(security)\n) -&gt; Dict[str, Any]:\n    \"\"\"FastAPI dependency for getting current authenticated user\"\"\"\n\n    key_manager = AWSJWTKeyManager()\n    validator = JWTValidator(key_manager.get_current_keys()[\"public_key\"])\n\n    try:\n        payload = await validator.validate_token(credentials.credentials)\n        return {\n            \"user_id\": payload[\"sub\"],\n            \"email\": payload.get(\"email\"),\n            \"roles\": payload.get(\"roles\", []),\n            \"permissions\": payload.get(\"permissions\", []),\n            \"tenant_id\": payload.get(\"tenant_id\")\n        }\n    except AuthenticationError as e:\n        raise HTTPException(status_code=401, detail=str(e))\n</code></pre>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#token-lifecycle-management","title":"Token Lifecycle Management","text":"","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#token-refresh-pattern","title":"Token Refresh Pattern","text":"<pre><code>class TokenRefreshService:\n    def __init__(self, token_manager: JWTTokenManager, user_service):\n        self.token_manager = token_manager\n        self.user_service = user_service\n        self.redis = get_redis_client()\n\n    async def refresh_access_token(\n        self,\n        refresh_token: str,\n        client_id: str\n    ) -&gt; Dict[str, str]:\n        \"\"\"Refresh access token using refresh token\"\"\"\n\n        try:\n            # Validate refresh token\n            payload = jwt.decode(\n                refresh_token,\n                self.token_manager.public_key,\n                algorithms=[\"RS256\"],\n                audience=\"https://auth.yourapp.com\"\n            )\n\n            if payload.get(\"token_type\") != \"refresh\":\n                raise AuthenticationError(\"Invalid token type\")\n\n            user_id = payload[\"sub\"]\n            session_id = payload[\"session_id\"]\n\n            # Check if session is still valid\n            session_key = f\"session:{session_id}\"\n            if not await self.redis.exists(session_key):\n                raise AuthenticationError(\"Session expired\")\n\n            # Get current user data\n            user = await self.user_service.get_user(user_id)\n            if not user or not user.is_active:\n                raise AuthenticationError(\"User not found or inactive\")\n\n            # Generate new access token\n            new_access_token = self.token_manager.create_access_token(\n                user_id=user.id,\n                email=user.email,\n                roles=user.roles,\n                permissions=user.permissions,\n                tenant_id=user.tenant_id\n            )\n\n            # Update session timestamp\n            await self.redis.setex(session_key, 2592000, user_id)  # 30 days\n\n            return {\n                \"access_token\": new_access_token,\n                \"token_type\": \"Bearer\",\n                \"expires_in\": 900  # 15 minutes\n            }\n\n        except jwt.ExpiredSignatureError:\n            raise AuthenticationError(\"Refresh token expired\")\n        except jwt.InvalidTokenError as e:\n            raise AuthenticationError(f\"Invalid refresh token: {str(e)}\")\n</code></pre>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#token-revocation","title":"Token Revocation","text":"<pre><code>class TokenRevocationService:\n    def __init__(self):\n        self.redis = get_redis_client()\n\n    async def revoke_token(self, token: str, reason: str = \"user_logout\"):\n        \"\"\"Revoke a specific token\"\"\"\n        try:\n            # Extract JTI without validation\n            payload = jwt.decode(token, options={\"verify_signature\": False})\n            jti = payload.get(\"jti\")\n            exp = payload.get(\"exp\")\n\n            if jti and exp:\n                # Calculate TTL based on expiration\n                ttl = max(0, exp - datetime.utcnow().timestamp())\n\n                # Add to revocation list\n                await self.redis.setex(\n                    f\"revoked:{jti}\",\n                    int(ttl),\n                    json.dumps({\n                        \"revoked_at\": datetime.utcnow().isoformat(),\n                        \"reason\": reason,\n                        \"jti\": jti\n                    })\n                )\n\n                # Log revocation for audit\n                audit_logger.info(\n                    \"Token revoked\",\n                    extra={\n                        \"jti\": jti,\n                        \"reason\": reason,\n                        \"expires_at\": exp\n                    }\n                )\n        except Exception as e:\n            print(f\"Error revoking token: {str(e)}\")\n\n    async def revoke_user_tokens(self, user_id: str, reason: str = \"security_incident\"):\n        \"\"\"Revoke all tokens for a specific user\"\"\"\n\n        # In a production system, you'd need to track active tokens per user\n        # This could be done by storing JTIs in Redis sets per user\n\n        user_tokens_key = f\"user_tokens:{user_id}\"\n        token_jtis = await self.redis.smembers(user_tokens_key)\n\n        for jti in token_jtis:\n            await self.redis.setex(\n                f\"revoked:{jti.decode()}\",\n                86400,  # 24 hours\n                json.dumps({\n                    \"revoked_at\": datetime.utcnow().isoformat(),\n                    \"reason\": reason,\n                    \"user_id\": user_id\n                })\n            )\n\n        # Clear user token tracking\n        await self.redis.delete(user_tokens_key)\n\n        # Log bulk revocation\n        audit_logger.warning(\n            \"All user tokens revoked\",\n            extra={\n                \"user_id\": user_id,\n                \"reason\": reason,\n                \"token_count\": len(token_jtis)\n            }\n        )\n</code></pre>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#performance-optimization","title":"Performance Optimization","text":"","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#caching-strategy","title":"Caching Strategy","text":"<pre><code>import asyncio\nfrom typing import Dict, Optional\n\nclass JWTPerformanceOptimizer:\n    def __init__(self):\n        self.redis = get_redis_client()\n        self.local_cache = {}\n        self.cache_stats = {\"hits\": 0, \"misses\": 0}\n\n    async def cached_validation(\n        self,\n        token: str,\n        validator: JWTValidator\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Multi-level caching for JWT validation\"\"\"\n\n        # Level 1: In-memory cache (fastest)\n        cache_key = f\"jwt:{hash(token)}\"\n\n        if cache_key in self.local_cache:\n            cached_data = self.local_cache[cache_key]\n            if cached_data[\"expires\"] &gt; datetime.utcnow().timestamp():\n                self.cache_stats[\"hits\"] += 1\n                return cached_data[\"payload\"]\n            else:\n                del self.local_cache[cache_key]\n\n        # Level 2: Redis cache (shared across instances)\n        redis_key = f\"jwt_cache:{hash(token)}\"\n        cached_payload = await self.redis.get(redis_key)\n\n        if cached_payload:\n            payload = json.loads(cached_payload)\n\n            # Store in local cache\n            self.local_cache[cache_key] = {\n                \"payload\": payload,\n                \"expires\": payload[\"exp\"]\n            }\n\n            self.cache_stats[\"hits\"] += 1\n            return payload\n\n        # Level 3: Full validation (slowest)\n        self.cache_stats[\"misses\"] += 1\n        payload = await validator.validate_token(token)\n\n        # Cache the result\n        ttl = max(0, payload[\"exp\"] - datetime.utcnow().timestamp())\n\n        # Redis cache (shared)\n        await self.redis.setex(\n            redis_key,\n            int(ttl),\n            json.dumps(payload)\n        )\n\n        # Local cache (instance-specific)\n        self.local_cache[cache_key] = {\n            \"payload\": payload,\n            \"expires\": payload[\"exp\"]\n        }\n\n        return payload\n\n    def get_cache_stats(self) -&gt; Dict[str, Any]:\n        \"\"\"Get cache performance statistics\"\"\"\n        total = self.cache_stats[\"hits\"] + self.cache_stats[\"misses\"]\n        hit_rate = (self.cache_stats[\"hits\"] / total * 100) if total &gt; 0 else 0\n\n        return {\n            \"hits\": self.cache_stats[\"hits\"],\n            \"misses\": self.cache_stats[\"misses\"],\n            \"hit_rate\": f\"{hit_rate:.2f}%\",\n            \"local_cache_size\": len(self.local_cache)\n        }\n</code></pre>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#security-monitoring","title":"Security Monitoring","text":"","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#jwt-security-events","title":"JWT Security Events","text":"<pre><code>class JWTSecurityMonitor:\n    def __init__(self):\n        self.audit_logger = get_logger(\"jwt.security\")\n        self.metrics = {}\n\n    def log_token_validation_attempt(\n        self,\n        token_hash: str,\n        success: bool,\n        user_id: Optional[str] = None,\n        error_reason: Optional[str] = None\n    ):\n        \"\"\"Log token validation attempts for security monitoring\"\"\"\n\n        self.audit_logger.info(\n            \"JWT validation attempt\",\n            extra={\n                \"token_hash\": token_hash,\n                \"success\": success,\n                \"user_id\": user_id,\n                \"error_reason\": error_reason,\n                \"timestamp\": datetime.utcnow().isoformat()\n            }\n        )\n\n        # Track metrics\n        status = \"success\" if success else \"failure\"\n        self.metrics[f\"validation_{status}\"] = self.metrics.get(f\"validation_{status}\", 0) + 1\n\n    def detect_suspicious_activity(self, user_id: str, activity_data: Dict):\n        \"\"\"Detect suspicious JWT-related activity\"\"\"\n\n        # Multiple failed validations\n        if activity_data.get(\"failed_validations\", 0) &gt; 5:\n            self.audit_logger.warning(\n                \"Suspicious JWT activity: multiple failed validations\",\n                extra={\n                    \"user_id\": user_id,\n                    \"failed_count\": activity_data[\"failed_validations\"],\n                    \"time_window\": \"5_minutes\"\n                }\n            )\n\n        # Token reuse attempts\n        if activity_data.get(\"token_reuse_attempts\", 0) &gt; 3:\n            self.audit_logger.warning(\n                \"Suspicious JWT activity: token reuse attempts\",\n                extra={\n                    \"user_id\": user_id,\n                    \"reuse_attempts\": activity_data[\"token_reuse_attempts\"]\n                }\n            )\n</code></pre>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#testing-jwt-implementation","title":"Testing JWT Implementation","text":"<pre><code># tests/test_jwt_authentication.py\nimport pytest\nfrom datetime import datetime, timedelta\nfrom src.infrastructure.security.jwt_manager import JWTTokenManager\nfrom src.infrastructure.security.jwt_validator import JWTValidator\n\nclass TestJWTAuthentication:\n    @pytest.fixture\n    def jwt_manager(self):\n        # Use test keys\n        private_key = \"\"\"-----BEGIN PRIVATE KEY-----\n        [Test private key content]\n        -----END PRIVATE KEY-----\"\"\"\n\n        public_key = \"\"\"-----BEGIN PUBLIC KEY-----\n        [Test public key content]\n        -----END PUBLIC KEY-----\"\"\"\n\n        return JWTTokenManager(private_key, public_key)\n\n    @pytest.fixture\n    def jwt_validator(self, jwt_manager):\n        return JWTValidator(jwt_manager.public_key)\n\n    def test_create_valid_access_token(self, jwt_manager):\n        \"\"\"Test creating a valid access token\"\"\"\n        token = jwt_manager.create_access_token(\n            user_id=\"user123\",\n            email=\"test@example.com\",\n            roles=[\"customer\"],\n            permissions=[\"orders:read\", \"profile:update\"]\n        )\n\n        assert isinstance(token, str)\n        assert len(token.split('.')) == 3  # JWT has 3 parts\n\n    async def test_validate_valid_token(self, jwt_manager, jwt_validator):\n        \"\"\"Test validating a valid token\"\"\"\n        token = jwt_manager.create_access_token(\n            user_id=\"user123\",\n            email=\"test@example.com\",\n            roles=[\"customer\"],\n            permissions=[\"orders:read\"]\n        )\n\n        payload = await jwt_validator.validate_token(token)\n\n        assert payload[\"sub\"] == \"user123\"\n        assert payload[\"email\"] == \"test@example.com\"\n        assert \"customer\" in payload[\"roles\"]\n        assert \"orders:read\" in payload[\"permissions\"]\n\n    async def test_reject_expired_token(self, jwt_manager, jwt_validator):\n        \"\"\"Test that expired tokens are rejected\"\"\"\n        token = jwt_manager.create_access_token(\n            user_id=\"user123\",\n            email=\"test@example.com\",\n            roles=[\"customer\"],\n            permissions=[\"orders:read\"],\n            expires_delta=timedelta(seconds=-1)  # Already expired\n        )\n\n        with pytest.raises(AuthenticationError, match=\"Token has expired\"):\n            await jwt_validator.validate_token(token)\n\n    async def test_reject_invalid_signature(self, jwt_validator):\n        \"\"\"Test that tokens with invalid signatures are rejected\"\"\"\n        # Token with wrong signature\n        invalid_token = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJ1c2VyMTIzIn0.invalid_signature\"\n\n        with pytest.raises(AuthenticationError, match=\"Invalid token\"):\n            await jwt_validator.validate_token(invalid_token)\n\n    async def test_token_revocation(self, jwt_manager, jwt_validator):\n        \"\"\"Test token revocation functionality\"\"\"\n        token = jwt_manager.create_access_token(\n            user_id=\"user123\",\n            email=\"test@example.com\",\n            roles=[\"customer\"],\n            permissions=[\"orders:read\"]\n        )\n\n        # Token should be valid initially\n        payload = await jwt_validator.validate_token(token)\n        assert payload[\"sub\"] == \"user123\"\n\n        # Revoke token\n        revocation_service = TokenRevocationService()\n        await revocation_service.revoke_token(token, \"test_revocation\")\n\n        # Token should now be rejected\n        with pytest.raises(AuthenticationError, match=\"Token has been revoked\"):\n            await jwt_validator.validate_token(token)\n</code></pre>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#production-deployment-checklist","title":"Production Deployment Checklist","text":"<p>Before deploying JWT authentication to production:</p>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#security-configuration","title":"Security Configuration","text":"<ul> <li>[ ] Use RS256 algorithm with proper key pairs</li> <li>[ ] Store private keys in AWS Secrets Manager</li> <li>[ ] Configure automatic key rotation</li> <li>[ ] Implement token revocation system</li> <li>[ ] Set appropriate token expiration times</li> <li>[ ] Enable comprehensive audit logging</li> </ul>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#performance-optimization_1","title":"Performance Optimization","text":"<ul> <li>[ ] Implement multi-level caching</li> <li>[ ] Configure Redis for shared cache</li> <li>[ ] Monitor validation performance</li> <li>[ ] Set up cache metrics and alerts</li> <li>[ ] Optimize token payload size</li> </ul>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#aws-integration","title":"AWS Integration","text":"<ul> <li>[ ] Configure API Gateway custom authorizer</li> <li>[ ] Set up ECS/Lambda middleware</li> <li>[ ] Integrate with AWS Cognito if needed</li> <li>[ ] Configure CloudWatch monitoring</li> <li>[ ] Set up security alerts</li> </ul>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#monitoring-and-maintenance","title":"Monitoring and Maintenance","text":"<ul> <li>[ ] Track token validation metrics</li> <li>[ ] Monitor for suspicious activity</li> <li>[ ] Set up key rotation alerts</li> <li>[ ] Configure performance monitoring</li> <li>[ ] Plan incident response procedures</li> </ul>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#conclusion","title":"Conclusion","text":"<p>JWT authentication in AWS environments requires careful attention to security, performance, and operational concerns. The clean-py repository provides a production-ready foundation that handles the complexities of key management, token validation, caching, and AWS integration.</p> <p>Key takeaways for production JWT implementation:</p> <ol> <li>Security First: Use RS256, proper key management, and comprehensive validation</li> <li>Performance Matters: Implement caching and optimize validation paths</li> <li>AWS Integration: Leverage AWS services for scalability and security</li> <li>Monitoring Essential: Track security events and performance metrics</li> <li>Operational Excellence: Plan for key rotation, incident response, and maintenance</li> </ol> <p>The difference between a basic JWT implementation and a production-ready system lies in the details\u2014proper error handling, performance optimization, security monitoring, and operational procedures. The clean-py patterns provide these details, giving you a solid foundation for enterprise authentication systems.</p>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/12/jwt-authentication-in-aws---from-development-to-production/#references","title":"References","text":"<ul> <li>Clean-Py Repository - Production JWT implementation</li> <li>RFC 7519 - JSON Web Token specification</li> <li>AWS Cognito Documentation - AWS authentication service</li> <li>JWT Best Practices - Security considerations</li> </ul> <p>Start with security, optimize for performance, integrate with AWS services, and build comprehensive monitoring from day one. Your users depend on secure authentication, and your operations team will thank you for building a system that's observable, maintainable, and secure.</p>","tags":["jwt","authentication","aws","security","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/","title":"FastAPI + Clean Architecture: A Match Made in Heaven","text":"<p>FastAPI has revolutionized Python web development with its modern approach to API design, automatic documentation, and exceptional performance. But many developers treat it as just another web framework, missing the opportunity to leverage its unique features within a Clean Architecture approach. The combination of FastAPI's dependency injection, type safety, and automatic validation with Clean Architecture's separation of concerns creates a powerful foundation for scalable applications.</p> <p>The clean-py repository demonstrates how FastAPI and Clean Architecture complement each other perfectly. This isn't just about using FastAPI as a web server\u2014it's about leveraging its design philosophy to reinforce architectural boundaries and create truly maintainable systems.</p>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#why-fastapi-and-clean-architecture-work-so-well-together","title":"Why FastAPI and Clean Architecture Work So Well Together","text":"<p>I've built REST APIs with Flask, Django REST Framework, and FastAPI. While each has its strengths, FastAPI's design philosophy aligns uniquely well with Clean Architecture principles:</p> <p>Type Safety: FastAPI's reliance on Python type hints enforces contracts between layers, making dependency inversion explicit and checkable.</p> <p>Dependency Injection: FastAPI's dependency system naturally implements the dependency inversion principle, making testing and mocking straightforward.</p> <p>Automatic Validation: Pydantic integration handles input validation at the presentation layer, keeping domain logic pure.</p> <p>Documentation Generation: OpenAPI documentation stays in sync with implementation, reducing maintenance overhead.</p> <p>Performance: ASGI foundation provides the performance needed for production systems without sacrificing development velocity.</p> <p>A recent project demonstrated this perfectly. We migrated a Django REST Framework API with 50+ endpoints to FastAPI with Clean Architecture. The result: 40% performance improvement, 60% reduction in test execution time, and dramatically improved code maintainability. The architectural boundaries became self-enforcing through FastAPI's type system.</p>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#clean-architecture-layers-with-fastapi","title":"Clean Architecture Layers with FastAPI","text":"<p>Let's examine how FastAPI components map to Clean Architecture layers:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Presentation Layer                       \u2502\n\u2502  \u2022 FastAPI routers   \u2022 Request/Response models             \u2502  \n\u2502  \u2022 Middleware        \u2022 Exception handlers                  \u2502\n\u2502  \u2022 Dependency injection for controllers                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Application Layer                        \u2502\n\u2502  \u2022 Use case classes  \u2022 Command/Query handlers              \u2502\n\u2502  \u2022 Service interfaces                                      \u2502\n\u2502  \u2022 FastAPI dependencies for use case injection             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Domain Layer                            \u2502\n\u2502  \u2022 Entities          \u2022 Value objects                       \u2502\n\u2502  \u2022 Domain services   \u2022 Repository interfaces               \u2502\n\u2502  \u2022 Business rules    \u2022 Domain events                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Infrastructure Layer                       \u2502\n\u2502  \u2022 Repository implementations                               \u2502\n\u2502  \u2022 Database models   \u2022 External service clients            \u2502\n\u2502  \u2022 FastAPI dependencies for infrastructure injection       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>This layering provides natural separation of concerns while leveraging FastAPI's strengths at each layer.</p>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#presentation-layer-implementation","title":"Presentation Layer Implementation","text":"","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#router-organization","title":"Router Organization","text":"<p>The clean-py repository organizes FastAPI routers by domain aggregate, maintaining clean boundaries:</p> <pre><code># src/presentation/routers/orders.py\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom typing import List, Optional\n\nfrom ..dependencies import get_order_service, get_current_user\nfrom ..models.requests import CreateOrderRequest, UpdateOrderRequest\nfrom ..models.responses import OrderResponse, OrderListResponse\nfrom ...application.use_cases.orders import (\n    CreateOrderUseCase,\n    GetOrderUseCase,\n    ListOrdersUseCase,\n    UpdateOrderUseCase\n)\nfrom ...domain.entities.user import User\n\nrouter = APIRouter(prefix=\"/orders\", tags=[\"orders\"])\n\n@router.post(\"/\", response_model=OrderResponse, status_code=status.HTTP_201_CREATED)\nasync def create_order(\n    request: CreateOrderRequest,\n    current_user: User = Depends(get_current_user),\n    create_order_use_case: CreateOrderUseCase = Depends()\n) -&gt; OrderResponse:\n    \"\"\"Create a new order for the authenticated user.\"\"\"\n\n    try:\n        order = await create_order_use_case.execute(\n            user_id=current_user.id,\n            order_data=request.model_dump(),\n            requesting_user=current_user\n        )\n        return OrderResponse.from_domain(order)\n\n    except OrderCreationError as e:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=str(e)\n        )\n    except InsufficientPermissionError as e:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=str(e)\n        )\n\n@router.get(\"/{order_id}\", response_model=OrderResponse)\nasync def get_order(\n    order_id: str,\n    current_user: User = Depends(get_current_user),\n    get_order_use_case: GetOrderUseCase = Depends()\n) -&gt; OrderResponse:\n    \"\"\"Get a specific order by ID.\"\"\"\n\n    try:\n        order = await get_order_use_case.execute(\n            order_id=order_id,\n            requesting_user=current_user\n        )\n        return OrderResponse.from_domain(order)\n\n    except OrderNotFoundError:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Order not found\"\n        )\n\n@router.get(\"/\", response_model=OrderListResponse)\nasync def list_orders(\n    limit: int = 50,\n    offset: int = 0,\n    status_filter: Optional[str] = None,\n    current_user: User = Depends(get_current_user),\n    list_orders_use_case: ListOrdersUseCase = Depends()\n) -&gt; OrderListResponse:\n    \"\"\"List orders for the authenticated user.\"\"\"\n\n    orders = await list_orders_use_case.execute(\n        user_id=current_user.id,\n        limit=limit,\n        offset=offset,\n        status_filter=status_filter,\n        requesting_user=current_user\n    )\n\n    return OrderListResponse(\n        orders=[OrderResponse.from_domain(order) for order in orders.items],\n        total=orders.total,\n        limit=limit,\n        offset=offset\n    )\n</code></pre>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#requestresponse-models","title":"Request/Response Models","text":"<p>Pydantic models define the presentation layer contract, separate from domain entities:</p> <pre><code># src/presentation/models/requests.py\nfrom pydantic import BaseModel, Field, validator\nfrom typing import List, Optional, Dict, Any\nfrom decimal import Decimal\nfrom datetime import datetime\n\nclass OrderItemRequest(BaseModel):\n    product_id: str = Field(..., description=\"Product identifier\")\n    quantity: int = Field(..., ge=1, le=100, description=\"Item quantity\")\n    unit_price: Optional[Decimal] = Field(None, description=\"Override unit price\")\n\n    @validator('unit_price')\n    def validate_unit_price(cls, v):\n        if v is not None and v &lt;= 0:\n            raise ValueError('Unit price must be positive')\n        return v\n\nclass AddressRequest(BaseModel):\n    street_address: str = Field(..., max_length=255)\n    city: str = Field(..., max_length=100)\n    state: str = Field(..., max_length=50)\n    postal_code: str = Field(..., max_length=20)\n    country: str = Field(..., max_length=50)\n\nclass CreateOrderRequest(BaseModel):\n    items: List[OrderItemRequest] = Field(..., min_items=1, max_items=50)\n    shipping_address: AddressRequest\n    billing_address: Optional[AddressRequest] = None\n    payment_method_id: str = Field(..., description=\"Payment method identifier\")\n    discount_code: Optional[str] = Field(None, max_length=50)\n    special_instructions: Optional[str] = Field(None, max_length=500)\n\n    @validator('items')\n    def validate_items(cls, items):\n        # Business validation at presentation layer\n        product_ids = [item.product_id for item in items]\n        if len(product_ids) != len(set(product_ids)):\n            raise ValueError('Duplicate products not allowed')\n        return items\n\n    class Config:\n        schema_extra = {\n            \"example\": {\n                \"items\": [\n                    {\n                        \"product_id\": \"prod_123\",\n                        \"quantity\": 2,\n                        \"unit_price\": 29.99\n                    }\n                ],\n                \"shipping_address\": {\n                    \"street_address\": \"123 Main St\",\n                    \"city\": \"Seattle\",\n                    \"state\": \"WA\", \n                    \"postal_code\": \"98101\",\n                    \"country\": \"US\"\n                },\n                \"payment_method_id\": \"pm_456\",\n                \"discount_code\": \"SAVE10\"\n            }\n        }\n\n# src/presentation/models/responses.py\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Dict, Any\nfrom decimal import Decimal\nfrom datetime import datetime\nfrom enum import Enum\n\nfrom ...domain.entities.order import Order\nfrom ...domain.value_objects.money import Money\nfrom ...domain.value_objects.address import Address\n\nclass OrderStatus(str, Enum):\n    PENDING = \"pending\"\n    CONFIRMED = \"confirmed\"\n    SHIPPED = \"shipped\"\n    DELIVERED = \"delivered\"\n    CANCELLED = \"cancelled\"\n\nclass OrderItemResponse(BaseModel):\n    product_id: str\n    product_name: str\n    quantity: int\n    unit_price: Decimal\n    total_price: Decimal\n\nclass AddressResponse(BaseModel):\n    street_address: str\n    city: str\n    state: str\n    postal_code: str\n    country: str\n\n    @classmethod\n    def from_domain(cls, address: Address) -&gt; 'AddressResponse':\n        return cls(\n            street_address=address.street_address,\n            city=address.city,\n            state=address.state,\n            postal_code=address.postal_code,\n            country=address.country\n        )\n\nclass OrderResponse(BaseModel):\n    id: str\n    status: OrderStatus\n    items: List[OrderItemResponse]\n    subtotal: Decimal\n    tax_amount: Decimal\n    shipping_cost: Decimal\n    discount_amount: Decimal\n    total_amount: Decimal\n    currency: str\n    shipping_address: AddressResponse\n    billing_address: Optional[AddressResponse]\n    created_at: datetime\n    updated_at: datetime\n\n    @classmethod\n    def from_domain(cls, order: Order) -&gt; 'OrderResponse':\n        \"\"\"Convert domain entity to response model\"\"\"\n        return cls(\n            id=str(order.id),\n            status=OrderStatus(order.status.value),\n            items=[\n                OrderItemResponse(\n                    product_id=str(item.product_id),\n                    product_name=item.product_name,\n                    quantity=item.quantity,\n                    unit_price=item.unit_price.amount,\n                    total_price=item.total_price.amount\n                ) for item in order.items\n            ],\n            subtotal=order.subtotal.amount,\n            tax_amount=order.tax_amount.amount,\n            shipping_cost=order.shipping_cost.amount,\n            discount_amount=order.discount_amount.amount,\n            total_amount=order.total_amount.amount,\n            currency=order.total_amount.currency,\n            shipping_address=AddressResponse.from_domain(order.shipping_address),\n            billing_address=AddressResponse.from_domain(order.billing_address) if order.billing_address else None,\n            created_at=order.created_at,\n            updated_at=order.updated_at\n        )\n\n    class Config:\n        schema_extra = {\n            \"example\": {\n                \"id\": \"ord_abc123\",\n                \"status\": \"confirmed\",\n                \"items\": [\n                    {\n                        \"product_id\": \"prod_123\",\n                        \"product_name\": \"Premium Widget\",\n                        \"quantity\": 2,\n                        \"unit_price\": 29.99,\n                        \"total_price\": 59.98\n                    }\n                ],\n                \"subtotal\": 59.98,\n                \"tax_amount\": 4.80,\n                \"shipping_cost\": 9.99,\n                \"discount_amount\": 6.00,\n                \"total_amount\": 68.77,\n                \"currency\": \"USD\"\n            }\n        }\n</code></pre>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#dependency-injection-for-clean-architecture","title":"Dependency Injection for Clean Architecture","text":"<p>FastAPI's dependency system beautifully implements dependency inversion:</p> <pre><code># src/presentation/dependencies.py\nfrom fastapi import Depends, HTTPException, status\nfrom typing import Annotated\n\n# Infrastructure dependencies\ndef get_database() -&gt; Database:\n    \"\"\"Get database connection\"\"\"\n    return Database(DATABASE_URL)\n\ndef get_redis() -&gt; Redis:\n    \"\"\"Get Redis client\"\"\"\n    return Redis(REDIS_URL)\n\ndef get_event_bus() -&gt; EventBus:\n    \"\"\"Get event bus for domain events\"\"\"\n    return EventBus()\n\n# Repository dependencies\ndef get_order_repository(\n    db: Database = Depends(get_database)\n) -&gt; OrderRepository:\n    \"\"\"Get order repository implementation\"\"\"\n    return SQLOrderRepository(db)\n\ndef get_product_repository(\n    db: Database = Depends(get_database)\n) -&gt; ProductRepository:\n    \"\"\"Get product repository implementation\"\"\"\n    return SQLProductRepository(db)\n\ndef get_user_repository(\n    db: Database = Depends(get_database)\n) -&gt; UserRepository:\n    \"\"\"Get user repository implementation\"\"\"\n    return SQLUserRepository(db)\n\n# Service dependencies\ndef get_payment_service() -&gt; PaymentService:\n    \"\"\"Get payment service implementation\"\"\"\n    return StripePaymentService(api_key=STRIPE_API_KEY)\n\ndef get_inventory_service() -&gt; InventoryService:\n    \"\"\"Get inventory service implementation\"\"\"\n    return InventoryService()\n\ndef get_notification_service() -&gt; NotificationService:\n    \"\"\"Get notification service implementation\"\"\"\n    return EmailNotificationService()\n\n# Use case dependencies\ndef get_create_order_use_case(\n    order_repo: OrderRepository = Depends(get_order_repository),\n    product_repo: ProductRepository = Depends(get_product_repository),\n    payment_service: PaymentService = Depends(get_payment_service),\n    inventory_service: InventoryService = Depends(get_inventory_service),\n    event_bus: EventBus = Depends(get_event_bus)\n) -&gt; CreateOrderUseCase:\n    \"\"\"Get create order use case with all dependencies\"\"\"\n    return CreateOrderUseCase(\n        order_repository=order_repo,\n        product_repository=product_repo,\n        payment_service=payment_service,\n        inventory_service=inventory_service,\n        event_bus=event_bus\n    )\n\ndef get_order_service(\n    order_repo: OrderRepository = Depends(get_order_repository),\n    event_bus: EventBus = Depends(get_event_bus)\n) -&gt; OrderService:\n    \"\"\"Get order service with dependencies\"\"\"\n    return OrderService(\n        order_repository=order_repo,\n        event_bus=event_bus\n    )\n\n# Authentication dependencies\nasync def get_current_user(\n    token: str = Depends(oauth2_scheme),\n    user_repo: UserRepository = Depends(get_user_repository)\n) -&gt; User:\n    \"\"\"Get currently authenticated user\"\"\"\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        user_id = payload.get(\"sub\")\n        if user_id is None:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid authentication credentials\"\n            )\n    except JWTError:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication credentials\"\n        )\n\n    user = await user_repo.get_by_id(user_id)\n    if user is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"User not found\"\n        )\n    return user\n\n# Type aliases for cleaner code\nCurrentUser = Annotated[User, Depends(get_current_user)]\nCreateOrderUseCaseDep = Annotated[CreateOrderUseCase, Depends(get_create_order_use_case)]\n</code></pre>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#application-layer-integration","title":"Application Layer Integration","text":"<p>The application layer contains use cases that orchestrate business operations:</p> <pre><code># src/application/use_cases/orders/create_order.py\nfrom typing import Dict, Any\nfrom dataclasses import dataclass\n\nfrom ...domain.entities.user import User\nfrom ...domain.entities.order import Order\nfrom ...domain.repositories.order_repository import OrderRepository\nfrom ...domain.repositories.product_repository import ProductRepository\nfrom ...domain.services.payment_service import PaymentService\nfrom ...domain.services.inventory_service import InventoryService\nfrom ...infrastructure.events.event_bus import EventBus\nfrom ...domain.events.order_events import OrderCreatedEvent\n\n@dataclass\nclass CreateOrderCommand:\n    user_id: str\n    items: list[Dict[str, Any]]\n    shipping_address: Dict[str, str]\n    billing_address: Dict[str, str]\n    payment_method_id: str\n    discount_code: str | None = None\n\nclass CreateOrderUseCase:\n    def __init__(\n        self,\n        order_repository: OrderRepository,\n        product_repository: ProductRepository,\n        payment_service: PaymentService,\n        inventory_service: InventoryService,\n        event_bus: EventBus\n    ):\n        self.order_repository = order_repository\n        self.product_repository = product_repository\n        self.payment_service = payment_service\n        self.inventory_service = inventory_service\n        self.event_bus = event_bus\n\n    async def execute(\n        self,\n        user_id: str,\n        order_data: Dict[str, Any],\n        requesting_user: User\n    ) -&gt; Order:\n        \"\"\"Execute order creation use case\"\"\"\n\n        # Authorization check\n        if requesting_user.id != user_id and not requesting_user.is_admin:\n            raise InsufficientPermissionError(\"Cannot create order for another user\")\n\n        # Validate products exist and have sufficient inventory\n        product_ids = [item['product_id'] for item in order_data['items']]\n        products = await self.product_repository.get_by_ids(product_ids)\n\n        if len(products) != len(product_ids):\n            missing_ids = set(product_ids) - {str(p.id) for p in products}\n            raise ProductNotFoundError(f\"Products not found: {missing_ids}\")\n\n        # Check inventory\n        for item_data in order_data['items']:\n            product = next(p for p in products if str(p.id) == item_data['product_id'])\n            available = await self.inventory_service.check_availability(\n                product.id, \n                item_data['quantity']\n            )\n            if not available:\n                raise InsufficientInventoryError(f\"Insufficient inventory for {product.name}\")\n\n        # Create order domain entity\n        order = Order.create(\n            user_id=user_id,\n            items_data=order_data['items'],\n            products=products,\n            shipping_address=order_data['shipping_address'],\n            billing_address=order_data.get('billing_address'),\n            payment_method_id=order_data['payment_method_id'],\n            discount_code=order_data.get('discount_code')\n        )\n\n        # Reserve inventory\n        for item in order.items:\n            await self.inventory_service.reserve_inventory(\n                item.product_id,\n                item.quantity,\n                order.id\n            )\n\n        # Process payment\n        payment_result = await self.payment_service.process_payment(\n            amount=order.total_amount,\n            payment_method_id=order_data['payment_method_id'],\n            order_id=str(order.id)\n        )\n\n        if not payment_result.success:\n            # Release reserved inventory\n            await self._release_inventory(order)\n            raise PaymentProcessingError(payment_result.error_message)\n\n        # Save order\n        saved_order = await self.order_repository.save(order)\n\n        # Publish domain event\n        await self.event_bus.publish(\n            OrderCreatedEvent(\n                order_id=str(saved_order.id),\n                user_id=saved_order.user_id,\n                total_amount=saved_order.total_amount.amount,\n                currency=saved_order.total_amount.currency\n            )\n        )\n\n        return saved_order\n\n    async def _release_inventory(self, order: Order):\n        \"\"\"Release reserved inventory in case of failure\"\"\"\n        for item in order.items:\n            try:\n                await self.inventory_service.release_reservation(\n                    item.product_id,\n                    item.quantity,\n                    order.id\n                )\n            except Exception:\n                # Log but don't fail the operation\n                pass\n</code></pre>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#middleware-and-error-handling","title":"Middleware and Error Handling","text":"<p>FastAPI middleware integrates cleanly with Clean Architecture concerns:</p> <pre><code># src/presentation/middleware/logging_middleware.py\nfrom fastapi import Request, Response\nfrom starlette.middleware.base import BaseHTTPMiddleware\nimport time\nimport uuid\n\nfrom ...infrastructure.logging import get_logger\n\nlogger = get_logger(__name__)\n\nclass RequestLoggingMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next):\n        # Generate correlation ID\n        correlation_id = str(uuid.uuid4())\n        request.state.correlation_id = correlation_id\n\n        # Log request\n        start_time = time.perf_counter()\n        logger.info(\n            \"Request started\",\n            extra={\n                \"correlation_id\": correlation_id,\n                \"method\": request.method,\n                \"url\": str(request.url),\n                \"client_ip\": request.client.host,\n                \"user_agent\": request.headers.get(\"user-agent\"),\n                \"content_length\": request.headers.get(\"content-length\")\n            }\n        )\n\n        # Process request\n        try:\n            response = await call_next(request)\n            duration = (time.perf_counter() - start_time) * 1000\n\n            # Log response\n            logger.info(\n                \"Request completed\",\n                extra={\n                    \"correlation_id\": correlation_id,\n                    \"status_code\": response.status_code,\n                    \"duration_ms\": round(duration, 2),\n                    \"response_size\": response.headers.get(\"content-length\")\n                }\n            )\n\n            # Add correlation ID to response headers\n            response.headers[\"X-Correlation-ID\"] = correlation_id\n            return response\n\n        except Exception as e:\n            duration = (time.perf_counter() - start_time) * 1000\n            logger.error(\n                \"Request failed\",\n                extra={\n                    \"correlation_id\": correlation_id,\n                    \"error\": str(e),\n                    \"error_type\": type(e).__name__,\n                    \"duration_ms\": round(duration, 2)\n                },\n                exc_info=True\n            )\n            raise\n\n# src/presentation/middleware/exception_handlers.py\nfrom fastapi import Request, HTTPException\nfrom fastapi.responses import JSONResponse\nimport traceback\n\nfrom ...domain.exceptions import (\n    DomainException,\n    OrderNotFoundError,\n    InsufficientInventoryError,\n    PaymentProcessingError\n)\nfrom ...infrastructure.logging import get_logger\n\nlogger = get_logger(__name__)\n\nasync def domain_exception_handler(request: Request, exc: DomainException):\n    \"\"\"Handle domain-specific exceptions\"\"\"\n    correlation_id = getattr(request.state, 'correlation_id', 'unknown')\n\n    logger.warning(\n        \"Domain exception occurred\",\n        extra={\n            \"correlation_id\": correlation_id,\n            \"exception_type\": type(exc).__name__,\n            \"exception_message\": str(exc),\n            \"endpoint\": str(request.url),\n            \"method\": request.method\n        }\n    )\n\n    # Map domain exceptions to HTTP status codes\n    status_code_mapping = {\n        OrderNotFoundError: 404,\n        InsufficientInventoryError: 409,\n        PaymentProcessingError: 402,\n    }\n\n    status_code = status_code_mapping.get(type(exc), 400)\n\n    return JSONResponse(\n        status_code=status_code,\n        content={\n            \"error\": {\n                \"type\": type(exc).__name__,\n                \"message\": str(exc),\n                \"correlation_id\": correlation_id\n            }\n        }\n    )\n\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    \"\"\"Handle validation errors from Pydantic\"\"\"\n    correlation_id = getattr(request.state, 'correlation_id', 'unknown')\n\n    logger.info(\n        \"Validation error occurred\",\n        extra={\n            \"correlation_id\": correlation_id,\n            \"errors\": exc.errors(),\n            \"endpoint\": str(request.url)\n        }\n    )\n\n    return JSONResponse(\n        status_code=422,\n        content={\n            \"error\": {\n                \"type\": \"ValidationError\",\n                \"message\": \"Request validation failed\",\n                \"details\": exc.errors(),\n                \"correlation_id\": correlation_id\n            }\n        }\n    )\n\nasync def http_exception_handler(request: Request, exc: HTTPException):\n    \"\"\"Handle FastAPI HTTP exceptions\"\"\"\n    correlation_id = getattr(request.state, 'correlation_id', 'unknown')\n\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\n            \"error\": {\n                \"type\": \"HTTPException\",\n                \"message\": exc.detail,\n                \"correlation_id\": correlation_id\n            }\n        }\n    )\n\nasync def internal_server_error_handler(request: Request, exc: Exception):\n    \"\"\"Handle unexpected server errors\"\"\"\n    correlation_id = getattr(request.state, 'correlation_id', 'unknown')\n\n    logger.error(\n        \"Unexpected server error\",\n        extra={\n            \"correlation_id\": correlation_id,\n            \"exception_type\": type(exc).__name__,\n            \"exception_message\": str(exc),\n            \"endpoint\": str(request.url),\n            \"method\": request.method,\n            \"traceback\": traceback.format_exc()\n        }\n    )\n\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": {\n                \"type\": \"InternalServerError\",\n                \"message\": \"An unexpected error occurred\",\n                \"correlation_id\": correlation_id\n            }\n        }\n    )\n</code></pre>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#application-factory-pattern","title":"Application Factory Pattern","text":"<p>The application factory pattern provides clean initialization:</p> <pre><code># src/presentation/main.py\nfrom fastapi import FastAPI, Request\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import JSONResponse\nfrom contextlib import asynccontextmanager\n\nfrom .routers import orders, products, users, auth\nfrom .middleware.logging_middleware import RequestLoggingMiddleware\nfrom .middleware.exception_handlers import (\n    domain_exception_handler,\n    validation_exception_handler,\n    http_exception_handler,\n    internal_server_error_handler\n)\nfrom ..domain.exceptions import DomainException\nfrom ..infrastructure.logging import configure_logging\nfrom ..infrastructure.database import initialize_database\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Application lifespan manager\"\"\"\n    # Startup\n    configure_logging()\n    await initialize_database()\n\n    yield\n\n    # Shutdown\n    await cleanup_resources()\n\ndef create_application() -&gt; FastAPI:\n    \"\"\"Application factory function\"\"\"\n\n    app = FastAPI(\n        title=\"Clean Architecture E-commerce API\",\n        description=\"Production-ready e-commerce API built with Clean Architecture principles\",\n        version=\"1.0.0\",\n        docs_url=\"/docs\",\n        redoc_url=\"/redoc\",\n        lifespan=lifespan\n    )\n\n    # Add CORS middleware\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[\"https://yourapp.com\", \"https://admin.yourapp.com\"],\n        allow_credentials=True,\n        allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n        allow_headers=[\"*\"],\n    )\n\n    # Add custom middleware\n    app.add_middleware(RequestLoggingMiddleware)\n\n    # Register exception handlers\n    app.add_exception_handler(DomainException, domain_exception_handler)\n    app.add_exception_handler(ValidationError, validation_exception_handler)\n    app.add_exception_handler(HTTPException, http_exception_handler)\n    app.add_exception_handler(Exception, internal_server_error_handler)\n\n    # Include routers\n    app.include_router(auth.router, prefix=\"/api/v1\")\n    app.include_router(orders.router, prefix=\"/api/v1\")\n    app.include_router(products.router, prefix=\"/api/v1\")\n    app.include_router(users.router, prefix=\"/api/v1\")\n\n    # Health check endpoint\n    @app.get(\"/health\")\n    async def health_check():\n        return {\"status\": \"healthy\", \"version\": \"1.0.0\"}\n\n    return app\n\n# Create application instance\napp = create_application()\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#testing-fastapi-with-clean-architecture","title":"Testing FastAPI with Clean Architecture","text":"<p>The combination enables comprehensive testing at all levels:</p> <pre><code># tests/presentation/test_orders_api.py\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom unittest.mock import Mock, AsyncMock\n\nfrom src.presentation.main import app\nfrom src.domain.entities.order import Order\nfrom src.domain.entities.user import User\nfrom src.application.use_cases.orders.create_order import CreateOrderUseCase\n\n@pytest.fixture\ndef client():\n    return TestClient(app)\n\n@pytest.fixture\ndef mock_create_order_use_case():\n    return Mock(spec=CreateOrderUseCase)\n\n@pytest.fixture\ndef mock_user():\n    return User(\n        id=\"user123\",\n        email=\"test@example.com\",\n        first_name=\"Test\",\n        last_name=\"User\",\n        is_active=True\n    )\n\nclass TestOrdersAPI:\n    def test_create_order_success(\n        self, \n        client: TestClient, \n        mock_create_order_use_case: Mock,\n        mock_user: User\n    ):\n        \"\"\"Test successful order creation\"\"\"\n\n        # Mock dependencies\n        app.dependency_overrides[get_create_order_use_case] = lambda: mock_create_order_use_case\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n\n        # Mock use case response\n        expected_order = Order.create(\n            user_id=\"user123\",\n            items_data=[{\"product_id\": \"prod123\", \"quantity\": 2}],\n            products=[],\n            shipping_address={\"street\": \"123 Main St\"},\n            payment_method_id=\"pm123\"\n        )\n        mock_create_order_use_case.execute = AsyncMock(return_value=expected_order)\n\n        # Make request\n        request_data = {\n            \"items\": [{\"product_id\": \"prod123\", \"quantity\": 2}],\n            \"shipping_address\": {\n                \"street_address\": \"123 Main St\",\n                \"city\": \"Seattle\",\n                \"state\": \"WA\",\n                \"postal_code\": \"98101\",\n                \"country\": \"US\"\n            },\n            \"payment_method_id\": \"pm123\"\n        }\n\n        response = client.post(\"/api/v1/orders/\", json=request_data)\n\n        # Assertions\n        assert response.status_code == 201\n        response_data = response.json()\n        assert response_data[\"id\"] == str(expected_order.id)\n        assert response_data[\"status\"] == \"pending\"\n\n        # Verify use case was called correctly\n        mock_create_order_use_case.execute.assert_called_once()\n\n        # Clean up\n        app.dependency_overrides = {}\n\n    def test_create_order_validation_error(self, client: TestClient, mock_user: User):\n        \"\"\"Test order creation with validation errors\"\"\"\n\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n\n        # Invalid request data (missing required fields)\n        request_data = {\n            \"items\": [],  # Empty items should fail validation\n            \"payment_method_id\": \"pm123\"\n        }\n\n        response = client.post(\"/api/v1/orders/\", json=request_data)\n\n        # Assertions\n        assert response.status_code == 422\n        response_data = response.json()\n        assert \"error\" in response_data\n        assert response_data[\"error\"][\"type\"] == \"ValidationError\"\n\n        app.dependency_overrides = {}\n\n    def test_create_order_domain_exception(\n        self, \n        client: TestClient, \n        mock_create_order_use_case: Mock,\n        mock_user: User\n    ):\n        \"\"\"Test order creation with domain exception\"\"\"\n\n        app.dependency_overrides[get_create_order_use_case] = lambda: mock_create_order_use_case\n        app.dependency_overrides[get_current_user] = lambda: mock_user\n\n        # Mock use case to raise domain exception\n        mock_create_order_use_case.execute = AsyncMock(\n            side_effect=InsufficientInventoryError(\"Product out of stock\")\n        )\n\n        request_data = {\n            \"items\": [{\"product_id\": \"prod123\", \"quantity\": 2}],\n            \"shipping_address\": {\n                \"street_address\": \"123 Main St\",\n                \"city\": \"Seattle\",\n                \"state\": \"WA\",\n                \"postal_code\": \"98101\",\n                \"country\": \"US\"\n            },\n            \"payment_method_id\": \"pm123\"\n        }\n\n        response = client.post(\"/api/v1/orders/\", json=request_data)\n\n        # Assertions\n        assert response.status_code == 409  # Conflict for insufficient inventory\n        response_data = response.json()\n        assert response_data[\"error\"][\"type\"] == \"InsufficientInventoryError\"\n        assert \"Product out of stock\" in response_data[\"error\"][\"message\"]\n\n        app.dependency_overrides = {}\n\n    def test_get_order_unauthorized(self, client: TestClient):\n        \"\"\"Test getting order without authentication\"\"\"\n\n        response = client.get(\"/api/v1/orders/order123\")\n\n        # Should return 401 Unauthorized\n        assert response.status_code == 401\n\n# tests/integration/test_order_flow.py\nimport pytest\nfrom httpx import AsyncClient\nfrom fastapi import FastAPI\n\nfrom tests.fixtures.database import test_database\nfrom tests.fixtures.test_data import create_test_user, create_test_products\n\n@pytest.mark.asyncio\nclass TestOrderFlowIntegration:\n    async def test_complete_order_flow(self, app: FastAPI, test_database):\n        \"\"\"Test complete order creation flow with real database\"\"\"\n\n        # Setup test data\n        user = await create_test_user()\n        products = await create_test_products()\n\n        async with AsyncClient(app=app, base_url=\"http://test\") as client:\n            # Login to get token\n            login_response = await client.post(\"/api/v1/auth/login\", json={\n                \"email\": user.email,\n                \"password\": \"testpassword\"\n            })\n            assert login_response.status_code == 200\n            token = login_response.json()[\"access_token\"]\n\n            headers = {\"Authorization\": f\"Bearer {token}\"}\n\n            # Create order\n            order_data = {\n                \"items\": [\n                    {\"product_id\": str(products[0].id), \"quantity\": 2},\n                    {\"product_id\": str(products[1].id), \"quantity\": 1}\n                ],\n                \"shipping_address\": {\n                    \"street_address\": \"123 Test St\",\n                    \"city\": \"Test City\",\n                    \"state\": \"TS\",\n                    \"postal_code\": \"12345\",\n                    \"country\": \"US\"\n                },\n                \"payment_method_id\": \"pm_test123\"\n            }\n\n            create_response = await client.post(\n                \"/api/v1/orders/\",\n                json=order_data,\n                headers=headers\n            )\n\n            assert create_response.status_code == 201\n            order = create_response.json()\n            assert order[\"status\"] == \"pending\"\n            assert len(order[\"items\"]) == 2\n\n            # Get order\n            get_response = await client.get(\n                f\"/api/v1/orders/{order['id']}\",\n                headers=headers\n            )\n\n            assert get_response.status_code == 200\n            retrieved_order = get_response.json()\n            assert retrieved_order[\"id\"] == order[\"id\"]\n            assert retrieved_order[\"total_amount\"] &gt; 0\n</code></pre>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#performance-optimization","title":"Performance Optimization","text":"<p>FastAPI and Clean Architecture together enable several performance optimizations:</p>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#asyncawait-throughout-the-stack","title":"Async/Await Throughout the Stack","text":"<pre><code># All layers support async operations\nclass AsyncOrderRepository:\n    async def save(self, order: Order) -&gt; Order:\n        async with self.db.transaction():\n            # Database operations\n            pass\n\n    async def get_by_id(self, order_id: str) -&gt; Optional[Order]:\n        # Async database query\n        pass\n\nclass CreateOrderUseCase:\n    async def execute(self, command: CreateOrderCommand) -&gt; Order:\n        # All operations are async\n        products = await self.product_repository.get_by_ids(command.product_ids)\n        inventory_check = await self.inventory_service.check_availability(products)\n        order = Order.create(...)\n        result = await self.order_repository.save(order)\n        await self.event_bus.publish(OrderCreatedEvent(...))\n        return result\n\n@router.post(\"/orders\")\nasync def create_order(\n    request: CreateOrderRequest,\n    use_case: CreateOrderUseCase = Depends()\n):\n    # End-to-end async\n    return await use_case.execute(...)\n</code></pre>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#dependency-injection-optimization","title":"Dependency Injection Optimization","text":"<pre><code># Singleton services for performance\n@lru_cache()\ndef get_payment_service() -&gt; PaymentService:\n    \"\"\"Cached singleton payment service\"\"\"\n    return StripePaymentService()\n\n# Connection pooling\ndef get_database() -&gt; Database:\n    \"\"\"Get database with connection pooling\"\"\"\n    return Database.get_pool()\n</code></pre>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#production-deployment-patterns","title":"Production Deployment Patterns","text":"","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#health-checks-and-monitoring","title":"Health Checks and Monitoring","text":"<pre><code>@router.get(\"/health\")\nasync def health_check(\n    db: Database = Depends(get_database),\n    redis: Redis = Depends(get_redis)\n):\n    \"\"\"Comprehensive health check\"\"\"\n    health_status = {\"status\": \"healthy\", \"checks\": {}}\n\n    # Database check\n    try:\n        await db.execute(\"SELECT 1\")\n        health_status[\"checks\"][\"database\"] = \"healthy\"\n    except Exception as e:\n        health_status[\"checks\"][\"database\"] = f\"unhealthy: {str(e)}\"\n        health_status[\"status\"] = \"unhealthy\"\n\n    # Redis check\n    try:\n        await redis.ping()\n        health_status[\"checks\"][\"redis\"] = \"healthy\"\n    except Exception as e:\n        health_status[\"checks\"][\"redis\"] = f\"unhealthy: {str(e)}\"\n        health_status[\"status\"] = \"unhealthy\"\n\n    return health_status\n\n@router.get(\"/metrics\")\nasync def metrics():\n    \"\"\"Application metrics for monitoring\"\"\"\n    return {\n        \"orders_created_total\": order_metrics.created_total,\n        \"orders_failed_total\": order_metrics.failed_total,\n        \"active_connections\": db_pool.active_connections,\n        \"memory_usage\": get_memory_usage()\n    }\n</code></pre>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#graceful-shutdown","title":"Graceful Shutdown","text":"<pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    logger.info(\"Starting application\")\n    await initialize_database()\n    await initialize_redis()\n\n    yield\n\n    # Shutdown\n    logger.info(\"Shutting down application\")\n    await cleanup_database()\n    await cleanup_redis()\n    logger.info(\"Application shutdown complete\")\n</code></pre>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#conclusion","title":"Conclusion","text":"<p>FastAPI and Clean Architecture form a powerful combination that leverages the strengths of both approaches. FastAPI's type safety, dependency injection, and automatic validation reinforce Clean Architecture's separation of concerns and dependency inversion principles.</p> <p>The key benefits of this combination:</p> <ol> <li>Type Safety: Python type hints provide compile-time verification of architectural boundaries</li> <li>Dependency Injection: Natural implementation of dependency inversion principle</li> <li>Automatic Validation: Pydantic handles presentation layer validation, keeping domain logic pure</li> <li>Performance: ASGI foundation provides production-ready performance</li> <li>Documentation: OpenAPI generation stays synchronized with implementation</li> <li>Testing: Dependency injection enables comprehensive testing at all levels</li> </ol> <p>The clean-py repository demonstrates these patterns in production-ready code. The result is a system that's both architecturally sound and performant, with clear separation of concerns and comprehensive testing capabilities.</p>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/16/fastapi--clean-architecture---a-match-made-in-heaven/#references","title":"References","text":"<ul> <li>Clean-Py Repository - FastAPI with Clean Architecture</li> <li>FastAPI Documentation - Official FastAPI guide</li> <li>Pydantic Documentation - Data validation library</li> <li>Dependency Injection in FastAPI - Official dependency guide</li> </ul> <p>Start with Clean Architecture principles, leverage FastAPI's unique features to reinforce those boundaries, and build systems that scale both in performance and maintainability. The combination of these approaches creates applications that are truly built to last.</p>","tags":["fastapi","clean-architecture","python","api-design","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/","title":"AWS Deployment Patterns: ECS Fargate vs Lambda for Python Services","text":"<p>Choosing the right AWS deployment pattern for your Python microservices can make the difference between a system that scales seamlessly and one that becomes a maintenance nightmare. The decision between ECS Fargate and Lambda isn't just about compute models\u2014it's about matching your application architecture to the right infrastructure patterns for optimal performance, cost, and operational overhead.</p> <p>The clean-py repository demonstrates both deployment patterns with production-ready configurations. This isn't theoretical comparison\u2014it's practical guidance based on real-world deployments managing millions of requests per day.</p>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#the-deployment-decision-framework","title":"The Deployment Decision Framework","text":"<p>I've deployed the same Clean Architecture Python application on both ECS Fargate and Lambda across different organizations. Each pattern has distinct advantages that align with specific use cases:</p> <p>ECS Fargate excels when you need: - Consistent long-running processes - Complex application state management - Full control over the runtime environment - Traditional microservices patterns - Predictable traffic patterns</p> <p>Lambda shines when you have: - Event-driven architectures - Irregular or spikey traffic - Simple, stateless operations - Cost optimization as a primary concern - Rapid scaling requirements</p> <p>A recent project illustrated this perfectly. We migrated an e-commerce platform from a monolithic architecture to Clean Architecture microservices. The order processing service handles steady traffic and maintains complex business logic\u2014perfect for ECS Fargate. The notification service processes events irregularly with high burst requirements\u2014ideal for Lambda.</p> <p>The key insight: don't choose one pattern for everything. Use the right tool for each service's specific requirements.</p>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#ecs-fargate-container-based-microservices","title":"ECS Fargate: Container-Based Microservices","text":"<p>ECS Fargate provides the traditional microservices experience with AWS-managed infrastructure. Your Python applications run in containers with predictable resource allocation and persistent connections.</p>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#fargate-architecture-pattern","title":"Fargate Architecture Pattern","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Application   \u2502    \u2502  Load Balancer  \u2502    \u2502   ECS Fargate   \u2502\n\u2502   Load Balancer \u2502\u2500\u2500\u2500\u25b6\u2502    (ALB/NLB)    \u2502\u2500\u2500\u2500\u25b6\u2502    Service      \u2502\n\u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502\n\u2502 \u2022 SSL termination\u2502    \u2502 \u2022 Health checks \u2502    \u2502 \u2022 Auto scaling  \u2502\n\u2502 \u2022 Rate limiting \u2502    \u2502 \u2022 Target groups \u2502    \u2502 \u2022 Rolling deploys\u2502\n\u2502 \u2022 WAF protection\u2502    \u2502 \u2022 Sticky sessions\u2502    \u2502 \u2022 Service mesh  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502                       \u2502\n                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                       \u2502   CloudWatch    \u2502    \u2502   Secrets       \u2502\n                       \u2502                 \u2502    \u2502   Manager       \u2502\n                       \u2502 \u2022 Metrics       \u2502    \u2502                 \u2502\n                       \u2502 \u2022 Logs          \u2502\u25c0\u2500\u2500\u2500\u2502 \u2022 DB credentials\u2502\n                       \u2502 \u2022 Alarms        \u2502    \u2502 \u2022 API keys      \u2502\n                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502 \u2022 Certificates  \u2502\n                                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#dockerized-clean-architecture-application","title":"Dockerized Clean Architecture Application","text":"<p>The clean-py repository includes production-ready Docker configurations:</p> <pre><code># Dockerfile\nFROM python:3.11-slim as base\n\n# Set environment variables\nENV PYTHONUNBUFFERED=1 \\\n    PYTHONDONTWRITEBYTECODE=1 \\\n    PIP_NO_CACHE_DIR=1 \\\n    PIP_DISABLE_PIP_VERSION_CHECK=1\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    gcc \\\n    libc6-dev \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Create app user\nRUN groupadd -r app &amp;&amp; useradd -r -g app app\n\nWORKDIR /app\n\n# Install Python dependencies\nCOPY requirements.txt .\nRUN pip install --no-deps -r requirements.txt\n\n# Copy application code\nCOPY src/ src/\nCOPY alembic/ alembic/\nCOPY alembic.ini .\n\n# Set ownership\nRUN chown -R app:app /app\nUSER app\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=5s --start-period=60s --retries=3 \\\n    CMD python -c \"import requests; requests.get('http://localhost:8000/health')\"\n\n# Production stage\nFROM base as production\n\n# Copy only necessary files for production\nCOPY --from=base --chown=app:app /app /app\n\nEXPOSE 8000\n\n# Use Gunicorn for production\nCMD [\"gunicorn\", \"src.presentation.main:app\", \\\n     \"--worker-class\", \"uvicorn.workers.UvicornWorker\", \\\n     \"--workers\", \"4\", \\\n     \"--bind\", \"0.0.0.0:8000\", \\\n     \"--access-logfile\", \"-\", \\\n     \"--error-logfile\", \"-\", \\\n     \"--log-level\", \"info\"]\n\n# Development stage\nFROM base as development\n\n# Install development dependencies\nCOPY requirements-dev.txt .\nRUN pip install --no-deps -r requirements-dev.txt\n\n# Install application in development mode\nRUN pip install -e .\n\nCMD [\"uvicorn\", \"src.presentation.main:app\", \\\n     \"--host\", \"0.0.0.0\", \\\n     \"--port\", \"8000\", \\\n     \"--reload\"]\n</code></pre>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#ecs-task-definition","title":"ECS Task Definition","text":"<pre><code>{\n  \"family\": \"clean-py-order-service\",\n  \"networkMode\": \"awsvpc\",\n  \"requiresCompatibilities\": [\"FARGATE\"],\n  \"cpu\": \"512\",\n  \"memory\": \"1024\",\n  \"executionRoleArn\": \"arn:aws:iam::account:role/ecsTaskExecutionRole\",\n  \"taskRoleArn\": \"arn:aws:iam::account:role/ecsTaskRole\",\n  \"containerDefinitions\": [\n    {\n      \"name\": \"order-service\",\n      \"image\": \"your-account.dkr.ecr.region.amazonaws.com/clean-py:latest\",\n      \"essential\": true,\n      \"portMappings\": [\n        {\n          \"containerPort\": 8000,\n          \"protocol\": \"tcp\"\n        }\n      ],\n      \"environment\": [\n        {\n          \"name\": \"AWS_REGION\",\n          \"value\": \"us-west-2\"\n        },\n        {\n          \"name\": \"ENVIRONMENT\",\n          \"value\": \"production\"\n        }\n      ],\n      \"secrets\": [\n        {\n          \"name\": \"DATABASE_URL\",\n          \"valueFrom\": \"arn:aws:secretsmanager:region:account:secret:clean-py/database-url\"\n        },\n        {\n          \"name\": \"JWT_SECRET_KEY\",\n          \"valueFrom\": \"arn:aws:secretsmanager:region:account:secret:clean-py/jwt-secret\"\n        }\n      ],\n      \"logConfiguration\": {\n        \"logDriver\": \"awslogs\",\n        \"options\": {\n          \"awslogs-group\": \"/ecs/clean-py-order-service\",\n          \"awslogs-region\": \"us-west-2\",\n          \"awslogs-stream-prefix\": \"ecs\"\n        }\n      },\n      \"healthCheck\": {\n        \"command\": [\n          \"CMD-SHELL\",\n          \"python -c \\\"import requests; requests.get('http://localhost:8000/health')\\\"\"\n        ],\n        \"interval\": 30,\n        \"timeout\": 5,\n        \"retries\": 3,\n        \"startPeriod\": 60\n      }\n    }\n  ]\n}\n</code></pre>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#infrastructure-as-code-options","title":"Infrastructure as Code Options","text":"<p>When deploying to AWS, you have several Infrastructure as Code (IaC) options. Each has its place in the development lifecycle:</p> <p>CloudFormation is AWS's native IaC service, perfect for prototyping and experimentation. Its declarative YAML/JSON format makes it easy to understand, and most importantly, it provides simple cleanup\u2014delete the stack and everything is gone. This makes CloudFormation ideal for development environments where you're iterating quickly:</p> <pre><code># cloudformation/prototype-stack.yaml\n# Great for prototyping - easy to create and tear down\nAWSTemplateFormatVersion: '2010-09-09'\nDescription: Prototype ECS Fargate stack for clean-py\n\nParameters:\n  EnvironmentName:\n    Type: String\n    Default: prototype\n    Description: Environment name prefix\n\nResources:\n  # Simple ECS cluster for testing\n  ECSCluster:\n    Type: AWS::ECS::Cluster\n    Properties:\n      ClusterName: !Sub ${EnvironmentName}-cluster\n\n  # Task definition\n  TaskDefinition:\n    Type: AWS::ECS::TaskDefinition\n    Properties:\n      Family: !Sub ${EnvironmentName}-task\n      NetworkMode: awsvpc\n      RequiresCompatibilities: [FARGATE]\n      Cpu: '256'\n      Memory: '512'\n      ContainerDefinitions:\n        - Name: app\n          Image: !Sub ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/clean-py:latest\n          PortMappings:\n            - ContainerPort: 8000\n\n  # Quick cleanup with: aws cloudformation delete-stack --stack-name prototype-stack\n</code></pre> <p>For production environments, however, you'll want more sophisticated tools:</p> <p>AWS CDK (Cloud Development Kit) lets you define infrastructure using familiar programming languages. This is the recommended approach for production Python applications\u2014you can use Python to define your Python application's infrastructure:</p> <pre><code># infrastructure/ecs_stack.py\nfrom aws_cdk import (\n    Stack,\n    aws_ecs as ecs,\n    aws_ec2 as ec2,\n    aws_elasticloadbalancingv2 as elbv2,\n    aws_logs as logs,\n    aws_secretsmanager as secretsmanager,\n    aws_iam as iam,\n    Duration\n)\n\nclass CleanPyECSStack(Stack):\n    def __init__(self, scope, construct_id, **kwargs):\n        super().__init__(scope, construct_id, **kwargs)\n\n        # VPC\n        vpc = ec2.Vpc(\n            self, \"CleanPyVPC\",\n            max_azs=2,\n            nat_gateways=1,\n            enable_dns_hostnames=True,\n            enable_dns_support=True\n        )\n\n        # ECS Cluster\n        cluster = ecs.Cluster(\n            self, \"CleanPyCluster\",\n            vpc=vpc,\n            enable_fargate_capacity_providers=True\n        )\n\n        # Task Definition\n        task_definition = ecs.FargateTaskDefinition(\n            self, \"OrderServiceTaskDef\",\n            memory_limit_mib=1024,\n            cpu=512\n        )\n\n        # Add container\n        container = task_definition.add_container(\n            \"OrderServiceContainer\",\n            image=ecs.ContainerImage.from_registry(\"your-registry/clean-py:latest\"),\n            logging=ecs.LogDrivers.aws_logs(\n                stream_prefix=\"order-service\",\n                log_retention=logs.RetentionDays.ONE_WEEK\n            ),\n            environment={\n                \"AWS_REGION\": self.region,\n                \"ENVIRONMENT\": \"production\"\n            },\n            secrets={\n                \"DATABASE_URL\": ecs.Secret.from_secrets_manager(\n                    secretsmanager.Secret.from_secret_name(\n                        self, \"DatabaseSecret\", \"clean-py/database\"\n                    )\n                )\n            }\n        )\n\n        container.add_port_mappings(\n            ecs.PortMapping(container_port=8000)\n        )\n\n        # Security Group\n        security_group = ec2.SecurityGroup(\n            self, \"OrderServiceSG\",\n            vpc=vpc,\n            description=\"Security group for Order Service\"\n        )\n        security_group.add_ingress_rule(\n            ec2.Peer.any_ipv4(),\n            ec2.Port.tcp(8000),\n            \"Allow HTTP traffic\"\n        )\n\n        # ECS Service\n        service = ecs.FargateService(\n            self, \"OrderService\",\n            cluster=cluster,\n            task_definition=task_definition,\n            desired_count=2,\n            security_groups=[security_group],\n            enable_logging=True,\n            health_check_grace_period=Duration.seconds(60)\n        )\n\n        # Application Load Balancer\n        alb = elbv2.ApplicationLoadBalancer(\n            self, \"OrderServiceALB\",\n            vpc=vpc,\n            internet_facing=True\n        )\n\n        # Target Group\n        target_group = elbv2.ApplicationTargetGroup(\n            self, \"OrderServiceTargets\",\n            port=8000,\n            vpc=vpc,\n            target_type=elbv2.TargetType.IP,\n            health_check_path=\"/health\",\n            health_check_interval=Duration.seconds(30)\n        )\n\n        # Listener\n        listener = alb.add_listener(\n            \"OrderServiceListener\",\n            port=80,\n            default_target_groups=[target_group]\n        )\n\n        # Auto Scaling\n        scaling = service.auto_scale_task_count(max_capacity=10, min_capacity=2)\n        scaling.scale_on_cpu_utilization(\n            \"CpuScaling\",\n            target_utilization_percent=70,\n            scale_in_cooldown=Duration.seconds(300),\n            scale_out_cooldown=Duration.seconds(60)\n        )\n\n        scaling.scale_on_memory_utilization(\n            \"MemoryScaling\",\n            target_utilization_percent=80\n        )\n</code></pre> <p>Terraform is another excellent production choice, especially if you're working with multiple cloud providers or prefer a cloud-agnostic approach. Its declarative HCL (HashiCorp Configuration Language) syntax and powerful state management make it ideal for complex production deployments:</p> <pre><code># infrastructure/ecs.tf\n# Terraform - production-grade with state management\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~&gt; 5.0\"\n    }\n  }\n\n  backend \"s3\" {\n    bucket = \"terraform-state-bucket\"\n    key    = \"clean-py/ecs/terraform.tfstate\"\n    region = \"us-west-2\"\n  }\n}\n\nresource \"aws_ecs_cluster\" \"main\" {\n  name = \"${var.environment}-clean-py-cluster\"\n\n  setting {\n    name  = \"containerInsights\"\n    value = \"enabled\"\n  }\n}\n\nresource \"aws_ecs_task_definition\" \"app\" {\n  family                   = \"${var.environment}-clean-py\"\n  network_mode            = \"awsvpc\"\n  requires_compatibilities = [\"FARGATE\"]\n  cpu                     = var.task_cpu\n  memory                  = var.task_memory\n\n  container_definitions = jsonencode([\n    {\n      name  = \"clean-py\"\n      image = \"${var.ecr_repository_url}:${var.image_tag}\"\n\n      portMappings = [\n        {\n          containerPort = 8000\n          protocol      = \"tcp\"\n        }\n      ]\n\n      environment = [\n        {\n          name  = \"ENVIRONMENT\"\n          value = var.environment\n        }\n      ]\n\n      secrets = [\n        {\n          name      = \"DATABASE_URL\"\n          valueFrom = aws_secretsmanager_secret.database_url.arn\n        }\n      ]\n\n      logConfiguration = {\n        logDriver = \"awslogs\"\n        options = {\n          awslogs-group         = aws_cloudwatch_log_group.ecs.name\n          awslogs-region        = var.aws_region\n          awslogs-stream-prefix = \"ecs\"\n        }\n      }\n    }\n  ])\n}\n\n# Terraform advantages:\n# - Detailed plan before apply\n# - State management and locking\n# - Import existing resources\n# - Multi-cloud support\n</code></pre>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#choosing-your-iac-tool","title":"Choosing Your IaC Tool","text":"Tool Best For Advantages Considerations CloudFormation Prototyping, experiments \u2022 Native AWS\u2022 Easy cleanup\u2022 No additional tools\u2022 Stack rollback \u2022 Verbose syntax\u2022 Limited programming constructs\u2022 AWS-only CDK Production AWS apps \u2022 Use Python/TypeScript\u2022 Type safety\u2022 High-level constructs\u2022 Generates CloudFormation \u2022 AWS-only\u2022 Requires CDK toolkit\u2022 Learning curve Terraform Multi-cloud production \u2022 Cloud agnostic\u2022 Mature ecosystem\u2022 State management\u2022 Resource import \u2022 Separate language (HCL)\u2022 State file management\u2022 Provider versioning <p>For the clean-py project, I recommend: 1. Start with CloudFormation for initial prototyping\u2014it's simple and cleanup is trivial 2. Move to CDK for production AWS deployments\u2014use Python to define Python infrastructure 3. Consider Terraform if you need multi-cloud support or have existing Terraform expertise</p> <p>The key insight: don't overthink the IaC choice initially. Start with CloudFormation to validate your architecture, then migrate to CDK or Terraform once you understand your requirements. The clean-py patterns work with all three approaches. <pre><code>### ECS Deployment Pipeline\n\n```yaml\n# .github/workflows/ecs-deploy.yml\nname: Deploy to ECS Fargate\n\non:\n  push:\n    branches: [main]\n    paths: ['src/**']\n\nenv:\n  AWS_REGION: us-west-2\n  ECR_REPOSITORY: clean-py\n  ECS_SERVICE: order-service\n  ECS_CLUSTER: clean-py-cluster\n  CONTAINER_NAME: order-service\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v3\n\n    - name: Configure AWS credentials\n      uses: aws-actions/configure-aws-credentials@v2\n      with:\n        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        aws-region: ${{ env.AWS_REGION }}\n\n    - name: Login to Amazon ECR\n      id: login-ecr\n      uses: aws-actions/amazon-ecr-login@v1\n\n    - name: Build, tag, and push image to Amazon ECR\n      id: build-image\n      env:\n        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}\n        IMAGE_TAG: ${{ github.sha }}\n      run: |\n        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .\n        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\n        echo \"image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\" &gt;&gt; $GITHUB_OUTPUT\n\n    - name: Download task definition\n      run: |\n        aws ecs describe-task-definition \\\n          --task-definition clean-py-order-service \\\n          --query taskDefinition &gt; task-definition.json\n\n    - name: Fill in the new image ID in the Amazon ECS task definition\n      id: task-def\n      uses: aws-actions/amazon-ecs-render-task-definition@v1\n      with:\n        task-definition: task-definition.json\n        container-name: ${{ env.CONTAINER_NAME }}\n        image: ${{ steps.build-image.outputs.image }}\n\n    - name: Deploy Amazon ECS task definition\n      uses: aws-actions/amazon-ecs-deploy-task-definition@v1\n      with:\n        task-definition: ${{ steps.task-def.outputs.task-definition }}\n        service: ${{ env.ECS_SERVICE }}\n        cluster: ${{ env.ECS_CLUSTER }}\n        wait-for-service-stability: true\n</code></pre></p>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#aws-lambda-serverless-event-driven-architecture","title":"AWS Lambda: Serverless Event-Driven Architecture","text":"<p>Lambda deployment patterns work best for event-driven services with irregular traffic patterns. The clean-py repository includes Lambda-optimized configurations for specific use cases.</p>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#lambda-architecture-pattern","title":"Lambda Architecture Pattern","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   API Gateway   \u2502    \u2502  Lambda Function\u2502    \u2502   Event Sources \u2502\n\u2502                 \u2502\u2500\u2500\u2500\u25b6\u2502                 \u2502\u25c0\u2500\u2500\u2500\u2502                 \u2502\n\u2502 \u2022 REST API      \u2502    \u2502 \u2022 Clean Arch    \u2502    \u2502 \u2022 SQS queues    \u2502\n\u2502 \u2022 Authentication\u2502    \u2502 \u2022 Fast startup  \u2502    \u2502 \u2022 DynamoDB      \u2502\n\u2502 \u2022 Rate limiting \u2502    \u2502 \u2022 Auto scaling  \u2502    \u2502 \u2022 S3 events     \u2502\n\u2502 \u2022 Request/Response\u2502  \u2502 \u2022 Pay per use   \u2502    \u2502 \u2022 EventBridge   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                \u2502                       \u2502\n                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                       \u2502   CloudWatch    \u2502    \u2502   Parameter     \u2502\n                       \u2502                 \u2502    \u2502   Store         \u2502\n                       \u2502 \u2022 Metrics       \u2502    \u2502                 \u2502\n                       \u2502 \u2022 Logs          \u2502    \u2502 \u2022 Configuration \u2502\n                       \u2502 \u2022 X-Ray traces  \u2502    \u2502 \u2022 Secrets       \u2502\n                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502 \u2022 Environment   \u2502\n                                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#lambda-optimized-application-structure","title":"Lambda-Optimized Application Structure","text":"<pre><code># src/presentation/lambda_handlers/order_handler.py\nimport json\nimport asyncio\nfrom typing import Dict, Any\nfrom aws_lambda_powertools import Logger, Tracer, Metrics\nfrom aws_lambda_powertools.logging import correlation_paths\nfrom aws_lambda_powertools.metrics import MetricUnit\n\nfrom ...infrastructure.logging.lambda_utils import configure_lambda_logging\nfrom ...infrastructure.dependencies import get_container\nfrom ...application.use_cases.orders.create_order import CreateOrderUseCase\nfrom ...domain.exceptions import DomainException\n\n# Configure observability\nlogger = Logger()\ntracer = Tracer()\nmetrics = Metrics()\n\n# Configure logging for Lambda\nconfigure_lambda_logging()\n\n# Initialize dependency container (cached across invocations)\ncontainer = get_container()\n\n@tracer.capture_lambda_handler\n@logger.inject_lambda_context(correlation_id_path=correlation_paths.API_GATEWAY_REST)\n@metrics.log_metrics\ndef lambda_handler(event: Dict[str, Any], context) -&gt; Dict[str, Any]:\n    \"\"\"\n    Lambda handler for order creation\n    Optimized for API Gateway REST API events\n    \"\"\"\n\n    try:\n        # Parse request\n        body = json.loads(event.get('body', '{}'))\n        headers = event.get('headers', {})\n        path_parameters = event.get('pathParameters') or {}\n        query_parameters = event.get('queryStringParameters') or {}\n\n        # Extract user context from JWT (set by API Gateway authorizer)\n        request_context = event.get('requestContext', {})\n        authorizer = request_context.get('authorizer', {})\n        user_id = authorizer.get('user_id')\n\n        if not user_id:\n            return create_error_response(401, \"Authentication required\")\n\n        # Route based on HTTP method and path\n        http_method = event['httpMethod']\n        resource = event['resource']\n\n        if http_method == 'POST' and resource == '/orders':\n            return asyncio.run(handle_create_order(body, user_id, context))\n        elif http_method == 'GET' and resource == '/orders/{order_id}':\n            order_id = path_parameters.get('order_id')\n            return asyncio.run(handle_get_order(order_id, user_id, context))\n        else:\n            return create_error_response(404, \"Not found\")\n\n    except json.JSONDecodeError:\n        logger.error(\"Invalid JSON in request body\")\n        return create_error_response(400, \"Invalid JSON\")\n    except Exception as e:\n        logger.exception(\"Unexpected error in Lambda handler\")\n        metrics.add_metadata(key=\"error\", value=str(e))\n        return create_error_response(500, \"Internal server error\")\n\n@tracer.capture_method\nasync def handle_create_order(\n    order_data: Dict[str, Any], \n    user_id: str, \n    context\n) -&gt; Dict[str, Any]:\n    \"\"\"Handle order creation request\"\"\"\n\n    try:\n        # Get use case from container\n        create_order_use_case = container.get(CreateOrderUseCase)\n\n        # Execute use case\n        with tracer.provider.get_tracer(__name__).start_as_current_span(\"create_order_use_case\"):\n            order = await create_order_use_case.execute(\n                user_id=user_id,\n                order_data=order_data,\n                requesting_user_id=user_id  # Simplified for Lambda\n            )\n\n        # Record metrics\n        metrics.add_metric(name=\"OrderCreated\", unit=MetricUnit.Count, value=1)\n        metrics.add_metadata(key=\"order_id\", value=str(order.id))\n\n        # Return success response\n        return {\n            'statusCode': 201,\n            'headers': {\n                'Content-Type': 'application/json',\n                'Access-Control-Allow-Origin': '*'\n            },\n            'body': json.dumps({\n                'id': str(order.id),\n                'status': order.status.value,\n                'total_amount': float(order.total_amount.amount),\n                'currency': order.total_amount.currency,\n                'created_at': order.created_at.isoformat()\n            }, default=str)\n        }\n\n    except DomainException as e:\n        logger.warning(f\"Domain exception: {str(e)}\")\n        metrics.add_metric(name=\"OrderCreationFailed\", unit=MetricUnit.Count, value=1)\n        return create_error_response(400, str(e))\n\ndef create_error_response(status_code: int, message: str) -&gt; Dict[str, Any]:\n    \"\"\"Create standardized error response\"\"\"\n    return {\n        'statusCode': status_code,\n        'headers': {\n            'Content-Type': 'application/json',\n            'Access-Control-Allow-Origin': '*'\n        },\n        'body': json.dumps({\n            'error': {\n                'message': message,\n                'timestamp': datetime.utcnow().isoformat()\n            }\n        })\n    }\n</code></pre>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#lambda-deployment-configuration","title":"Lambda Deployment Configuration","text":"<pre><code># infrastructure/lambda_stack.py\nfrom aws_cdk import (\n    Stack,\n    aws_lambda as lambda_,\n    aws_apigateway as apigateway,\n    aws_iam as iam,\n    aws_logs as logs,\n    Duration\n)\n\nclass CleanPyLambdaStack(Stack):\n    def __init__(self, scope, construct_id, **kwargs):\n        super().__init__(scope, construct_id, **kwargs)\n\n        # Lambda Layer for dependencies\n        dependencies_layer = lambda_.LayerVersion(\n            self, \"DependenciesLayer\",\n            code=lambda_.Code.from_asset(\"lambda-layer.zip\"),\n            compatible_runtimes=[lambda_.Runtime.PYTHON_3_11],\n            description=\"Python dependencies for Clean Architecture services\"\n        )\n\n        # Order Service Lambda Function\n        order_function = lambda_.Function(\n            self, \"OrderFunction\",\n            runtime=lambda_.Runtime.PYTHON_3_11,\n            handler=\"src.presentation.lambda_handlers.order_handler.lambda_handler\",\n            code=lambda_.Code.from_asset(\"src\"),\n            layers=[dependencies_layer],\n            timeout=Duration.seconds(30),\n            memory_size=512,\n            environment={\n                \"ENVIRONMENT\": \"production\",\n                \"AWS_REGION\": self.region,\n                \"POWERTOOLS_SERVICE_NAME\": \"order-service\",\n                \"LOG_LEVEL\": \"INFO\"\n            },\n            tracing=lambda_.Tracing.ACTIVE,\n            retry_attempts=0  # Disable retries for API Gateway\n        )\n\n        # Grant permissions for AWS services\n        order_function.add_to_role_policy(\n            iam.PolicyStatement(\n                effect=iam.Effect.ALLOW,\n                actions=[\n                    \"secretsmanager:GetSecretValue\",\n                    \"ssm:GetParameter\",\n                    \"ssm:GetParameters\"\n                ],\n                resources=[\"*\"]  # Restrict in production\n            )\n        )\n\n        # API Gateway\n        api = apigateway.RestApi(\n            self, \"OrderAPI\",\n            rest_api_name=\"Clean Architecture Order Service\",\n            description=\"Order management API using Clean Architecture\",\n            binary_media_types=[\"application/octet-stream\"],\n            default_cors_preflight_options=apigateway.CorsOptions(\n                allow_origins=apigateway.Cors.ALL_ORIGINS,\n                allow_methods=apigateway.Cors.ALL_METHODS,\n                allow_headers=[\"Content-Type\", \"Authorization\"]\n            )\n        )\n\n        # Lambda Integration\n        lambda_integration = apigateway.LambdaIntegration(\n            order_function,\n            request_templates={\n                \"application/json\": '{ \"statusCode\": \"200\" }'\n            }\n        )\n\n        # API Resources and Methods\n        orders_resource = api.root.add_resource(\"orders\")\n        orders_resource.add_method(\"POST\", lambda_integration)\n        orders_resource.add_method(\"GET\", lambda_integration)\n\n        order_detail_resource = orders_resource.add_resource(\"{order_id}\")\n        order_detail_resource.add_method(\"GET\", lambda_integration)\n        order_detail_resource.add_method(\"PUT\", lambda_integration)\n\n        # CloudWatch Log Groups\n        lambda_.Function(\n            self, \"OrderFunctionLogGroup\",\n            log_retention=logs.RetentionDays.ONE_WEEK\n        )\n</code></pre>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#lambda-cold-start-optimization","title":"Lambda Cold Start Optimization","text":"<pre><code># src/infrastructure/lambda_optimization.py\nimport asyncio\nimport functools\nfrom typing import Any, Callable\n\n# Global connection pool (reused across invocations)\n_connection_pool = None\n_event_loop = None\n\ndef lambda_handler_wrapper(handler: Callable) -&gt; Callable:\n    \"\"\"\n    Wrapper to optimize Lambda cold starts and connection reuse\n    \"\"\"\n    @functools.wraps(handler)\n    def wrapper(event: dict, context) -&gt; Any:\n        global _connection_pool, _event_loop\n\n        # Initialize event loop if not exists\n        if _event_loop is None:\n            _event_loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(_event_loop)\n\n        # Initialize connection pool on first invocation\n        if _connection_pool is None:\n            _connection_pool = initialize_connection_pool()\n\n        # Set connection pool in context for reuse\n        context.connection_pool = _connection_pool\n\n        return handler(event, context)\n\n    return wrapper\n\ndef initialize_connection_pool():\n    \"\"\"Initialize database connection pool optimized for Lambda\"\"\"\n    from sqlalchemy.pool import NullPool\n    from sqlalchemy import create_engine\n\n    # Use NullPool for Lambda (connections don't persist between invocations)\n    engine = create_engine(\n        DATABASE_URL,\n        poolclass=NullPool,\n        connect_args={\n            \"connect_timeout\": 5,\n            \"command_timeout\": 20\n        }\n    )\n    return engine\n\n# Lambda-specific dependency injection\nclass LambdaDependencyContainer:\n    def __init__(self):\n        self._instances = {}\n        self._initialized = False\n\n    def get(self, service_type):\n        if not self._initialized:\n            self._initialize()\n\n        if service_type not in self._instances:\n            self._instances[service_type] = self._create_instance(service_type)\n\n        return self._instances[service_type]\n\n    def _initialize(self):\n        \"\"\"Initialize heavyweight components once per container lifetime\"\"\"\n        # Database connections, external service clients, etc.\n        self._initialized = True\n\n    def _create_instance(self, service_type):\n        \"\"\"Factory method for service creation\"\"\"\n        # Implementation depends on your DI framework\n        pass\n\n# Global container instance (reused across Lambda invocations)\ncontainer = LambdaDependencyContainer()\n</code></pre>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#deployment-pattern-comparison","title":"Deployment Pattern Comparison","text":"","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#performance-characteristics","title":"Performance Characteristics","text":"Metric ECS Fargate AWS Lambda Cold Start ~30-60 seconds ~1-3 seconds Warm Performance Consistent Consistent Memory Usage 512MB - 30GB 128MB - 10GB Request Timeout Unlimited 15 minutes Concurrent Requests Instance-based 1000 concurrent State Management Persistent Stateless","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#cost-analysis","title":"Cost Analysis","text":"<pre><code># cost_calculator.py - Compare deployment costs\nfrom typing import Dict, Any\nfrom dataclasses import dataclass\n\n@dataclass\nclass TrafficPattern:\n    requests_per_second_avg: float\n    requests_per_second_peak: float\n    average_response_time_ms: int\n    daily_peak_hours: int\n\ndef calculate_fargate_cost(\n    traffic: TrafficPattern,\n    cpu_units: int = 512,  # 0.5 vCPU\n    memory_mb: int = 1024,  # 1 GB\n    region: str = \"us-west-2\"\n) -&gt; Dict[str, float]:\n    \"\"\"Calculate monthly ECS Fargate costs\"\"\"\n\n    # AWS Fargate pricing (as of 2024)\n    cpu_price_per_hour = 0.04048  # per vCPU\n    memory_price_per_hour = 0.004445  # per GB\n\n    # Calculate required tasks based on traffic\n    requests_per_task_per_second = 50  # Assume 50 RPS per task\n\n    avg_tasks = max(1, traffic.requests_per_second_avg / requests_per_task_per_second)\n    peak_tasks = max(1, traffic.requests_per_second_peak / requests_per_task_per_second)\n\n    # Task requirements\n    vcpu = cpu_units / 1024\n    memory_gb = memory_mb / 1024\n\n    # Cost calculation\n    cost_per_task_per_hour = (vcpu * cpu_price_per_hour) + (memory_gb * memory_price_per_hour)\n\n    # Average cost (assuming auto-scaling between avg and peak)\n    avg_cost_per_hour = avg_tasks * cost_per_task_per_hour\n    peak_cost_per_hour = peak_tasks * cost_per_task_per_hour\n\n    # Weighted average (peak hours vs normal hours)\n    weighted_hourly_cost = (\n        (avg_cost_per_hour * (24 - traffic.daily_peak_hours)) +\n        (peak_cost_per_hour * traffic.daily_peak_hours)\n    ) / 24\n\n    monthly_cost = weighted_hourly_cost * 24 * 30\n\n    return {\n        \"monthly_cost\": monthly_cost,\n        \"avg_tasks\": avg_tasks,\n        \"peak_tasks\": peak_tasks,\n        \"cost_breakdown\": {\n            \"cpu\": vcpu * cpu_price_per_hour * avg_tasks * 24 * 30,\n            \"memory\": memory_gb * memory_price_per_hour * avg_tasks * 24 * 30\n        }\n    }\n\ndef calculate_lambda_cost(\n    traffic: TrafficPattern,\n    memory_mb: int = 512,\n    region: str = \"us-west-2\"\n) -&gt; Dict[str, float]:\n    \"\"\"Calculate monthly AWS Lambda costs\"\"\"\n\n    # Lambda pricing (as of 2024)\n    request_price = 0.0000002  # per request\n    gb_second_price = 0.0000166667  # per GB-second\n\n    # Calculate monthly requests\n    daily_requests = (\n        traffic.requests_per_second_avg * (24 - traffic.daily_peak_hours) * 3600 +\n        traffic.requests_per_second_peak * traffic.daily_peak_hours * 3600\n    )\n    monthly_requests = daily_requests * 30\n\n    # Duration and memory\n    duration_seconds = traffic.average_response_time_ms / 1000\n    memory_gb = memory_mb / 1024\n\n    # Cost calculation\n    request_cost = monthly_requests * request_price\n    compute_cost = monthly_requests * duration_seconds * memory_gb * gb_second_price\n\n    total_cost = request_cost + compute_cost\n\n    return {\n        \"monthly_cost\": total_cost,\n        \"monthly_requests\": monthly_requests,\n        \"cost_breakdown\": {\n            \"requests\": request_cost,\n            \"compute\": compute_cost\n        }\n    }\n\n# Example usage\nif __name__ == \"__main__\":\n    # E-commerce order service traffic pattern\n    traffic = TrafficPattern(\n        requests_per_second_avg=10,\n        requests_per_second_peak=100,\n        average_response_time_ms=200,\n        daily_peak_hours=8\n    )\n\n    fargate_cost = calculate_fargate_cost(traffic)\n    lambda_cost = calculate_lambda_cost(traffic)\n\n    print(\"Cost Comparison:\")\n    print(f\"Fargate: ${fargate_cost['monthly_cost']:.2f}/month\")\n    print(f\"Lambda:  ${lambda_cost['monthly_cost']:.2f}/month\")\n    print(f\"Savings: ${abs(fargate_cost['monthly_cost'] - lambda_cost['monthly_cost']):.2f}/month\")\n</code></pre>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#operational-complexity","title":"Operational Complexity","text":"Aspect ECS Fargate AWS Lambda Deployment Docker + Task Def ZIP/Container Scaling Auto Scaling Groups Automatic Monitoring CloudWatch + Custom CloudWatch + X-Ray Debugging SSH/Exec into containers CloudWatch Logs Local Development Docker Compose SAM CLI CI/CD Complexity Medium Low","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#hybrid-deployment-strategy","title":"Hybrid Deployment Strategy","text":"<p>The most effective approach often combines both patterns:</p> <pre><code># Service routing based on characteristics\nclass ServiceDeploymentStrategy:\n    def __init__(self):\n        self.fargate_services = [\n            \"order-processing\",      # Long-running, stateful\n            \"inventory-management\",  # Consistent traffic\n            \"user-management\",       # Database-heavy\n            \"payment-processing\"     # PCI compliance requirements\n        ]\n\n        self.lambda_services = [\n            \"notification-service\",  # Event-driven\n            \"report-generation\",     # Sporadic, compute-intensive\n            \"image-processing\",      # Burst workloads\n            \"audit-logging\",         # Event-driven\n            \"webhook-handlers\"       # Irregular traffic\n        ]\n\n    def determine_deployment(self, service_name: str, characteristics: Dict) -&gt; str:\n        \"\"\"Determine optimal deployment pattern based on service characteristics\"\"\"\n\n        # Rule-based decision making\n        if characteristics.get(\"requires_persistent_connections\"):\n            return \"fargate\"\n\n        if characteristics.get(\"traffic_pattern\") == \"irregular\":\n            return \"lambda\"\n\n        if characteristics.get(\"execution_time_minutes\", 0) &gt; 10:\n            return \"fargate\"\n\n        if characteristics.get(\"memory_requirements_gb\", 1) &gt; 3:\n            return \"fargate\"\n\n        if characteristics.get(\"concurrent_connections\") &gt; 1000:\n            return \"fargate\"\n\n        # Default to Lambda for event-driven workloads\n        return \"lambda\"\n</code></pre>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#monitoring-and-observability","title":"Monitoring and Observability","text":"","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#ecs-fargate-monitoring","title":"ECS Fargate Monitoring","text":"<pre><code># monitoring/fargate_monitoring.py\nfrom aws_cdk import (\n    aws_cloudwatch as cloudwatch,\n    aws_cloudwatch_actions as cw_actions,\n    aws_sns as sns\n)\n\ndef create_fargate_alarms(service_name: str, cluster_name: str):\n    \"\"\"Create CloudWatch alarms for ECS Fargate service\"\"\"\n\n    # SNS topic for alerts\n    alert_topic = sns.Topic(f\"{service_name}-alerts\")\n\n    # CPU Utilization\n    cpu_alarm = cloudwatch.Alarm(\n        f\"{service_name}-high-cpu\",\n        alarm_description=f\"High CPU utilization for {service_name}\",\n        metric=cloudwatch.Metric(\n            namespace=\"AWS/ECS\",\n            metric_name=\"CPUUtilization\",\n            dimensions_map={\n                \"ServiceName\": service_name,\n                \"ClusterName\": cluster_name\n            },\n            statistic=\"Average\"\n        ),\n        threshold=80,\n        evaluation_periods=2,\n        datapoints_to_alarm=2\n    )\n    cpu_alarm.add_alarm_action(cw_actions.SnsAction(alert_topic))\n\n    # Memory Utilization\n    memory_alarm = cloudwatch.Alarm(\n        f\"{service_name}-high-memory\",\n        alarm_description=f\"High memory utilization for {service_name}\",\n        metric=cloudwatch.Metric(\n            namespace=\"AWS/ECS\",\n            metric_name=\"MemoryUtilization\",\n            dimensions_map={\n                \"ServiceName\": service_name,\n                \"ClusterName\": cluster_name\n            },\n            statistic=\"Average\"\n        ),\n        threshold=90,\n        evaluation_periods=2\n    )\n    memory_alarm.add_alarm_action(cw_actions.SnsAction(alert_topic))\n\n    # Service health\n    running_count_alarm = cloudwatch.Alarm(\n        f\"{service_name}-low-running-count\",\n        alarm_description=f\"Low running task count for {service_name}\",\n        metric=cloudwatch.Metric(\n            namespace=\"AWS/ECS\",\n            metric_name=\"RunningCount\",\n            dimensions_map={\n                \"ServiceName\": service_name,\n                \"ClusterName\": cluster_name\n            },\n            statistic=\"Average\"\n        ),\n        threshold=1,\n        comparison_operator=cloudwatch.ComparisonOperator.LESS_THAN_THRESHOLD,\n        evaluation_periods=1\n    )\n    running_count_alarm.add_alarm_action(cw_actions.SnsAction(alert_topic))\n</code></pre>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#lambda-monitoring","title":"Lambda Monitoring","text":"<pre><code># monitoring/lambda_monitoring.py\ndef create_lambda_alarms(function_name: str):\n    \"\"\"Create CloudWatch alarms for Lambda function\"\"\"\n\n    alert_topic = sns.Topic(f\"{function_name}-alerts\")\n\n    # Error Rate\n    error_rate_alarm = cloudwatch.Alarm(\n        f\"{function_name}-high-error-rate\",\n        alarm_description=f\"High error rate for {function_name}\",\n        metric=cloudwatch.Metric(\n            namespace=\"AWS/Lambda\",\n            metric_name=\"ErrorRate\",\n            dimensions_map={\"FunctionName\": function_name},\n            statistic=\"Average\"\n        ),\n        threshold=5,  # 5% error rate\n        evaluation_periods=2\n    )\n    error_rate_alarm.add_alarm_action(cw_actions.SnsAction(alert_topic))\n\n    # Duration\n    duration_alarm = cloudwatch.Alarm(\n        f\"{function_name}-high-duration\",\n        alarm_description=f\"High duration for {function_name}\",\n        metric=cloudwatch.Metric(\n            namespace=\"AWS/Lambda\",\n            metric_name=\"Duration\",\n            dimensions_map={\"FunctionName\": function_name},\n            statistic=\"Average\"\n        ),\n        threshold=25000,  # 25 seconds\n        evaluation_periods=3\n    )\n    duration_alarm.add_alarm_action(cw_actions.SnsAction(alert_topic))\n\n    # Throttles\n    throttle_alarm = cloudwatch.Alarm(\n        f\"{function_name}-throttles\",\n        alarm_description=f\"Function throttling detected for {function_name}\",\n        metric=cloudwatch.Metric(\n            namespace=\"AWS/Lambda\",\n            metric_name=\"Throttles\",\n            dimensions_map={\"FunctionName\": function_name},\n            statistic=\"Sum\"\n        ),\n        threshold=1,\n        evaluation_periods=1\n    )\n    throttle_alarm.add_alarm_action(cw_actions.SnsAction(alert_topic))\n</code></pre>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#decision-framework-and-best-practices","title":"Decision Framework and Best Practices","text":"","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#when-to-choose-ecs-fargate","title":"When to Choose ECS Fargate","text":"<p>\u2705 Choose Fargate when: - Long-running services with consistent traffic - Applications requiring persistent connections - Complex application state or caching needs - Traditional microservices architectures - Need for SSH/exec access for debugging - Compliance requirements for container isolation - Applications with predictable resource requirements</p>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#when-to-choose-lambda","title":"When to Choose Lambda","text":"<p>\u2705 Choose Lambda when: - Event-driven processing - Irregular or unpredictable traffic patterns - Short-running tasks (&lt; 15 minutes) - Cost optimization is critical - Automatic scaling is essential - Stateless operations - Integration with AWS event sources</p>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#migration-strategy","title":"Migration Strategy","text":"<pre><code># migration/service_analyzer.py\nclass ServiceMigrationAnalyzer:\n    def analyze_service(self, service_metrics: Dict) -&gt; str:\n        \"\"\"Analyze service for migration recommendation\"\"\"\n\n        score_fargate = 0\n        score_lambda = 0\n\n        # Traffic pattern analysis\n        if service_metrics.get(\"traffic_coefficient_variation\", 1.0) &gt; 2.0:\n            score_lambda += 3  # High variability favors Lambda\n        else:\n            score_fargate += 2  # Steady traffic favors Fargate\n\n        # Execution time\n        avg_execution_time = service_metrics.get(\"avg_execution_time_ms\", 1000)\n        if avg_execution_time &lt; 30000:  # &lt; 30 seconds\n            score_lambda += 2\n        elif avg_execution_time &gt; 300000:  # &gt; 5 minutes\n            score_fargate += 3\n\n        # Memory requirements\n        memory_usage = service_metrics.get(\"avg_memory_mb\", 512)\n        if memory_usage &lt; 1024:  # &lt; 1GB\n            score_lambda += 1\n        elif memory_usage &gt; 3008:  # &gt; 3GB (Lambda limit)\n            score_fargate += 3\n\n        # State requirements\n        if service_metrics.get(\"requires_persistent_state\", False):\n            score_fargate += 3\n        else:\n            score_lambda += 1\n\n        # Cost sensitivity\n        if service_metrics.get(\"cost_sensitive\", False):\n            requests_per_month = service_metrics.get(\"requests_per_month\", 1000000)\n            if requests_per_month &lt; 10000000:  # &lt; 10M requests\n                score_lambda += 2\n            else:\n                score_fargate += 2\n\n        return \"lambda\" if score_lambda &gt; score_fargate else \"fargate\"\n</code></pre>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#conclusion","title":"Conclusion","text":"<p>The choice between ECS Fargate and Lambda for Python microservices isn't binary\u2014it's about matching each service's characteristics to the optimal deployment pattern. The clean-py repository demonstrates how Clean Architecture enables this flexibility by decoupling business logic from infrastructure concerns.</p> <p>Key takeaways:</p> <ol> <li>Service Characteristics Drive Decisions: Analyze traffic patterns, execution time, state requirements, and cost sensitivity</li> <li>Hybrid Approaches Work Best: Use Fargate for steady-state services, Lambda for event-driven workloads</li> <li>Architecture Enables Choice: Clean Architecture makes migration between patterns straightforward</li> <li>Monitor and Optimize: Continuously evaluate service performance and costs to optimize deployment patterns</li> </ol> <p>Start with Lambda for new services unless you have specific requirements for Fargate. The pay-per-use model and automatic scaling often provide better initial economics. As services mature and traffic patterns stabilize, evaluate migration to Fargate if it offers operational or cost advantages.</p> <p>The clean-py patterns provide production-ready templates for both deployment models. Choose based on your specific requirements, not on technology preferences. Your architecture should serve your business needs, not constrain them.</p>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/07/19/aws-deployment-patterns---ecs-fargate-vs-lambda-for-python-services/#references","title":"References","text":"<ul> <li>Clean-Py Repository - Complete deployment examples</li> <li>AWS ECS Documentation - Container orchestration service</li> <li>AWS Lambda Documentation - Serverless compute service</li> <li>AWS CDK Documentation - Infrastructure as code</li> </ul>","tags":["aws","deployment","ecs-fargate","lambda","clean-py"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/","title":"Evolving Your Architecture: Patterns for Growth","text":"<p>Software architecture isn't a one-time design decision\u2014it's a living system that must evolve as your business grows, requirements change, and technology advances. The greatest architectural challenge isn't building the perfect system from day one; it's creating a foundation that can adapt and scale while maintaining code quality, team productivity, and system reliability.</p> <p>The clean-py repository demonstrates evolution-friendly patterns that have guided real-world applications from startup MVPs to enterprise-scale systems processing millions of requests daily. This isn't theoretical advice\u2014it's battle-tested strategies for architectural evolution that preserve your investment while enabling growth.</p>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#the-evolution-imperative","title":"The Evolution Imperative","text":"<p>I've watched too many promising startups hit the \"architectural wall\"\u2014the moment when their initial system design becomes the limiting factor in their growth. The symptoms are always the same:</p> <ul> <li>New features take exponentially longer to implement</li> <li>Simple changes require modifications across multiple systems</li> <li>The development team spends more time fighting the architecture than building features</li> <li>Scaling requires complete rewrites instead of incremental improvements</li> <li>Technical debt compounds faster than business value creation</li> </ul> <p>A recent client experienced this perfectly. Their e-commerce platform started as a Flask monolith serving 100 orders per day. Eighteen months later, they were processing 10,000 orders daily, had grown from 3 to 25 engineers, and needed to support multiple sales channels. Their architecture had become their biggest constraint.</p> <p>The solution wasn't a big bang rewrite\u2014it was systematic evolution using Clean Architecture principles as the foundation for incremental transformation.</p>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#the-clean-py-tool-arsenal-foundation-for-evolution","title":"The Clean-Py Tool Arsenal: Foundation for Evolution","text":"<p>Before diving into evolution principles, let's examine how the clean-py repository uses specific tools to maintain architectural cleanliness and enable smooth evolution. These tools aren't just development conveniences\u2014they're the foundation that makes architectural evolution possible without code rot.</p>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#strategic-tool-selection-in-clean-py","title":"Strategic Tool Selection in Clean-Py","text":"<p>The repository demonstrates a carefully curated tool selection where each tool serves a specific purpose in maintaining architectural integrity:</p> <pre><code># pyproject.toml - The single source of truth\n[tool.ruff]\nselect = [\n    \"E\",   # pycodestyle errors - enforces PEP 8\n    \"F\",   # pyflakes - catches bugs early\n    \"I\",   # isort - maintains import organization\n    \"B\",   # flake8-bugbear - catches common mistakes\n    \"UP\",  # pyupgrade - keeps code modern\n    \"SIM\", # flake8-simplify - promotes cleaner patterns\n    \"TCH\", # flake8-type-checking - ensures proper typing\n]\n\n[tool.mypy]\nstrict = true  # Maximum type safety\nwarn_unused_ignores = true\ndisallow_untyped_defs = true\n\n[tool.black]\nline-length = 88  # Consistent formatting across the project\n\n[tool.pytest.ini_options]\naddopts = \"\"\"\n    --strict-markers\n    --cov=src\n    --cov-branch\n    --cov-report=term-missing\n\"\"\"\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#how-tools-enable-clean-architecture","title":"How Tools Enable Clean Architecture","text":"","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#1-type-safety-with-mypy-and-pydantic","title":"1. Type Safety with Mypy and Pydantic","text":"<p>Clean-py leverages Python's type system to enforce architectural boundaries at the type level:</p> <pre><code># src/domain/repositories/order_repository.py\nfrom abc import ABC, abstractmethod\nfrom typing import Optional, List\nfrom ..entities.order import Order\nfrom ..value_objects.order_id import OrderId\n\nclass OrderRepository(ABC):\n    \"\"\"Repository interface - domain layer defines the contract\"\"\"\n\n    @abstractmethod\n    async def save(self, order: Order) -&gt; Order:\n        \"\"\"Type hints enforce correct entity usage\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_id(self, order_id: OrderId) -&gt; Optional[Order]:\n        \"\"\"Value objects like OrderId prevent primitive obsession\"\"\"\n        pass\n\n# src/infrastructure/repositories/postgres_order_repository.py\nfrom typing import Optional\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom ...domain.repositories.order_repository import OrderRepository\nfrom ...domain.entities.order import Order\nfrom ...domain.value_objects.order_id import OrderId\n\nclass PostgresOrderRepository(OrderRepository):\n    \"\"\"Infrastructure implementation - must satisfy domain interface\"\"\"\n\n    def __init__(self, session: AsyncSession):\n        self.session = session\n\n    async def save(self, order: Order) -&gt; Order:\n        # Mypy ensures this returns Order, not OrderModel\n        order_model = self._to_model(order)\n        self.session.add(order_model)\n        await self.session.commit()\n        return order  # Type safety enforced\n\n    async def get_by_id(self, order_id: OrderId) -&gt; Optional[Order]:\n        # OrderId value object prevents passing raw strings\n        result = await self.session.get(OrderModel, str(order_id))\n        return self._to_entity(result) if result else None\n</code></pre> <p>Mypy catches architectural violations at development time: - Domain depending on infrastructure (import error) - Wrong types crossing boundaries (type error) - Missing interface implementations (abstract method error)</p>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#2-code-organization-with-ruff-and-isort","title":"2. Code Organization with Ruff and isort","text":"<p>Ruff's comprehensive rule set maintains consistent code organization that reflects architectural boundaries:</p> <pre><code># Ruff enforces import organization that reflects architecture\n# src/application/use_cases/create_order.py\n\n# Standard library imports\nfrom datetime import datetime\nfrom typing import Optional\n\n# Third-party imports\nfrom pydantic import BaseModel\n\n# Domain imports (dependencies flow inward)\nfrom src.domain.entities.order import Order\nfrom src.domain.repositories.order_repository import OrderRepository\nfrom src.domain.services.pricing_service import PricingService\n\n# Application layer imports (same level)\nfrom ..commands.create_order_command import CreateOrderCommand\nfrom ..events.order_created_event import OrderCreatedEvent\n\n# \u274c Ruff would flag this - application shouldn't import infrastructure\n# from src.infrastructure.database import get_session  # TCH004 error\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#3-consistent-formatting-with-black","title":"3. Consistent Formatting with Black","text":"<p>Black eliminates formatting debates, ensuring the codebase remains readable as it evolves:</p> <pre><code># Before Black - inconsistent formatting obscures architecture\ndef process_order(order_id,customer_id,items,\n                 shipping_address,billing_address,\n    payment_method):\n    if not items: return None\n    total=sum([item.price*item.quantity for item in items])\n    order=Order(order_id,customer_id,total)\n    return order\n\n# After Black - clean, consistent, architectural intent is clear\ndef process_order(\n    order_id: OrderId,\n    customer_id: CustomerId,\n    items: List[OrderItem],\n    shipping_address: Address,\n    billing_address: Address,\n    payment_method: PaymentMethod,\n) -&gt; Optional[Order]:\n    if not items:\n        return None\n\n    total = sum(item.price * item.quantity for item in items)\n    order = Order(order_id, customer_id, total)\n    return order\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#4-testing-infrastructure-with-pytest","title":"4. Testing Infrastructure with Pytest","text":"<p>Clean-py's test structure mirrors the architecture, making it easy to test each layer independently:</p> <pre><code># tests/unit/domain/test_order.py\nimport pytest\nfrom src.domain.entities.order import Order\nfrom src.domain.value_objects.money import Money\n\nclass TestOrder:\n    \"\"\"Domain tests - no infrastructure dependencies\"\"\"\n\n    def test_order_total_calculation(self):\n        # Pure domain logic testing\n        order = Order.create(customer_id=\"123\")\n        order.add_item(product_id=\"ABC\", quantity=2, price=Money(10.00))\n\n        assert order.total == Money(20.00)\n\n    def test_order_business_rules(self):\n        order = Order.create(customer_id=\"123\")\n\n        with pytest.raises(DomainException):\n            order.confirm()  # Can't confirm empty order\n\n# tests/integration/repositories/test_order_repository.py\nclass TestOrderRepository:\n    \"\"\"Integration tests - test infrastructure with real dependencies\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_save_and_retrieve(self, db_session):\n        repo = PostgresOrderRepository(db_session)\n        order = Order.create(customer_id=\"123\")\n\n        saved = await repo.save(order)\n        retrieved = await repo.get_by_id(saved.id)\n\n        assert retrieved == saved\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#5-dependency-management-with-pip-tools","title":"5. Dependency Management with pip-tools","text":"<p>Clean-py uses pip-tools to maintain reproducible builds while allowing controlled evolution:</p> <pre><code># Makefile commands for dependency management\n.PHONY: deps-compile\ndeps-compile:  ## Compile dependencies\n    pip-compile pyproject.toml -o requirements.txt\n    pip-compile --extra dev pyproject.toml -o requirements-dev.txt\n\n.PHONY: deps-upgrade\ndeps-upgrade:  ## Upgrade dependencies safely\n    pip-compile --upgrade pyproject.toml -o requirements.txt\n    pip-compile --upgrade --extra dev pyproject.toml -o requirements-dev.txt\n    pip-sync requirements-dev.txt\n    $(MAKE) test  # Verify nothing broke\n\n.PHONY: deps-check\ndeps-check:  ## Check for security vulnerabilities\n    safety check\n    pip-audit\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#makefile-the-unifying-interface","title":"Makefile: The Unifying Interface","text":"<p>The Makefile provides a consistent interface that abstracts tool complexity:</p> <pre><code># Key make commands that maintain cleanliness\n\n.PHONY: check\ncheck: format lint type-check test  ## Run all checks\n\n.PHONY: format\nformat:  ## Format code consistently\n    black src tests\n    isort src tests\n    ruff check --fix src tests\n\n.PHONY: lint\nlint:  ## Comprehensive linting\n    ruff check src tests\n    pylint src --fail-under=8.0\n\n.PHONY: type-check\ntype-check:  ## Verify type safety\n    mypy src --strict\n    pyright src\n\n.PHONY: test\ntest:  ## Run tests with coverage\n    pytest tests/unit --cov=src --cov-fail-under=80\n    pytest tests/integration\n\n.PHONY: security\nsecurity:  ## Security scanning\n    bandit -r src -ll\n    safety check\n    pip-audit\n\n.PHONY: complexity\ncomplexity:  ## Monitor code complexity\n    radon cc src --min B --total-average\n    radon mi src --min B\n\n.PHONY: clean-arch-check\nclean-arch-check:  ## Verify Clean Architecture rules\n    python scripts/check_architecture.py\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#architecture-validation-scripts","title":"Architecture Validation Scripts","text":"<p>Clean-py includes custom scripts that enforce architectural rules:</p> <pre><code># scripts/check_architecture.py\nimport ast\nimport os\nfrom pathlib import Path\nfrom typing import List, Set\n\nclass ArchitectureChecker(ast.NodeVisitor):\n    \"\"\"Validates Clean Architecture dependency rules\"\"\"\n\n    def __init__(self):\n        self.violations = []\n        self.current_file = None\n        self.current_layer = None\n\n    def check_project(self, src_path: Path) -&gt; List[str]:\n        \"\"\"Check entire project for architectural violations\"\"\"\n        for py_file in src_path.rglob(\"*.py\"):\n            self.check_file(py_file)\n        return self.violations\n\n    def check_file(self, file_path: Path):\n        \"\"\"Check single file for violations\"\"\"\n        self.current_file = file_path\n        self.current_layer = self._determine_layer(file_path)\n\n        with open(file_path) as f:\n            tree = ast.parse(f.read())\n            self.visit(tree)\n\n    def visit_Import(self, node):\n        \"\"\"Check import statements for violations\"\"\"\n        for alias in node.names:\n            self._check_import(alias.name)\n\n    def visit_ImportFrom(self, node):\n        \"\"\"Check from-import statements for violations\"\"\"\n        if node.module:\n            self._check_import(node.module)\n\n    def _determine_layer(self, file_path: Path) -&gt; str:\n        \"\"\"Determine architectural layer from file path\"\"\"\n        parts = file_path.parts\n        if \"domain\" in parts:\n            return \"domain\"\n        elif \"application\" in parts:\n            return \"application\"\n        elif \"infrastructure\" in parts:\n            return \"infrastructure\"\n        elif \"presentation\" in parts:\n            return \"presentation\"\n        return \"unknown\"\n\n    def _check_import(self, module: str):\n        \"\"\"Check if import violates architectural rules\"\"\"\n        if not module.startswith(\"src\"):\n            return  # External import, allowed\n\n        imported_layer = self._get_layer_from_module(module)\n\n        # Check dependency rules\n        if self.current_layer == \"domain\":\n            if imported_layer in [\"application\", \"infrastructure\", \"presentation\"]:\n                self.violations.append(\n                    f\"{self.current_file}: Domain layer importing from {imported_layer}\"\n                )\n\n        elif self.current_layer == \"application\":\n            if imported_layer in [\"infrastructure\", \"presentation\"]:\n                self.violations.append(\n                    f\"{self.current_file}: Application layer importing from {imported_layer}\"\n                )\n\n        elif self.current_layer == \"infrastructure\":\n            if imported_layer == \"presentation\":\n                self.violations.append(\n                    f\"{self.current_file}: Infrastructure layer importing from presentation\"\n                )\n\n# Run in CI/CD\nif __name__ == \"__main__\":\n    checker = ArchitectureChecker()\n    violations = checker.check_project(Path(\"src\"))\n\n    if violations:\n        print(\"\u274c Architecture violations found:\")\n        for v in violations:\n            print(f\"  - {v}\")\n        exit(1)\n    else:\n        print(\"\u2705 No architecture violations found\")\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#how-these-tools-enable-evolution","title":"How These Tools Enable Evolution","text":"<p>The combination of these tools creates a safety net that makes architectural evolution possible:</p> <ol> <li>Refactoring Confidence: Comprehensive type checking and tests mean you can refactor fearlessly</li> <li>Consistent Codebase: Formatting and linting tools ensure the codebase remains readable as it grows</li> <li>Architectural Integrity: Custom validation scripts prevent architectural drift</li> <li>Quick Feedback: Pre-commit hooks catch issues before they enter the repository</li> <li>Team Alignment: Shared tooling ensures everyone follows the same standards</li> </ol> <pre><code># .pre-commit-config.yaml - Automated quality gates\nrepos:\n  - repo: https://github.com/psf/black\n    rev: 23.11.0\n    hooks:\n      - id: black\n\n  - repo: https://github.com/charliermarsh/ruff-pre-commit\n    rev: v0.1.6\n    hooks:\n      - id: ruff\n        args: [--fix]\n\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.7.1\n    hooks:\n      - id: mypy\n        args: [--strict]\n\n  - repo: local\n    hooks:\n      - id: clean-arch-check\n        name: Clean Architecture Check\n        entry: python scripts/check_architecture.py\n        language: system\n        pass_filenames: false\n\n      - id: complexity-check\n        name: Complexity Check\n        entry: radon cc src --min C --no-assert\n        language: system\n        pass_filenames: false\n</code></pre> <p>This tool infrastructure isn't overhead\u2014it's what makes the clean-py architecture sustainable and evolvable. Each tool serves a specific purpose in maintaining the integrity of the Clean Architecture while enabling the flexibility needed for evolution.</p>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#evolution-principles","title":"Evolution Principles","text":"<p>With this tool foundation in place, successful architectural evolution follows consistent patterns:</p>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#1-preserve-business-logic-investment","title":"1. Preserve Business Logic Investment","text":"<p>Your domain logic\u2014the core business rules that differentiate your product\u2014should remain stable even as infrastructure evolves. Clean Architecture's dependency inversion principle ensures business logic never depends on technical implementation details.</p> <pre><code># Domain layer remains unchanged during evolution\nclass OrderService:\n    def __init__(self, order_repository: OrderRepository):\n        self.order_repository = order_repository\n\n    async def create_order(self, order_data: CreateOrderCommand) -&gt; Order:\n        # Business logic never changes\n        order = Order.create(\n            customer_id=order_data.customer_id,\n            items=order_data.items,\n            shipping_address=order_data.shipping_address\n        )\n\n        # Validate business rules\n        self._validate_order_rules(order)\n\n        # Save through repository interface (implementation can evolve)\n        return await self.order_repository.save(order)\n\n# Infrastructure evolves while business logic remains stable\n# Evolution 1: In-memory repository for testing\nclass InMemoryOrderRepository(OrderRepository):\n    def __init__(self):\n        self._orders = {}\n\n    async def save(self, order: Order) -&gt; Order:\n        self._orders[order.id] = order\n        return order\n\n# Evolution 2: SQL database for production\nclass SQLOrderRepository(OrderRepository):\n    def __init__(self, db_session):\n        self.db_session = db_session\n\n    async def save(self, order: Order) -&gt; Order:\n        # SQL implementation\n        pass\n\n# Evolution 3: Event-sourced repository for audit requirements\nclass EventSourcedOrderRepository(OrderRepository):\n    def __init__(self, event_store):\n        self.event_store = event_store\n\n    async def save(self, order: Order) -&gt; Order:\n        # Event sourcing implementation\n        events = order.get_uncommitted_events()\n        await self.event_store.append_events(order.id, events)\n        return order\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#2-enable-incremental-migration","title":"2. Enable Incremental Migration","text":"<p>Rather than big-bang rewrites, successful evolution happens incrementally. The Strangler Fig pattern allows you to gradually replace system components while maintaining system functionality.</p> <pre><code># Legacy system integration during transition\nclass LegacyOrderService:\n    \"\"\"Legacy order service being gradually replaced\"\"\"\n\n    def create_order(self, order_data: dict) -&gt; dict:\n        # Legacy implementation\n        pass\n\nclass ModernOrderService:\n    \"\"\"New Clean Architecture implementation\"\"\"\n\n    def __init__(self, order_use_case: CreateOrderUseCase):\n        self.order_use_case = order_use_case\n\n    async def create_order(self, order_data: CreateOrderCommand) -&gt; Order:\n        return await self.order_use_case.execute(order_data)\n\nclass OrderServiceRouter:\n    \"\"\"Routes requests between legacy and modern implementations\"\"\"\n\n    def __init__(\n        self, \n        legacy_service: LegacyOrderService,\n        modern_service: ModernOrderService,\n        feature_flags: FeatureFlags\n    ):\n        self.legacy_service = legacy_service\n        self.modern_service = modern_service\n        self.feature_flags = feature_flags\n\n    async def create_order(self, order_data: dict) -&gt; dict:\n        # Gradual migration based on feature flags\n        customer_id = order_data.get('customer_id')\n\n        if await self.feature_flags.is_enabled('modern_order_service', customer_id):\n            # Use modern implementation\n            command = self._convert_to_command(order_data)\n            order = await self.modern_service.create_order(command)\n            return self._convert_to_legacy_format(order)\n        else:\n            # Fall back to legacy implementation\n            return self.legacy_service.create_order(order_data)\n\n    def _convert_to_command(self, order_data: dict) -&gt; CreateOrderCommand:\n        \"\"\"Convert legacy format to modern command\"\"\"\n        return CreateOrderCommand(\n            customer_id=order_data['customer_id'],\n            items=[OrderItem(**item) for item in order_data['items']],\n            shipping_address=Address(**order_data['shipping_address'])\n        )\n\n    def _convert_to_legacy_format(self, order: Order) -&gt; dict:\n        \"\"\"Convert modern order to legacy format\"\"\"\n        return {\n            'order_id': str(order.id),\n            'status': order.status.value,\n            'total': float(order.total_amount.amount)\n        }\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#3-anticipate-scale-requirements","title":"3. Anticipate Scale Requirements","text":"<p>Design interfaces and abstractions that can handle future scale requirements without requiring complete rewrites.</p> <pre><code># Repository interface designed for scale evolution\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional, Protocol\n\nclass ScalableOrderRepository(ABC):\n    \"\"\"Repository interface designed to evolve with scale requirements\"\"\"\n\n    @abstractmethod\n    async def save(self, order: Order) -&gt; Order:\n        \"\"\"Save single order\"\"\"\n        pass\n\n    @abstractmethod\n    async def save_batch(self, orders: List[Order]) -&gt; List[Order]:\n        \"\"\"Batch save for high-throughput scenarios\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_id(self, order_id: str) -&gt; Optional[Order]:\n        \"\"\"Get single order\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_customer_id(\n        self, \n        customer_id: str, \n        limit: int = 50,\n        offset: int = 0\n    ) -&gt; List[Order]:\n        \"\"\"Paginated customer orders\"\"\"\n        pass\n\n    @abstractmethod\n    async def search(self, criteria: OrderSearchCriteria) -&gt; OrderSearchResult:\n        \"\"\"Flexible search interface for complex queries\"\"\"\n        pass\n\n# Evolution from simple to sophisticated implementations\nclass SimpleOrderRepository(ScalableOrderRepository):\n    \"\"\"Initial implementation for low scale\"\"\"\n\n    async def save_batch(self, orders: List[Order]) -&gt; List[Order]:\n        # Simple loop for initial implementation\n        results = []\n        for order in orders:\n            result = await self.save(order)\n            results.append(result)\n        return results\n\nclass HighPerformanceOrderRepository(ScalableOrderRepository):\n    \"\"\"Evolved implementation for high scale\"\"\"\n\n    async def save_batch(self, orders: List[Order]) -&gt; List[Order]:\n        # Optimized batch operations\n        async with self.db.transaction():\n            return await self.db.bulk_insert(orders)\n\n    async def search(self, criteria: OrderSearchCriteria) -&gt; OrderSearchResult:\n        # Sophisticated search with caching and indexing\n        cache_key = criteria.cache_key()\n\n        if cached_result := await self.cache.get(cache_key):\n            return cached_result\n\n        result = await self._execute_search(criteria)\n        await self.cache.set(cache_key, result, ttl=300)\n        return result\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#evolutionary-patterns","title":"Evolutionary Patterns","text":"","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#pattern-1-modular-monolith-to-microservices","title":"Pattern 1: Modular Monolith to Microservices","text":"<p>Start with a well-structured monolith and evolve to microservices based on actual scaling needs, not theoretical benefits.</p> <pre><code># Phase 1: Modular Monolith with Clear Boundaries\nclass ECommerceApplication:\n    \"\"\"Modular monolith with clear service boundaries\"\"\"\n\n    def __init__(self):\n        # Each module is independently deployable logic\n        self.order_service = OrderService()\n        self.inventory_service = InventoryService()\n        self.payment_service = PaymentService()\n        self.notification_service = NotificationService()\n\n    async def process_order(self, order_request: CreateOrderRequest):\n        # Cross-module coordination within single process\n        order = await self.order_service.create_order(order_request)\n        await self.inventory_service.reserve_items(order.items)\n        await self.payment_service.process_payment(order.payment_info)\n        await self.notification_service.send_confirmation(order)\n        return order\n\n# Phase 2: Extract High-Value Services\nclass DistributedOrderProcessor:\n    \"\"\"Hybrid approach: some services extracted, others remain monolithic\"\"\"\n\n    def __init__(\n        self,\n        order_service: OrderService,  # Still in monolith\n        inventory_service: InventoryService,  # Still in monolith\n        payment_service: PaymentServiceClient,  # Extracted microservice\n        notification_service: NotificationServiceClient  # Extracted microservice\n    ):\n        self.order_service = order_service\n        self.inventory_service = inventory_service\n        self.payment_service = payment_service\n        self.notification_service = notification_service\n\n    async def process_order(self, order_request: CreateOrderRequest):\n        # Mixed local and remote calls\n        order = await self.order_service.create_order(order_request)\n        await self.inventory_service.reserve_items(order.items)\n\n        # Remote service calls\n        payment_result = await self.payment_service.process_payment({\n            'amount': order.total_amount,\n            'payment_method': order.payment_method_id\n        })\n\n        await self.notification_service.send_confirmation({\n            'order_id': str(order.id),\n            'customer_email': order.customer_email\n        })\n\n        return order\n\n# Phase 3: Full Microservices with Orchestration\nclass MicroservicesOrderProcessor:\n    \"\"\"Full microservices architecture with proper orchestration\"\"\"\n\n    def __init__(self, saga_orchestrator: SagaOrchestrator):\n        self.saga_orchestrator = saga_orchestrator\n\n    async def process_order(self, order_request: CreateOrderRequest):\n        # Use saga pattern for distributed transaction management\n        saga = OrderProcessingSaga()\n        return await self.saga_orchestrator.execute(saga, order_request)\n\nclass OrderProcessingSaga:\n    \"\"\"Saga pattern for distributed order processing\"\"\"\n\n    def __init__(self):\n        self.steps = [\n            SagaStep('create_order', 'cancel_order'),\n            SagaStep('reserve_inventory', 'release_inventory'),\n            SagaStep('process_payment', 'refund_payment'),\n            SagaStep('send_confirmation', 'send_cancellation')\n        ]\n\n    async def execute(self, context: SagaContext) -&gt; OrderResult:\n        completed_steps = []\n\n        try:\n            for step in self.steps:\n                result = await step.execute(context)\n                completed_steps.append((step, result))\n                context.add_result(step.name, result)\n\n            return OrderResult.success(context.order)\n\n        except Exception as e:\n            # Compensate completed steps in reverse order\n            for step, result in reversed(completed_steps):\n                await step.compensate(context, result)\n\n            return OrderResult.failure(str(e))\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#pattern-2-data-architecture-evolution","title":"Pattern 2: Data Architecture Evolution","text":"<p>Data architecture often needs the most careful evolution, as data migration is risky and expensive.</p> <pre><code># Evolution 1: Single Database with Domain Tables\nclass SingleDatabaseRepository:\n    \"\"\"Traditional approach with domain-specific tables\"\"\"\n\n    def __init__(self, db_session):\n        self.db = db_session\n\n    async def save_order(self, order: Order):\n        # Direct table mapping\n        order_record = OrderRecord(\n            id=order.id,\n            customer_id=order.customer_id,\n            status=order.status.value,\n            total_amount=order.total_amount.amount\n        )\n        await self.db.save(order_record)\n\n        for item in order.items:\n            item_record = OrderItemRecord(\n                order_id=order.id,\n                product_id=item.product_id,\n                quantity=item.quantity,\n                unit_price=item.unit_price.amount\n            )\n            await self.db.save(item_record)\n\n# Evolution 2: Read/Write Separation (CQRS)\nclass CQRSOrderRepository:\n    \"\"\"Separate read and write models for better performance\"\"\"\n\n    def __init__(self, write_db, read_db, event_bus):\n        self.write_db = write_db\n        self.read_db = read_db\n        self.event_bus = event_bus\n\n    async def save_order(self, order: Order):\n        # Write to normalized tables\n        async with self.write_db.transaction():\n            await self._save_order_aggregate(order)\n\n        # Publish event for read model update\n        await self.event_bus.publish(\n            OrderCreatedEvent(order_id=order.id, order_data=order.to_dict())\n        )\n\n    async def get_order_summary(self, order_id: str) -&gt; OrderSummary:\n        # Read from denormalized view\n        return await self.read_db.get_order_summary(order_id)\n\n# Evolution 3: Event Sourcing for Complete Auditability\nclass EventSourcedOrderRepository:\n    \"\"\"Full event sourcing for complex business requirements\"\"\"\n\n    def __init__(self, event_store, snapshot_store):\n        self.event_store = event_store\n        self.snapshot_store = snapshot_store\n\n    async def save_order(self, order: Order):\n        # Save domain events\n        events = order.get_uncommitted_events()\n        await self.event_store.append_events(\n            stream_id=str(order.id),\n            events=events,\n            expected_version=order.version\n        )\n\n        # Update snapshot if needed\n        if len(events) &gt; 10:  # Snapshot every 10 events\n            await self.snapshot_store.save_snapshot(order)\n\n        order.mark_events_as_committed()\n\n    async def get_order(self, order_id: str) -&gt; Optional[Order]:\n        # Try to load from snapshot first\n        snapshot = await self.snapshot_store.get_snapshot(order_id)\n\n        if snapshot:\n            order = snapshot.order\n            from_version = snapshot.version + 1\n        else:\n            order = None\n            from_version = 0\n\n        # Apply events since snapshot\n        events = await self.event_store.get_events(order_id, from_version)\n\n        if not order and events:\n            order = Order.from_events(events)\n        elif order and events:\n            order.apply_events(events)\n\n        return order\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#pattern-3-api-evolution-strategies","title":"Pattern 3: API Evolution Strategies","text":"<p>APIs must evolve without breaking existing clients, requiring careful versioning and backward compatibility strategies.</p> <pre><code># API Versioning Strategy\nfrom enum import Enum\nfrom typing import Union, Any, Dict\nfrom pydantic import BaseModel, Field\n\nclass APIVersion(Enum):\n    V1 = \"1.0\"\n    V2 = \"2.0\"\n    V3 = \"3.0\"\n\n# Version 1: Original API\nclass OrderResponseV1(BaseModel):\n    id: str\n    status: str\n    total: float\n    items: List[Dict[str, Any]]\n\n# Version 2: Enhanced with additional fields (backward compatible)\nclass OrderResponseV2(BaseModel):\n    id: str\n    status: str\n    total: float\n    currency: str = Field(default=\"USD\")  # New field with default\n    items: List[Dict[str, Any]]\n    shipping_address: Optional[Dict[str, Any]] = None  # New optional field\n\n    @classmethod\n    def from_v1(cls, v1_response: OrderResponseV1) -&gt; 'OrderResponseV2':\n        \"\"\"Convert V1 response to V2 format\"\"\"\n        return cls(\n            id=v1_response.id,\n            status=v1_response.status,\n            total=v1_response.total,\n            currency=\"USD\",  # Default for legacy data\n            items=v1_response.items\n        )\n\n# Version 3: Breaking changes with new structure\nclass OrderResponseV3(BaseModel):\n    order_id: str  # Renamed field\n    order_status: OrderStatus  # Changed to enum\n    pricing: OrderPricing  # Nested object\n    line_items: List[OrderLineItem]  # Structured items\n\n    @classmethod\n    def from_v2(cls, v2_response: OrderResponseV2) -&gt; 'OrderResponseV3':\n        \"\"\"Convert V2 response to V3 format\"\"\"\n        return cls(\n            order_id=v2_response.id,\n            order_status=OrderStatus(v2_response.status),\n            pricing=OrderPricing(\n                total=v2_response.total,\n                currency=v2_response.currency\n            ),\n            line_items=[\n                OrderLineItem(**item) for item in v2_response.items\n            ]\n        )\n\nclass VersionedOrderController:\n    \"\"\"Controller that supports multiple API versions\"\"\"\n\n    def __init__(self, order_service: OrderService):\n        self.order_service = order_service\n\n    @router.get(\"/orders/{order_id}\")\n    async def get_order(\n        self,\n        order_id: str,\n        version: APIVersion = APIVersion.V3,\n        accept_version: Optional[str] = Header(None)\n    ) -&gt; Union[OrderResponseV1, OrderResponseV2, OrderResponseV3]:\n\n        # Determine version from header or parameter\n        requested_version = self._determine_version(version, accept_version)\n\n        # Get order from service (version-agnostic)\n        order = await self.order_service.get_order(order_id)\n        if not order:\n            raise HTTPException(status_code=404, detail=\"Order not found\")\n\n        # Convert to appropriate response format\n        return self._format_response(order, requested_version)\n\n    def _determine_version(\n        self, \n        version_param: APIVersion, \n        accept_header: Optional[str]\n    ) -&gt; APIVersion:\n        \"\"\"Determine API version from various sources\"\"\"\n\n        if accept_header:\n            # Parse from Accept header: application/json; version=2.0\n            if \"version=1.0\" in accept_header:\n                return APIVersion.V1\n            elif \"version=2.0\" in accept_header:\n                return APIVersion.V2\n            elif \"version=3.0\" in accept_header:\n                return APIVersion.V3\n\n        return version_param\n\n    def _format_response(\n        self, \n        order: Order, \n        version: APIVersion\n    ) -&gt; Union[OrderResponseV1, OrderResponseV2, OrderResponseV3]:\n        \"\"\"Format order response for requested API version\"\"\"\n\n        if version == APIVersion.V1:\n            return OrderResponseV1(\n                id=str(order.id),\n                status=order.status.value,\n                total=float(order.total_amount.amount),\n                items=[item.to_dict() for item in order.items]\n            )\n\n        elif version == APIVersion.V2:\n            return OrderResponseV2(\n                id=str(order.id),\n                status=order.status.value,\n                total=float(order.total_amount.amount),\n                currency=order.total_amount.currency,\n                items=[item.to_dict() for item in order.items],\n                shipping_address=order.shipping_address.to_dict() if order.shipping_address else None\n            )\n\n        else:  # V3\n            return OrderResponseV3(\n                order_id=str(order.id),\n                order_status=order.status,\n                pricing=OrderPricing(\n                    total=order.total_amount.amount,\n                    currency=order.total_amount.currency\n                ),\n                line_items=[\n                    OrderLineItem.from_domain(item) for item in order.items\n                ]\n            )\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#pattern-4-infrastructure-evolution","title":"Pattern 4: Infrastructure Evolution","text":"<p>Infrastructure should evolve to meet changing operational requirements without disrupting business logic.</p> <pre><code># Evolution from simple to sophisticated infrastructure\nclass InfrastructureEvolution:\n\n    # Phase 1: Simple Deployment\n    class SimpleDeployment:\n        \"\"\"Single server deployment for initial launch\"\"\"\n\n        def __init__(self):\n            self.database = PostgreSQLDatabase(\"localhost:5432\")\n            self.cache = InMemoryCache()\n            self.logger = ConsoleLogger()\n\n    # Phase 2: Scalable Infrastructure\n    class ScalableDeployment:\n        \"\"\"Multi-server deployment with load balancing\"\"\"\n\n        def __init__(self):\n            self.database = PostgreSQLCluster([\n                \"db-primary:5432\",\n                \"db-replica-1:5432\", \n                \"db-replica-2:5432\"\n            ])\n            self.cache = RedisCluster([\n                \"redis-1:6379\",\n                \"redis-2:6379\",\n                \"redis-3:6379\"\n            ])\n            self.logger = StructuredLogger(\n                output=CloudWatchLogsHandler()\n            )\n\n    # Phase 3: Cloud-Native Infrastructure\n    class CloudNativeDeployment:\n        \"\"\"Fully cloud-native with auto-scaling and monitoring\"\"\"\n\n        def __init__(self):\n            self.database = AWSRDSProxy(\n                cluster_endpoint=\"cluster.amazonaws.com\",\n                read_replicas=[\"reader-1.amazonaws.com\"],\n                auto_scaling=True\n            )\n            self.cache = AWSElastiCache(\n                cluster_mode=True,\n                auto_failover=True\n            )\n            self.search = AWSElasticsearch(\n                domain=\"order-search-domain\"\n            )\n            self.logger = AWSCloudWatchLogger(\n                log_group=\"/aws/application/orders\",\n                structured=True,\n                sampling_rate=0.1  # Sample 10% of logs\n            )\n            self.metrics = AWSCloudWatchMetrics()\n            self.tracing = AWSXRayTracing()\n\n# Configuration-driven infrastructure selection\nclass InfrastructureFactory:\n    \"\"\"Factory to create infrastructure based on environment configuration\"\"\"\n\n    @staticmethod\n    def create_infrastructure(config: InfrastructureConfig):\n        if config.environment == \"development\":\n            return InfrastructureEvolution.SimpleDeployment()\n        elif config.environment == \"staging\":\n            return InfrastructureEvolution.ScalableDeployment()\n        elif config.environment == \"production\":\n            return InfrastructureEvolution.CloudNativeDeployment()\n        else:\n            raise ValueError(f\"Unknown environment: {config.environment}\")\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#managing-technical-debt-during-evolution","title":"Managing Technical Debt During Evolution","text":"<p>Technical debt is inevitable during architectural evolution. The key is managing it strategically:</p> <pre><code># Technical Debt Tracking and Management\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\n\nclass TechnicalDebtSeverity(Enum):\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    CRITICAL = \"critical\"\n\n@dataclass\nclass TechnicalDebt:\n    id: str\n    description: str\n    severity: TechnicalDebtSeverity\n    affected_components: List[str]\n    estimated_effort_days: int\n    business_impact: str\n    created_date: datetime\n    target_resolution_date: Optional[datetime] = None\n\nclass TechnicalDebtManager:\n    \"\"\"Manages technical debt during architectural evolution\"\"\"\n\n    def __init__(self):\n        self.debt_items: Dict[str, TechnicalDebt] = {}\n        self.resolution_strategies = {}\n\n    def add_debt(self, debt: TechnicalDebt):\n        \"\"\"Add new technical debt item\"\"\"\n        self.debt_items[debt.id] = debt\n        self._schedule_resolution(debt)\n\n    def prioritize_debt(self) -&gt; List[TechnicalDebt]:\n        \"\"\"Prioritize debt items by business impact and severity\"\"\"\n        return sorted(\n            self.debt_items.values(),\n            key=lambda d: (\n                d.severity.value,\n                len(d.affected_components),\n                d.estimated_effort_days\n            ),\n            reverse=True\n        )\n\n    def create_migration_plan(\n        self, \n        target_architecture: str,\n        available_capacity_days: int\n    ) -&gt; MigrationPlan:\n        \"\"\"Create plan to address debt while evolving architecture\"\"\"\n\n        prioritized_debt = self.prioritize_debt()\n        plan = MigrationPlan(target_architecture)\n\n        remaining_capacity = available_capacity_days\n\n        for debt_item in prioritized_debt:\n            if debt_item.estimated_effort_days &lt;= remaining_capacity:\n                plan.add_debt_resolution(debt_item)\n                remaining_capacity -= debt_item.estimated_effort_days\n            else:\n                plan.add_deferred_debt(debt_item)\n\n        return plan\n\n    def _schedule_resolution(self, debt: TechnicalDebt):\n        \"\"\"Schedule debt resolution based on severity\"\"\"\n        now = datetime.now()\n\n        if debt.severity == TechnicalDebtSeverity.CRITICAL:\n            debt.target_resolution_date = now + timedelta(weeks=1)\n        elif debt.severity == TechnicalDebtSeverity.HIGH:\n            debt.target_resolution_date = now + timedelta(weeks=4)\n        elif debt.severity == TechnicalDebtSeverity.MEDIUM:\n            debt.target_resolution_date = now + timedelta(weeks=12)\n        else:\n            debt.target_resolution_date = now + timedelta(weeks=26)\n\n# Example usage during evolution\ndef evolve_order_service():\n    \"\"\"Example of managed evolution with debt tracking\"\"\"\n\n    debt_manager = TechnicalDebtManager()\n\n    # Identify debt during evolution\n    debt_manager.add_debt(TechnicalDebt(\n        id=\"legacy-payment-integration\",\n        description=\"Legacy payment service uses synchronous calls without retries\",\n        severity=TechnicalDebtSeverity.HIGH,\n        affected_components=[\"OrderService\", \"PaymentService\"],\n        estimated_effort_days=5,\n        business_impact=\"Payment failures cause order loss\",\n        created_date=datetime.now()\n    ))\n\n    debt_manager.add_debt(TechnicalDebt(\n        id=\"missing-integration-tests\",\n        description=\"Order processing flow lacks comprehensive integration tests\",\n        severity=TechnicalDebtSeverity.MEDIUM,\n        affected_components=[\"OrderService\", \"InventoryService\", \"PaymentService\"],\n        estimated_effort_days=8,\n        business_impact=\"Deployment risk increases with each change\",\n        created_date=datetime.now()\n    ))\n\n    # Create migration plan\n    plan = debt_manager.create_migration_plan(\n        target_architecture=\"microservices\",\n        available_capacity_days=20\n    )\n\n    return plan\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#evolution-monitoring-and-metrics","title":"Evolution Monitoring and Metrics","text":"<p>Track the health of your architectural evolution with key metrics:</p> <pre><code># Evolution Health Metrics\nclass ArchitecturalMetrics:\n    \"\"\"Metrics to track architectural evolution health\"\"\"\n\n    def __init__(self, metrics_collector):\n        self.metrics = metrics_collector\n\n    def track_coupling_metrics(self):\n        \"\"\"Track coupling between components\"\"\"\n\n        # Afferent coupling (incoming dependencies)\n        afferent_coupling = self._calculate_afferent_coupling()\n        self.metrics.gauge(\"architecture.afferent_coupling\", afferent_coupling)\n\n        # Efferent coupling (outgoing dependencies) \n        efferent_coupling = self._calculate_efferent_coupling()\n        self.metrics.gauge(\"architecture.efferent_coupling\", efferent_coupling)\n\n        # Instability (Efferent / (Afferent + Efferent))\n        total_coupling = afferent_coupling + efferent_coupling\n        instability = efferent_coupling / total_coupling if total_coupling &gt; 0 else 0\n        self.metrics.gauge(\"architecture.instability\", instability)\n\n    def track_complexity_metrics(self):\n        \"\"\"Track code complexity trends\"\"\"\n\n        # Cyclomatic complexity\n        complexity = self._calculate_cyclomatic_complexity()\n        self.metrics.gauge(\"architecture.cyclomatic_complexity\", complexity)\n\n        # Lines of code per component\n        loc_per_component = self._calculate_loc_per_component()\n        for component, loc in loc_per_component.items():\n            self.metrics.gauge(f\"architecture.loc.{component}\", loc)\n\n    def track_test_coverage(self):\n        \"\"\"Track test coverage by architectural layer\"\"\"\n\n        coverage = self._calculate_layer_coverage()\n        for layer, percentage in coverage.items():\n            self.metrics.gauge(f\"architecture.test_coverage.{layer}\", percentage)\n\n    def track_deployment_metrics(self):\n        \"\"\"Track deployment and operational metrics\"\"\"\n\n        # Deployment frequency\n        self.metrics.counter(\"architecture.deployments\")\n\n        # Mean time to recovery\n        mttr = self._calculate_mttr()\n        self.metrics.gauge(\"architecture.mttr_minutes\", mttr)\n\n        # Change failure rate\n        failure_rate = self._calculate_change_failure_rate()\n        self.metrics.gauge(\"architecture.change_failure_rate\", failure_rate)\n\nclass EvolutionDashboard:\n    \"\"\"Dashboard to visualize architectural evolution\"\"\"\n\n    def __init__(self, metrics: ArchitecturalMetrics):\n        self.metrics = metrics\n\n    def generate_health_report(self) -&gt; Dict[str, Any]:\n        \"\"\"Generate comprehensive architectural health report\"\"\"\n\n        return {\n            \"coupling\": {\n                \"afferent\": self.metrics.get_latest(\"architecture.afferent_coupling\"),\n                \"efferent\": self.metrics.get_latest(\"architecture.efferent_coupling\"),\n                \"instability\": self.metrics.get_latest(\"architecture.instability\")\n            },\n            \"complexity\": {\n                \"cyclomatic\": self.metrics.get_latest(\"architecture.cyclomatic_complexity\"),\n                \"loc_trend\": self.metrics.get_trend(\"architecture.total_loc\", days=30)\n            },\n            \"quality\": {\n                \"test_coverage\": self.metrics.get_latest(\"architecture.test_coverage.total\"),\n                \"debt_ratio\": self._calculate_technical_debt_ratio()\n            },\n            \"operational\": {\n                \"deployment_frequency\": self.metrics.get_rate(\"architecture.deployments\"),\n                \"mttr\": self.metrics.get_latest(\"architecture.mttr_minutes\"),\n                \"change_failure_rate\": self.metrics.get_latest(\"architecture.change_failure_rate\")\n            }\n        }\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#evolution-best-practices","title":"Evolution Best Practices","text":"","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#1-evolutionary-architecture-principles","title":"1. Evolutionary Architecture Principles","text":"<pre><code># Fitness Functions for Architectural Evolution\nclass ArchitecturalFitnessFunction:\n    \"\"\"Automated tests that verify architectural characteristics\"\"\"\n\n    def test_dependency_direction(self):\n        \"\"\"Ensure dependencies flow toward the domain layer\"\"\"\n        violations = []\n\n        # Check that infrastructure doesn't import domain\n        domain_imports = self._get_imports_to_domain()\n        for module, imports in domain_imports.items():\n            if module.startswith('infrastructure.'):\n                violations.append(f\"Infrastructure module {module} imports domain\")\n\n        assert len(violations) == 0, f\"Dependency violations: {violations}\"\n\n    def test_database_abstraction(self):\n        \"\"\"Ensure business logic doesn't depend on specific database\"\"\"\n        business_modules = self._get_business_modules()\n        for module in business_modules:\n            imports = self._get_module_imports(module)\n            database_imports = [imp for imp in imports if 'sqlalchemy' in imp or 'django.db' in imp]\n            assert len(database_imports) == 0, f\"Business module {module} has database dependencies\"\n\n    def test_external_service_abstraction(self):\n        \"\"\"Ensure business logic uses interfaces for external services\"\"\"\n        business_modules = self._get_business_modules()\n        for module in business_modules:\n            imports = self._get_module_imports(module)\n            external_imports = [imp for imp in imports if 'requests' in imp or 'boto3' in imp]\n            assert len(external_imports) == 0, f\"Business module {module} has external service dependencies\"\n\n# Integration with CI/CD\ndef run_architectural_tests():\n    \"\"\"Run architectural fitness functions in CI/CD pipeline\"\"\"\n    fitness = ArchitecturalFitnessFunction()\n\n    try:\n        fitness.test_dependency_direction()\n        fitness.test_database_abstraction()\n        fitness.test_external_service_abstraction()\n        print(\"\u2705 All architectural tests passed\")\n        return True\n    except AssertionError as e:\n        print(f\"\u274c Architectural test failed: {e}\")\n        return False\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#2-feature-toggle-strategy","title":"2. Feature Toggle Strategy","text":"<pre><code># Feature Toggles for Safe Evolution\nclass FeatureToggleManager:\n    \"\"\"Manages feature toggles during architectural evolution\"\"\"\n\n    def __init__(self, toggle_store):\n        self.toggle_store = toggle_store\n\n    async def is_enabled(\n        self, \n        feature: str, \n        context: Optional[Dict[str, Any]] = None\n    ) -&gt; bool:\n        \"\"\"Check if feature is enabled for given context\"\"\"\n\n        toggle = await self.toggle_store.get_toggle(feature)\n        if not toggle:\n            return False\n\n        return toggle.evaluate(context or {})\n\nclass EvolutionFeatureToggle:\n    \"\"\"Specific toggle for architectural evolution features\"\"\"\n\n    def __init__(self, name: str, rollout_percentage: int = 0):\n        self.name = name\n        self.rollout_percentage = rollout_percentage\n        self.enabled_users = set()\n        self.enabled_tenants = set()\n\n    def evaluate(self, context: Dict[str, Any]) -&gt; bool:\n        \"\"\"Evaluate if toggle should be enabled for context\"\"\"\n\n        user_id = context.get('user_id')\n        tenant_id = context.get('tenant_id')\n\n        # Explicit enable lists\n        if user_id in self.enabled_users:\n            return True\n        if tenant_id in self.enabled_tenants:\n            return True\n\n        # Percentage rollout\n        if self.rollout_percentage &gt; 0:\n            hash_input = f\"{self.name}:{user_id}:{tenant_id}\"\n            hash_value = hash(hash_input) % 100\n            return hash_value &lt; self.rollout_percentage\n\n        return False\n\n# Usage in evolved architecture\nclass OrderServiceRouter:\n    \"\"\"Routes between old and new implementations based on toggles\"\"\"\n\n    def __init__(\n        self,\n        legacy_service: LegacyOrderService,\n        modern_service: ModernOrderService,\n        toggle_manager: FeatureToggleManager\n    ):\n        self.legacy_service = legacy_service\n        self.modern_service = modern_service\n        self.toggle_manager = toggle_manager\n\n    async def create_order(self, order_request, user_context):\n        \"\"\"Route order creation based on feature toggles\"\"\"\n\n        # Check various evolution toggles\n        use_modern_service = await self.toggle_manager.is_enabled(\n            \"modern_order_service\",\n            context={'user_id': user_context.user_id, 'tenant_id': user_context.tenant_id}\n        )\n\n        use_event_sourcing = await self.toggle_manager.is_enabled(\n            \"order_event_sourcing\",\n            context=user_context.to_dict()\n        )\n\n        if use_modern_service:\n            if use_event_sourcing:\n                # Use fully evolved implementation\n                return await self.modern_service.create_order_with_events(order_request)\n            else:\n                # Use modern service with traditional persistence\n                return await self.modern_service.create_order(order_request)\n        else:\n            # Fall back to legacy implementation\n            return await self.legacy_service.create_order(order_request)\n</code></pre>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#conclusion-evolution-as-a-competitive-advantage","title":"Conclusion: Evolution as a Competitive Advantage","text":"<p>Architectural evolution isn't just about managing technical complexity\u2014it's a competitive advantage that enables your business to adapt faster than competitors constrained by rigid architectures.</p> <p>Key principles for successful evolution:</p> <ol> <li>Business Logic Stability: Preserve your core business investments while infrastructure evolves</li> <li>Incremental Migration: Use patterns like Strangler Fig to evolve systems gradually</li> <li>Interface Design: Create abstractions that anticipate future scaling needs</li> <li>Debt Management: Track and strategically address technical debt</li> <li>Monitoring Evolution: Use metrics to ensure architectural changes improve system health</li> <li>Safety Mechanisms: Feature toggles and fitness functions provide guardrails during evolution</li> </ol> <p>The clean-py repository demonstrates these patterns in action, providing a foundation that can evolve from startup MVP to enterprise scale without requiring complete rewrites.</p> <p>The companies that thrive long-term are those that build evolution into their DNA from day one. They understand that the first version of their architecture won't be the last, and they design for change rather than perfection.</p> <p>Start with Clean Architecture principles, implement evolution-friendly patterns, and build systems that grow with your business rather than constraining it. Your future self\u2014and your business\u2014will thank you when you're scaling to millions of users instead of rewriting everything from scratch.</p> <p>Architecture evolution is not just about technology\u2014it's about building organizational capability to adapt and thrive in an uncertain future.</p>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/02/evolving-your-architecture---patterns-for-growth/#references","title":"References","text":"<ul> <li>Clean-Py Repository - Evolution-ready architecture</li> <li>Building Evolutionary Architectures - Evolutionary architecture patterns</li> <li>Strangler Fig Pattern - Incremental migration strategy</li> <li>Feature Toggles - Safe evolution techniques</li> </ul>","tags":["architecture-evolution","software-design","python","clean-py","growth-patterns"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/","title":"Keeping Your Python Codebase Tidy: Linters, Type Checkers, and Workspace Harmony","text":"<p>After fifteen posts about architecture, patterns, and deployment, let's talk about something equally important but often overlooked: keeping your codebase consistently clean as it grows. I've seen brilliant architectures deteriorate not from bad design decisions, but from gradual erosion of code quality standards. A thousand small inconsistencies eventually make a codebase unmaintainable.</p> <p>The clean-py repository uses multiple complementary tools to maintain code quality. This isn't the only way\u2014it's one approach I've found convenient after years of experimentation. Your team might prefer different tools or workflows, and that's perfectly fine. The key is having a system and sticking to it.</p>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#the-multi-tool-approach-why-one-tool-isnt-enough","title":"The Multi-Tool Approach: Why One Tool Isn't Enough","text":"<p>Each code quality tool serves a different purpose. Trying to find one tool that does everything is like looking for a universal remote that also makes coffee\u2014theoretically possible, but probably not optimal at either task.</p> <p>Here's the toolkit approach used in clean-py:</p> <ul> <li>Black: Formats code (opinions included, debates excluded)</li> <li>isort: Organizes imports consistently</li> <li>Ruff: Fast linting and basic error catching</li> <li>Pylint: Deep code analysis and convention enforcement</li> <li>Pyright: Strict type checking</li> <li>Mypy: Alternative type checking with different strengths</li> <li>Bandit: Security vulnerability scanning</li> <li>Vulture: Dead code detection</li> <li>Radon: Complexity analysis</li> </ul> <p>Each tool catches different issues. Ruff might miss a design smell that Pylint catches. Pyright might find type issues that Mypy misses (and vice versa). The overlap isn't redundancy\u2014it's defense in depth.</p>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#pylint-the-thorough-inspector","title":"Pylint: The Thorough Inspector","text":"<p>Pylint goes beyond syntax checking to enforce coding standards and catch design issues. While Ruff is blazingly fast for basic checks, Pylint takes its time to perform deeper analysis:</p> <pre><code># .pylintrc\n[MASTER]\n# Specify a score threshold to be exceeded before program exits with error\nfail-under=8.0\n\n# Use multiple processes to speed up Pylint\njobs=4\n\n# Pickle collected data for later comparisons\npersistent=yes\n\n# Allow loading of arbitrary C extensions\nunsafe-load-any-extension=no\n\n[MESSAGES CONTROL]\n# Disable messages that conflict with other tools or are too strict\ndisable=\n    C0111,  # missing-docstring (we use interrogate for this)\n    C0103,  # invalid-name (too strict for test functions)\n    R0903,  # too-few-public-methods (value objects often have few methods)\n    R0801,  # duplicate-code (often false positives in tests)\n    W0212,  # protected-access (needed for testing private methods)\n    E1101,  # no-member (false positives with SQLAlchemy)\n    W0511,  # fixme (we track TODOs differently)\n\n[REPORTS]\n# Set the output format\noutput-format=colorized\n\n# Include message's id in output\ninclude-ids=yes\n\n# Include symbolic ids of messages in output\nsymbol=yes\n\n# Put messages in separate files\nfiles-output=no\n\n# Template for output\nmsg-template={path}:{line}: [{msg_id}({symbol}), {obj}] {msg}\n\n[BASIC]\n# Naming conventions\nargument-naming-style=snake_case\nattr-naming-style=snake_case\nclass-attribute-naming-style=any\nclass-naming-style=PascalCase\nconst-naming-style=UPPER_CASE\nfunction-naming-style=snake_case\nmethod-naming-style=snake_case\nmodule-naming-style=snake_case\nvariable-naming-style=snake_case\n\n# Good names which should always be accepted\ngood-names=i,j,k,ex,Run,_,id,ok,db\n\n# Bad names which should always be refused\nbad-names=foo,bar,baz,toto,tutu,tata\n\n[DESIGN]\n# Maximum number of arguments for functions\nmax-args=7\n\n# Maximum number of attributes for a class\nmax-attributes=10\n\n# Maximum number of boolean expressions in an if statement\nmax-bool-expr=5\n\n# Maximum number of branch for function/method body\nmax-branches=12\n\n# Maximum number of locals for function/method body\nmax-locals=15\n\n# Maximum number of parents for a class\nmax-parents=7\n\n# Maximum number of public methods for a class\nmax-public-methods=20\n\n# Maximum number of return/yield for function/method body\nmax-returns=6\n\n# Maximum number of statements in function/method body\nmax-statements=50\n\n# Minimum number of public methods for a class\nmin-public-methods=0\n\n[SIMILARITIES]\n# Minimum lines number of a similarity\nmin-similarity-lines=4\n\n# Ignore comments when computing similarities\nignore-comments=yes\n\n# Ignore docstrings when computing similarities\nignore-docstrings=yes\n\n# Ignore imports when computing similarities\nignore-imports=yes\n\n[TYPECHECK]\n# List of class names for which member attributes should not be checked\nignored-classes=optparse.Values,thread._local,_thread._local,SQLAlchemy,scoped_session\n\n# List of module names for which member attributes should not be checked\nignored-modules=alembic.context,sqlalchemy.orm\n\n[IMPORTS]\n# Allow wildcard imports from modules\nallow-wildcard-with-all=no\n\n# Analyse import fallback blocks\nanalyse-fallback-blocks=no\n\n# Deprecated modules which should not be used\ndeprecated-modules=optparse,tkinter.tix\n\n[EXCEPTIONS]\n# Exceptions that will emit a warning when being caught\novergeneral-exceptions=BaseException,Exception\n</code></pre> <p>Pylint catches issues other tools miss:</p> <pre><code># Pylint catches these design issues\n\nclass OrderService:\n    def process_order(self, order_id, customer_id, product_ids, \n                      quantities, prices, discounts, shipping_address,\n                      billing_address, payment_method):  # too-many-arguments\n        \"\"\"Process an order with too many parameters.\"\"\"\n        pass\n\ndef calculate_total(items):\n    # too-many-branches, too-many-statements\n    total = 0\n    for item in items:\n        if item.type == 'product':\n            if item.taxable:\n                if item.category == 'food':\n                    total += item.price * 1.05\n                elif item.category == 'clothing':\n                    total += item.price * 1.08\n                else:\n                    total += item.price * 1.10\n            else:\n                total += item.price\n        elif item.type == 'service':\n            if item.duration &gt; 4:\n                total += item.price * 1.5\n            else:\n                total += item.price\n    # ... 20 more conditions\n    return total\n\n# Pylint suggests refactoring to:\nclass PriceCalculator:\n    def calculate_total(self, items):\n        return sum(self._calculate_item_price(item) for item in items)\n\n    def _calculate_item_price(self, item):\n        if item.type == 'product':\n            return self._calculate_product_price(item)\n        elif item.type == 'service':\n            return self._calculate_service_price(item)\n        return item.price\n</code></pre>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#pyright-the-strict-type-guardian","title":"Pyright: The Strict Type Guardian","text":"<p>While Mypy is popular, Pyright (which powers Pylance in VS Code) offers some advantages, especially for large codebases:</p> <pre><code>// pyrightconfig.json\n{\n  \"include\": [\n    \"src\",\n    \"tests\"\n  ],\n  \"exclude\": [\n    \"**/__pycache__\",\n    \"**/.*\",\n    \"build\",\n    \"dist\"\n  ],\n  \"ignore\": [],\n  \"defineConstant\": {\n    \"DEBUG\": true\n  },\n  \"stubPath\": \"typings\",\n  \"venv\": \".venv\",\n  \"typeCheckingMode\": \"strict\",\n  \"pythonVersion\": \"3.11\",\n  \"pythonPlatform\": \"Linux\",\n  \"reportMissingImports\": \"error\",\n  \"reportMissingTypeStubs\": \"warning\",\n  \"reportMissingModuleSource\": \"warning\",\n  \"reportInvalidTypeForm\": \"error\",\n  \"reportMissingParameterType\": \"error\",\n  \"reportMissingTypeArgument\": \"error\",\n  \"reportUnknownParameterType\": \"warning\",\n  \"reportUnknownArgumentType\": \"warning\",\n  \"reportUnknownLambdaType\": \"warning\",\n  \"reportUnknownVariableType\": \"warning\",\n  \"reportUnknownMemberType\": \"warning\",\n  \"reportUnnecessaryIsInstance\": \"warning\",\n  \"reportUnnecessaryCast\": \"error\",\n  \"reportUnnecessaryComparison\": \"error\",\n  \"reportUnnecessaryContains\": \"error\",\n  \"reportAssertAlwaysTrue\": \"error\",\n  \"reportSelfClsParameterName\": \"error\",\n  \"reportUnusedImport\": \"error\",\n  \"reportUnusedClass\": \"warning\",\n  \"reportUnusedFunction\": \"warning\",\n  \"reportUnusedVariable\": \"warning\",\n  \"reportDuplicateImport\": \"error\",\n  \"reportWildcardImportFromLibrary\": \"error\",\n  \"reportOptionalMemberAccess\": \"error\",\n  \"reportOptionalCall\": \"error\",\n  \"reportOptionalIterable\": \"error\",\n  \"reportOptionalContextManager\": \"error\",\n  \"reportOptionalOperand\": \"error\",\n  \"reportTypedDictNotRequiredAccess\": \"error\",\n  \"reportPrivateImportUsage\": \"error\",\n  \"reportUnboundVariable\": \"error\",\n  \"reportUnsupportedDunderAll\": \"warning\",\n  \"reportIncompatibleMethodOverride\": \"error\",\n  \"reportIncompatibleVariableOverride\": \"error\",\n  \"reportOverlappingOverload\": \"error\",\n  \"reportConstantRedefinition\": \"error\",\n  \"reportDeprecated\": \"warning\",\n  \"reportMatchNotExhaustive\": \"error\",\n  \"reportUnnecessaryTypeIgnoreComment\": \"warning\"\n}\n</code></pre> <p>Pyright's advantages include: - Faster performance on large codebases - Better IDE integration (especially VS Code) - More accurate type inference in some cases - Better support for type narrowing</p> <p>Example where Pyright shines:</p> <pre><code>from typing import Union, Literal\n\ndef process_value(value: Union[int, str]) -&gt; str:\n    # Pyright understands type narrowing better\n    if isinstance(value, int):\n        # Pyright knows value is int here\n        return str(value + 10)\n    else:\n        # Pyright knows value is str here\n        return value.upper()\n\n# Pyright handles Literal types well\nStatus = Literal[\"pending\", \"approved\", \"rejected\"]\n\ndef handle_status(status: Status) -&gt; None:\n    # Pyright ensures exhaustive handling\n    match status:\n        case \"pending\":\n            print(\"Waiting\")\n        case \"approved\":\n            print(\"Good to go\")\n        # Pyright warns: Case \"rejected\" not handled\n</code></pre>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#workspace-configuration-team-consistency","title":"Workspace Configuration: Team Consistency","text":"<p>One of the most underrated features for team development is workspace configuration. This ensures everyone has the same setup:</p> <pre><code>// .vscode/settings.json\n{\n  \"python.defaultInterpreterPath\": \"${workspaceFolder}/.venv/bin/python\",\n  \"python.linting.enabled\": true,\n  \"python.linting.pylintEnabled\": true,\n  \"python.linting.pylintPath\": \"${workspaceFolder}/.venv/bin/pylint\",\n  \"python.linting.mypyEnabled\": true,\n  \"python.linting.mypyPath\": \"${workspaceFolder}/.venv/bin/mypy\",\n  \"python.linting.banditEnabled\": true,\n  \"python.linting.banditPath\": \"${workspaceFolder}/.venv/bin/bandit\",\n  \"python.formatting.provider\": \"black\",\n  \"python.formatting.blackPath\": \"${workspaceFolder}/.venv/bin/black\",\n  \"python.sortImports.path\": \"${workspaceFolder}/.venv/bin/isort\",\n  \"python.testing.pytestEnabled\": true,\n  \"python.testing.pytestPath\": \"${workspaceFolder}/.venv/bin/pytest\",\n  \"python.testing.unittestEnabled\": false,\n  \"python.testing.autoTestDiscoverOnSaveEnabled\": true,\n  \"python.languageServer\": \"Pylance\",\n  \"python.analysis.typeCheckingMode\": \"strict\",\n  \"python.analysis.autoImportCompletions\": true,\n  \"python.analysis.autoSearchPaths\": true,\n  \"python.analysis.diagnosticMode\": \"workspace\",\n  \"python.analysis.stubPath\": \"typings\",\n  \"python.analysis.extraPaths\": [\"src\"],\n  \"python.analysis.reportMissingImports\": \"error\",\n  \"python.analysis.reportMissingTypeStubs\": \"warning\",\n  \"python.analysis.reportUnusedImport\": \"warning\",\n  \"python.analysis.reportUnusedClass\": \"warning\",\n  \"python.analysis.reportUnusedFunction\": \"warning\",\n  \"python.analysis.reportUnusedVariable\": \"warning\",\n  \"python.analysis.reportDuplicateImport\": \"error\",\n  \"python.analysis.reportOptionalMemberAccess\": \"error\",\n  \"python.analysis.reportOptionalCall\": \"error\",\n  \"python.analysis.reportUnsupportedDunderAll\": \"warning\",\n  \"[python]\": {\n    \"editor.formatOnSave\": true,\n    \"editor.codeActionsOnSave\": {\n      \"source.organizeImports\": true,\n      \"source.fixAll\": true\n    },\n    \"editor.rulers\": [88],\n    \"editor.wordWrap\": \"on\"\n  },\n  \"files.exclude\": {\n    \"**/__pycache__\": true,\n    \"**/*.pyc\": true,\n    \"**/.pytest_cache\": true,\n    \"**/.mypy_cache\": true,\n    \"**/.ruff_cache\": true,\n    \"**/htmlcov\": true,\n    \"**/.coverage\": true\n  },\n  \"files.watcherExclude\": {\n    \"**/.venv/**\": true,\n    \"**/venv/**\": true\n  },\n  \"search.exclude\": {\n    \"**/.venv\": true,\n    \"**/venv\": true,\n    \"**/__pycache__\": true,\n    \"**/htmlcov\": true\n  }\n}\n</code></pre> <p>For PyCharm users, similar configuration:</p> <pre><code>&lt;!-- .idea/inspectionProfiles/Project_Default.xml --&gt;\n&lt;component name=\"InspectionProjectProfileManager\"&gt;\n  &lt;profile version=\"1.0\"&gt;\n    &lt;option name=\"myName\" value=\"Project Default\" /&gt;\n    &lt;inspection_tool class=\"PyPackageRequirementsInspection\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\"&gt;\n      &lt;option name=\"ignoredPackages\"&gt;\n        &lt;value&gt;\n          &lt;list size=\"0\" /&gt;\n        &lt;/value&gt;\n      &lt;/option&gt;\n    &lt;/inspection_tool&gt;\n    &lt;inspection_tool class=\"PyPep8Inspection\" enabled=\"true\" level=\"WEAK WARNING\" enabled_by_default=\"true\"&gt;\n      &lt;option name=\"ignoredErrors\"&gt;\n        &lt;list&gt;\n          &lt;option value=\"E501\" /&gt;\n        &lt;/list&gt;\n      &lt;/option&gt;\n    &lt;/inspection_tool&gt;\n    &lt;inspection_tool class=\"PyTypeCheckerInspection\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\" /&gt;\n    &lt;inspection_tool class=\"PyUnresolvedReferencesInspection\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\"&gt;\n      &lt;option name=\"ignoredIdentifiers\"&gt;\n        &lt;list&gt;\n          &lt;option value=\"sqlalchemy.orm.scoped_session.*\" /&gt;\n        &lt;/list&gt;\n      &lt;/option&gt;\n    &lt;/inspection_tool&gt;\n  &lt;/profile&gt;\n&lt;/component&gt;\n</code></pre>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#editorconfig-universal-editor-settings","title":"EditorConfig: Universal Editor Settings","text":"<p>For teams using different editors, EditorConfig provides consistency:</p> <pre><code># .editorconfig\nroot = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\nindent_style = space\n\n[*.py]\nindent_size = 4\nmax_line_length = 88\n\n[*.{json,yaml,yml,toml}]\nindent_size = 2\n\n[*.md]\ntrim_trailing_whitespace = false\n\n[Makefile]\nindent_style = tab\n\n[*.{js,jsx,ts,tsx}]\nindent_size = 2\n\n[*.sql]\nindent_size = 2\n</code></pre>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#make-commands-one-interface-to-rule-them-all","title":"Make Commands: One Interface to Rule Them All","text":"<p>The Makefile provides a consistent interface regardless of the underlying tools:</p> <pre><code># Additional Make commands for code maintenance\n\n.PHONY: lint-all\nlint-all: ## Run all linting tools\n    @echo \"Running comprehensive linting...\"\n    @echo \"1/5 Ruff...\"\n    @ruff check src tests\n    @echo \"2/5 Pylint...\"\n    @pylint src --rcfile=.pylintrc\n    @echo \"3/5 Mypy...\"\n    @mypy src --strict\n    @echo \"4/5 Pyright...\"\n    @pyright src\n    @echo \"5/5 Bandit...\"\n    @bandit -r src -ll\n    @echo \"\u2705 All linting passed!\"\n\n.PHONY: fix-all\nfix-all: ## Auto-fix all possible issues\n    @echo \"Auto-fixing code issues...\"\n    @black src tests\n    @isort src tests\n    @ruff check --fix src tests\n    @autoflake --in-place --remove-all-unused-imports --recursive src tests\n    @echo \"\u2705 Auto-fixes applied!\"\n\n.PHONY: complexity\ncomplexity: ## Analyze code complexity\n    @echo \"Analyzing code complexity...\"\n    @radon cc src --min B --show-complexity --total-average\n    @radon mi src --min B --show\n    @echo \"\"\n    @echo \"Cyclomatic Complexity:\"\n    @echo \"  A: 1-5   (low risk - simple block)\"\n    @echo \"  B: 6-10  (low risk - well structured)\"\n    @echo \"  C: 11-20 (moderate risk - more complex)\"\n    @echo \"  D: 21-50 (high risk - complex, alarming)\"\n    @echo \"  E: &gt;50   (very high risk - untestable)\"\n\n.PHONY: dead-code\ndead-code: ## Find dead code\n    @echo \"Searching for dead code...\"\n    @vulture src --min-confidence 80\n\n.PHONY: todos\ntodos: ## List all TODOs and FIXMEs\n    @echo \"TODOs and FIXMEs:\"\n    @grep -r \"TODO\\|FIXME\\|HACK\\|XXX\" src tests --exclude-dir=__pycache__ || echo \"No TODOs found!\"\n\n.PHONY: deps-check\ndeps-check: ## Check dependency health\n    @echo \"Checking dependencies...\"\n    @pip list --outdated\n    @echo \"\"\n    @echo \"Security check:\"\n    @safety check || true\n    @echo \"\"\n    @echo \"License check:\"\n    @pip-licenses --with-urls --format=markdown\n\n.PHONY: stats\nstats: ## Show codebase statistics\n    @echo \"Codebase Statistics:\"\n    @echo \"===================\"\n    @echo \"Lines of Code:\"\n    @cloc src --exclude-dir=__pycache__\n    @echo \"\"\n    @echo \"File Count:\"\n    @find src -name \"*.py\" | wc -l\n    @echo \"\"\n    @echo \"Test Coverage:\"\n    @coverage report --skip-covered --sort=cover\n\n.PHONY: health\nhealth: ## Full codebase health check\n    @echo \"\ud83c\udfe5 Running full health check...\"\n    @$(MAKE) lint-all\n    @$(MAKE) test\n    @$(MAKE) complexity\n    @$(MAKE) dead-code\n    @$(MAKE) deps-check\n    @echo \"\u2705 Codebase is healthy!\"\n\n.PHONY: pre-commit-all\npre-commit-all: ## Run pre-commit on all files\n    @pre-commit run --all-files\n\n.PHONY: clean-deep\nclean-deep: clean ## Deep clean including caches and environments\n    @echo \"Deep cleaning...\"\n    @rm -rf .venv venv\n    @rm -rf node_modules\n    @rm -rf .tox\n    @rm -rf .eggs *.egg-info\n    @find . -type d -name \".pytest_cache\" -exec rm -rf {} + 2&gt;/dev/null || true\n    @find . -type d -name \".mypy_cache\" -exec rm -rf {} + 2&gt;/dev/null || true\n    @find . -type d -name \".ruff_cache\" -exec rm -rf {} + 2&gt;/dev/null || true\n    @find . -type d -name \"__pycache__\" -exec rm -rf {} + 2&gt;/dev/null || true\n    @echo \"\u2705 Deep clean complete!\"\n</code></pre>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#alternative-approaches","title":"Alternative Approaches","text":"<p>This multi-tool approach works well for the clean-py project, but it's not the only way. Here are alternatives worth considering:</p>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#the-minimalist-approach","title":"The Minimalist Approach","text":"<p>Some teams prefer fewer tools: - Ruff only: Fast and covers most linting needs - Black + Ruff: Formatting plus linting - Poetry + Black + Pytest: Simplified toolchain</p>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#the-all-in-one-approach","title":"The All-in-One Approach","text":"<p>Tools that try to do everything: - Prospector: Wraps multiple tools - Sourcery: AI-powered code review - SonarQube: Enterprise code quality platform</p>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#the-progressive-approach","title":"The Progressive Approach","text":"<p>Start simple, add tools as needed: 1. Start with Black (formatting) 2. Add Ruff (fast linting) 3. Add Mypy (type checking) 4. Add Pylint (deep analysis) when needed 5. Add specialized tools (security, complexity) for mature projects</p>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#continuous-code-health-monitoring","title":"Continuous Code Health Monitoring","text":"<p>Beyond running tools, monitor code health trends:</p> <pre><code># scripts/code_health.py\nimport json\nimport subprocess\nfrom datetime import datetime\nfrom pathlib import Path\n\ndef collect_metrics():\n    \"\"\"Collect code health metrics.\"\"\"\n    metrics = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"metrics\": {}\n    }\n\n    # Complexity metrics\n    result = subprocess.run(\n        [\"radon\", \"cc\", \"src\", \"--json\"],\n        capture_output=True,\n        text=True\n    )\n    complexity_data = json.loads(result.stdout)\n\n    total_complexity = 0\n    high_complexity_functions = 0\n\n    for file_data in complexity_data.values():\n        for func in file_data:\n            if isinstance(func, dict):\n                total_complexity += func.get(\"complexity\", 0)\n                if func.get(\"complexity\", 0) &gt; 10:\n                    high_complexity_functions += 1\n\n    metrics[\"metrics\"][\"average_complexity\"] = total_complexity / max(len(complexity_data), 1)\n    metrics[\"metrics\"][\"high_complexity_functions\"] = high_complexity_functions\n\n    # Pylint score\n    result = subprocess.run(\n        [\"pylint\", \"src\", \"--output-format=json\"],\n        capture_output=True,\n        text=True\n    )\n    if result.stdout:\n        pylint_data = json.loads(result.stdout)\n        metrics[\"metrics\"][\"pylint_score\"] = pylint_data.get(\"score\", 0)\n\n    # Type coverage (pyright)\n    result = subprocess.run(\n        [\"pyright\", \"--outputjson\"],\n        capture_output=True,\n        text=True\n    )\n    if result.stdout:\n        pyright_data = json.loads(result.stdout)\n        metrics[\"metrics\"][\"type_errors\"] = pyright_data[\"summary\"][\"errorCount\"]\n        metrics[\"metrics\"][\"type_warnings\"] = pyright_data[\"summary\"][\"warningCount\"]\n\n    return metrics\n\ndef generate_report(metrics):\n    \"\"\"Generate health report.\"\"\"\n    print(\"\ud83d\udcca Code Health Report\")\n    print(\"=\" * 50)\n    print(f\"Timestamp: {metrics['timestamp']}\")\n    print(f\"Average Complexity: {metrics['metrics'].get('average_complexity', 0):.2f}\")\n    print(f\"High Complexity Functions: {metrics['metrics'].get('high_complexity_functions', 0)}\")\n    print(f\"Pylint Score: {metrics['metrics'].get('pylint_score', 0):.2f}/10\")\n    print(f\"Type Errors: {metrics['metrics'].get('type_errors', 0)}\")\n    print(f\"Type Warnings: {metrics['metrics'].get('type_warnings', 0)}\")\n\n    # Save to file for tracking\n    history_file = Path(\"code_health_history.json\")\n    history = []\n    if history_file.exists():\n        history = json.loads(history_file.read_text())\n    history.append(metrics)\n    history_file.write_text(json.dumps(history, indent=2))\n\nif __name__ == \"__main__\":\n    metrics = collect_metrics()\n    generate_report(metrics)\n</code></pre>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":"","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#tool-overload","title":"Tool Overload","text":"<p>Problem: Too many tools slow down development. Solution: Start with essentials, add tools when problems arise.</p>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#configuration-drift","title":"Configuration Drift","text":"<p>Problem: Local configs diverge from team standards. Solution: Version control all configuration files, use workspace settings.</p>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#ignored-warnings","title":"Ignored Warnings","text":"<p>Problem: Teams ignore tool output due to noise. Solution: Configure tools properly, fix warnings immediately or suppress with reason.</p>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#performance-issues","title":"Performance Issues","text":"<p>Problem: Linting takes too long. Solution: Use faster tools (Ruff), run expensive checks only in CI.</p>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#the-human-element","title":"The Human Element","text":"<p>Tools don't maintain code quality\u2014people do. The best tooling setup fails if the team doesn't buy in. Here's what works:</p> <ol> <li>Explain the Why: Show how tools save time and prevent bugs</li> <li>Start Gradually: Don't enable all checks at once</li> <li>Fix Together: Make fixing warnings a team activity</li> <li>Celebrate Improvements: Share metrics showing quality improvements</li> <li>Allow Flexibility: Some rules might not fit your project</li> </ol>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#conclusion","title":"Conclusion","text":"<p>Keeping a Python codebase tidy isn't about following a prescriptive set of rules\u2014it's about finding what works for your team and automating it. The clean-py repository demonstrates one approach using multiple complementary tools, comprehensive configuration, and convenient Make commands.</p> <p>The specific tools matter less than having a system. Whether you use Pylint or only Ruff, Pyright or Mypy, VS Code or PyCharm\u2014what matters is consistency, automation, and team buy-in. Start with the basics, add tools as needed, and always prioritize developer experience alongside code quality.</p> <p>Remember: Clean code isn't an end goal\u2014it's a means to deliver value efficiently. The best codebase is one that's clean enough to maintain, flexible enough to evolve, and simple enough for your team to understand.</p> <p>The tools and configurations shown here are one way of achieving this. Your way might be different, and that's perfectly fine. The important thing is to have a way, document it, automate it, and stick to it.</p>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/08/08/keeping-your-python-codebase-tidy---linters-type-checkers-and-workspace-harmony/#references","title":"References","text":"<ul> <li>Clean-Py Repository - Complete tool configuration</li> <li>Pylint Documentation - Advanced Python linter</li> <li>Pyright Documentation - Static type checker</li> <li>EditorConfig - Cross-editor configuration</li> </ul>","tags":["code-quality","linters","type-checkers","python","clean-py"]},{"location":"blog/2025/06/18/building-maintainable-infrastructure---how-to-organize-your-terraform-projects/","title":"Building Maintainable Infrastructure: How to Organize Your Terraform Projects","text":"<p>\ud83d\udd17 GitHub Repository: Find the complete sample project at tf-tutorial \ud83d\udcc1</p> <p>When I first started working with Terraform, my configuration files were essentially one massive main.tf file that contained everything\u2014resources, variables, outputs, all jumbled together. It worked, but as the infrastructure grew, making changes became increasingly risky. A simple update could have unintended consequences elsewhere, and collaborating with teammates was a constant source of merge conflicts.</p> <p>After several painful refactoring sessions and learning from the community's collective wisdom, I've developed an appreciation for well-structured Terraform projects. Let me share what I've learned about organizing Terraform code in a way that scales with your team and infrastructure needs, using our sample-tf-project as a practical example.</p>","tags":["terraform","iac","project-organization","tf-tutorial","infrastructure"]},{"location":"blog/2025/06/18/building-maintainable-infrastructure---how-to-organize-your-terraform-projects/#start-with-clear-directory-structure","title":"Start with Clear Directory Structure","text":"<p>The foundation of any maintainable Terraform project is its directory structure. Think of it like organizing a kitchen\u2014you wouldn't store your plates with your cleaning supplies. Similarly, different aspects of your infrastructure code deserve their own dedicated spaces.</p> <p>Our sample-tf-project demonstrates this principle beautifully with its clear separation of concerns:</p> <pre><code>sample-tf-project/\n\u251c\u2500\u2500 infrastructure/\n\u2502   \u251c\u2500\u2500 environments/\n\u2502   \u2502   \u2514\u2500\u2500 dev/\n\u2502   \u2502       \u251c\u2500\u2500 main.tf           # Environment-specific configuration\n\u2502   \u2502       \u251c\u2500\u2500 variables.tf      # Environment variables\n\u2502   \u2502       \u2514\u2500\u2500 outputs.tf        # Environment outputs\n\u2502   \u2514\u2500\u2500 modules/\n\u2502       \u251c\u2500\u2500 lambda/\n\u2502       \u2502   \u251c\u2500\u2500 main.tf           # Lambda module\n\u2502       \u2502   \u251c\u2500\u2500 variables.tf      # Lambda variables\n\u2502       \u2502   \u2514\u2500\u2500 outputs.tf        # Lambda outputs\n\u2502       \u2514\u2500\u2500 s3/\n\u2502           \u251c\u2500\u2500 main.tf           # S3 module\n\u2502           \u251c\u2500\u2500 variables.tf      # S3 variables\n\u2502           \u2514\u2500\u2500 outputs.tf        # S3 outputs\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 lambda/\n\u2502       \u251c\u2500\u2500 timestamp_function.py # Python Lambda function code\n\u2502       \u2514\u2500\u2500 requirements.txt      # Python dependencies\n\u2514\u2500\u2500 scripts/\n    \u251c\u2500\u2500 deploy.sh                 # Deployment script\n    \u2514\u2500\u2500 test-lambda.sh           # Testing script\n</code></pre> <p>This separation isn't just about being tidy. When your Lambda function code lives in a dedicated <code>src/lambda/</code> directory rather than being embedded in Terraform files, developers can work on application logic without navigating infrastructure complexity. The Python developers on your team can focus on <code>timestamp_function.py</code> without worrying about Terraform syntax. Similarly, having environment-specific directories like <code>environments/dev/</code> means you can safely experiment in development without accidentally affecting production configurations.</p>","tags":["terraform","iac","project-organization","tf-tutorial","infrastructure"]},{"location":"blog/2025/06/18/building-maintainable-infrastructure---how-to-organize-your-terraform-projects/#embrace-modular-design","title":"Embrace Modular Design","text":"<p>Creating reusable modules is where Terraform really shines. Instead of copying and pasting resource definitions across environments, modules let you define infrastructure patterns once and reuse them with different parameters. Think of modules as functions in programming\u2014they accept inputs (variables), perform operations (create resources), and return outputs.</p> <p>Look at how the sample-tf-project's main.tf file in the dev environment elegantly consumes modules:</p> <pre><code># infrastructure/environments/dev/main.tf\n\n# Create S3 bucket module\nmodule \"s3_bucket\" {\n  source = \"../../modules/s3\"\n\n  bucket_name = var.bucket_name\n  environment = var.environment\n}\n\n# Create Lambda function module\nmodule \"lambda_function\" {\n  source = \"../../modules/lambda\"\n\n  function_name        = var.lambda_function_name\n  bucket_name          = module.s3_bucket.bucket_name\n  bucket_arn           = module.s3_bucket.bucket_arn\n  environment          = var.environment\n  lambda_source_path   = var.lambda_source_path\n  lambda_role_name     = var.lambda_role_name\n}\n</code></pre> <p>Notice how clean this is? The environment configuration doesn't worry about S3 encryption settings or Lambda runtime configurations. Those details are abstracted into the modules. The S3 module in our project encapsulates security best practices automatically:</p> <pre><code># infrastructure/modules/s3/main.tf\n\nresource \"aws_s3_bucket\" \"timestamp_bucket\" {\n  bucket = \"${var.bucket_name}-${var.environment}\"\n}\n\n# Block public access to the S3 bucket\nresource \"aws_s3_bucket_public_access_block\" \"timestamp_bucket_pab\" {\n  bucket = aws_s3_bucket.timestamp_bucket.id\n\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\n# Add server-side encryption\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"timestamp_bucket_encryption\" {\n  bucket = aws_s3_bucket.timestamp_bucket.id\n\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm = \"AES256\"\n    }\n  }\n}\n</code></pre> <p>Your S3 module becomes a contract that ensures every S3 bucket in your infrastructure follows the same security and operational standards. When AWS releases new features or your security team updates requirements, you update the module once, and all environments benefit.</p> <p>The Lambda module similarly encapsulates complexity while exposing just the right parameters:</p> <pre><code># infrastructure/modules/lambda/main.tf\n\nresource \"aws_lambda_function\" \"timestamp_lambda\" {\n  filename         = data.archive_file.lambda_zip.output_path\n  function_name    = \"${var.function_name}-${var.environment}\"\n  role            = data.aws_iam_role.lambda_role.arn\n  handler         = \"timestamp_function.lambda_handler\"\n  source_code_hash = data.archive_file.lambda_zip.output_base64sha256\n  runtime         = var.runtime\n  timeout         = var.timeout\n\n  environment {\n    variables = {\n      BUCKET_NAME = var.bucket_name\n      ENVIRONMENT = var.environment\n    }\n  }\n}\n</code></pre> <p>The key is finding the right level of abstraction. Our modules are focused enough to be understandable but flexible enough to handle variations between use cases. The Lambda module accepts parameters for function name and timeout, but it enforces naming conventions (appending the environment) and standard configurations.</p>","tags":["terraform","iac","project-organization","tf-tutorial","infrastructure"]},{"location":"blog/2025/06/18/building-maintainable-infrastructure---how-to-organize-your-terraform-projects/#environment-management-done-right","title":"Environment Management Done Right","text":"<p>Each environment should be self-contained with its own state file and variable definitions. This isolation is crucial for safety and sanity. When you run terraform apply in your development environment, you want absolute confidence that production remains untouched.</p> <p>The sample-tf-project demonstrates this with its environment structure. Each environment gets its own directory under <code>infrastructure/environments/</code>, and you can customize behavior through terraform.tfvars files:</p> <pre><code># infrastructure/environments/dev/terraform.tfvars\naws_region = \"us-west-2\"\nbucket_name = \"my-unique-timestamp-bucket\"\nlambda_function_name = \"timestamp-creator\"\nenvironment = \"dev\"\nlambda_role_name = \"TerraformLambdaRole\"\n</code></pre> <p>This approach makes it obvious what differs between environments and prevents accidental production changes. To extend this to multiple environments, you simply copy the dev directory structure:</p> <pre><code># Create staging and production environments\ncp -r infrastructure/environments/dev infrastructure/environments/staging\ncp -r infrastructure/environments/dev infrastructure/environments/prod\n\n# Then customize each environment's terraform.tfvars\n</code></pre> <p>The beauty is that each environment maintains its own Terraform state, completely isolated from others. A junior developer experimenting in dev can't accidentally destroy production resources.</p>","tags":["terraform","iac","project-organization","tf-tutorial","infrastructure"]},{"location":"blog/2025/06/18/building-maintainable-infrastructure---how-to-organize-your-terraform-projects/#automate-with-purpose","title":"Automate with Purpose","text":"<p>Scripts aren't just conveniences; they're documentation of your processes. The sample-tf-project includes thoughtfully designed automation scripts that make deployment straightforward:</p> <pre><code># scripts/deploy.sh usage\n./scripts/deploy.sh dev init     # Initialize Terraform\n./scripts/deploy.sh dev plan     # Plan changes\n./scripts/deploy.sh dev apply    # Apply changes\n./scripts/deploy.sh dev destroy  # Tear down resources\n</code></pre> <p>Look at how the deploy script handles environment management:</p> <pre><code>#!/bin/bash\n# Simplified excerpt from scripts/deploy.sh\n\nENVIRONMENT=$1\nCOMMAND=$2\n\n# Navigate to the correct environment directory\ncd \"infrastructure/environments/${ENVIRONMENT}\"\n\n# Execute the Terraform command\ncase $COMMAND in\n  init)\n    terraform init\n    ;;\n  plan)\n    terraform plan\n    ;;\n  apply)\n    terraform apply\n    ;;\n  # ... other commands\nesac\n</code></pre> <p>These scripts handle the navigation between directories, ensure the correct environment is targeted, and provide a consistent interface regardless of which environment you're deploying. The test script goes even further, automating Lambda invocation and S3 verification:</p> <pre><code># scripts/test-lambda.sh automates testing\n./scripts/test-lambda.sh dev\n</code></pre> <p>This investment in automation pays dividends when onboarding new developers or during incident response when every second counts.</p>","tags":["terraform","iac","project-organization","tf-tutorial","infrastructure"]},{"location":"blog/2025/06/18/building-maintainable-infrastructure---how-to-organize-your-terraform-projects/#security-as-a-foundation","title":"Security as a Foundation","text":"<p>Security shouldn't be an afterthought bolted onto your infrastructure. The sample-tf-project demonstrates this principle by building security into the module designs. Look at how the S3 module automatically implements multiple layers of security:</p> <pre><code># Versioning for data protection\nresource \"aws_s3_bucket_versioning\" \"timestamp_bucket_versioning\" {\n  bucket = aws_s3_bucket.timestamp_bucket.id\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\n# Lifecycle rules for cost optimization and compliance\nresource \"aws_s3_bucket_lifecycle_configuration\" \"timestamp_bucket_lifecycle\" {\n  bucket = aws_s3_bucket.timestamp_bucket.id\n\n  rule {\n    id     = \"timestamp_files_lifecycle\"\n    status = \"Enabled\"\n\n    expiration {\n      days = var.file_retention_days\n    }\n\n    noncurrent_version_expiration {\n      noncurrent_days = 7\n    }\n  }\n}\n</code></pre> <p>When security is built into the foundation, developers don't need to be security experts to deploy secure infrastructure. Every S3 bucket created through this module automatically gets encryption, public access blocking, versioning, and lifecycle policies.</p> <p>The project also demonstrates the principle of least privilege with IAM roles. Rather than embedding AWS credentials or creating overly permissive policies, it references a pre-created role with specific permissions:</p> <pre><code># Reference the manually created IAM role\ndata \"aws_iam_role\" \"lambda_role\" {\n  name = var.lambda_role_name\n}\n</code></pre> <p>This approach extends beyond individual resources. The modules interact securely, with the Lambda module receiving the S3 bucket ARN from the S3 module output, ensuring proper resource dependencies and access patterns.</p>","tags":["terraform","iac","project-organization","tf-tutorial","infrastructure"]},{"location":"blog/2025/06/18/building-maintainable-infrastructure---how-to-organize-your-terraform-projects/#real-world-application","title":"Real-World Application","text":"<p>The sample-tf-project isn't just a toy example\u2014it demonstrates patterns that scale to production workloads. The project creates a Lambda function that generates timestamp files and stores them in S3, but the patterns it establishes work for any AWS infrastructure:</p> <ul> <li>Modular design that promotes reuse across projects</li> <li>Environment isolation that prevents costly mistakes</li> <li>Automated deployment that reduces human error</li> <li>Built-in security that meets compliance requirements</li> <li>Clear documentation that onboards new team members quickly</li> </ul> <p>\ud83d\udd17 GitHub Repository: You can find the complete implementation at [YOUR_GITHUB_REPO_URL_HERE] \ud83d\udcc1</p> <p>The repository includes additional features like CloudFormation templates for IAM role creation, comprehensive testing scripts, and detailed documentation for getting started.</p>","tags":["terraform","iac","project-organization","tf-tutorial","infrastructure"]},{"location":"blog/2025/06/18/building-maintainable-infrastructure---how-to-organize-your-terraform-projects/#extending-the-structure","title":"Extending the Structure","text":"<p>Once you've mastered the basic structure demonstrated in sample-tf-project, you can extend it for more complex scenarios:</p>","tags":["terraform","iac","project-organization","tf-tutorial","infrastructure"]},{"location":"blog/2025/06/18/building-maintainable-infrastructure---how-to-organize-your-terraform-projects/#remote-state-management","title":"Remote State Management","text":"<p>Add backend configuration for storing Terraform state in S3:</p> <pre><code># infrastructure/environments/dev/backend.tf\nterraform {\n  backend \"s3\" {\n    bucket = \"terraform-state-bucket\"\n    key    = \"dev/terraform.tfstate\"\n    region = \"us-west-2\"\n  }\n}\n</code></pre>","tags":["terraform","iac","project-organization","tf-tutorial","infrastructure"]},{"location":"blog/2025/06/18/building-maintainable-infrastructure---how-to-organize-your-terraform-projects/#multi-region-deployments","title":"Multi-Region Deployments","text":"<p>Extend the module structure to support regional variations:</p> <pre><code>infrastructure/\n\u251c\u2500\u2500 environments/\n\u2502   \u2514\u2500\u2500 dev/\n\u2502       \u251c\u2500\u2500 us-west-2/\n\u2502       \u2514\u2500\u2500 eu-west-1/\n</code></pre>","tags":["terraform","iac","project-organization","tf-tutorial","infrastructure"]},{"location":"blog/2025/06/18/building-maintainable-infrastructure---how-to-organize-your-terraform-projects/#shared-resources","title":"Shared Resources","text":"<p>Add a global directory for resources that span environments:</p> <pre><code>infrastructure/\n\u251c\u2500\u2500 global/\n\u2502   \u251c\u2500\u2500 iam/\n\u2502   \u2514\u2500\u2500 route53/\n\u251c\u2500\u2500 environments/\n\u2514\u2500\u2500 modules/\n</code></pre>","tags":["terraform","iac","project-organization","tf-tutorial","infrastructure"]},{"location":"blog/2025/06/18/building-maintainable-infrastructure---how-to-organize-your-terraform-projects/#looking-forward","title":"Looking Forward","text":"<p>The sample-tf-project provides a solid foundation for organizing Terraform projects, but remember that the best structure is one that evolves with your needs. Start with the patterns demonstrated in the project:</p> <ol> <li>Separate infrastructure, modules, and application code</li> <li>Create reusable modules with sensible defaults</li> <li>Isolate environments completely</li> <li>Automate common workflows</li> <li>Build security into every component</li> </ol> <p>As your infrastructure grows, you'll discover new patterns and optimizations. Perhaps you'll add a module registry, implement policy as code with Sentinel or Open Policy Agent, or integrate with a CI/CD pipeline for automated deployments.</p> <p>The key is to start with a solid foundation like the one demonstrated in sample-tf-project, then iterate based on your team's needs. Every improvement you make compounds over time, turning infrastructure management from a source of stress into a well-oiled machine.</p> <p>Remember, organizing Terraform projects well isn't about following rules blindly\u2014it's about creating a structure that makes your team more productive, your infrastructure more reliable, and your applications more secure. The sample-tf-project shows you how to achieve all three goals with a clean, maintainable structure that scales from proof-of-concept to production.</p>","tags":["terraform","iac","project-organization","tf-tutorial","infrastructure"]},{"location":"blog/2025/05/29/dont-let-your-terraform-state-file-ruin-your-day---a-hard-learned-lesson/","title":"Don't Let Your Terraform State File Ruin Your Day: A Hard-Learned Lesson","text":"<p>\ud83d\udd17 GitHub Repository: Find the complete sample project at tf-tutorial \ud83d\udcc1</p> <p>If you've been working with Terraform for any length of time, you've probably experienced that sinking feeling when your state file gets corrupted. I know I have\u2014multiple times, actually. There's nothing quite like running <code>terraform plan</code> and seeing it want to recreate your entire production infrastructure because the state file is out of sync. Trust me, you don't want to be that person explaining to your team why all the servers just disappeared.</p>","tags":["terraform","state-management","tf-tutorial","infrastructure","devops"]},{"location":"blog/2025/05/29/dont-let-your-terraform-state-file-ruin-your-day---a-hard-learned-lesson/#the-state-file-your-infrastructures-memory","title":"The State File: Your Infrastructure's Memory","text":"<p>Terraform's state file is essentially your infrastructure's memory. It tracks what resources exist, their current configuration, and how they map to your configuration files. When this file gets corrupted, lost, or out of sync, Terraform loses its ability to manage your infrastructure properly. The result? Chaos.</p> <p>During my early days learning Terraform, state file corruption got me more times than I care to admit. I'd make a simple change, run <code>terraform apply</code>, and suddenly Terraform would think resources that had been running for weeks didn't exist. Sometimes I'd end up with duplicate resources, orphaned infrastructure, or worse\u2014completely broken deployments that required manual cleanup.</p>","tags":["terraform","state-management","tf-tutorial","infrastructure","devops"]},{"location":"blog/2025/05/29/dont-let-your-terraform-state-file-ruin-your-day---a-hard-learned-lesson/#why-cdk-and-cloudformation-might-be-better-for-learning","title":"Why CDK and CloudFormation Might Be Better for Learning","text":"<p>For beginners or quick experiments, AWS CDK and CloudFormation actually offer some significant advantages over Terraform:</p> <ul> <li>Built-in state management: CloudFormation handles state automatically through AWS APIs</li> <li>Easy cleanup: Deleting a CloudFormation stack removes all associated resources</li> <li>Rollback capabilities: Failed deployments automatically roll back to the previous state</li> <li>Integrated monitoring: Native AWS integration provides better visibility into deployment status</li> </ul> <p>These tools eliminate the state management complexity that trips up many Terraform newcomers. You can focus on learning infrastructure concepts without worrying about state file corruption.</p>","tags":["terraform","state-management","tf-tutorial","infrastructure","devops"]},{"location":"blog/2025/05/29/dont-let-your-terraform-state-file-ruin-your-day---a-hard-learned-lesson/#why-terraform-still-rules-for-enterprise","title":"Why Terraform Still Rules for Enterprise","text":"<p>Despite the learning curve, Terraform remains the gold standard for enterprise infrastructure management:</p> <ul> <li>Multi-cloud support: Manage AWS, Azure, GCP, and other providers with one tool</li> <li>Rich ecosystem: Extensive provider library covering virtually every service</li> <li>Mature tooling: Better testing, validation, and CI/CD integration</li> <li>Modularity: Create reusable, shareable infrastructure components</li> <li>State management flexibility: Once mastered, provides powerful deployment strategies</li> </ul>","tags":["terraform","state-management","tf-tutorial","infrastructure","devops"]},{"location":"blog/2025/05/29/dont-let-your-terraform-state-file-ruin-your-day---a-hard-learned-lesson/#getting-state-management-right-the-sample-tf-state-lock-project","title":"Getting State Management Right: The <code>sample-tf-state-lock</code> Project","text":"<p>The key to avoiding state file disasters is implementing proper remote state management with locking from day one. While there are many approaches to Terraform state management\u2014including enterprise solutions like Terraform Cloud, Terraform Enterprise, Azure DevOps, GitLab CI/CD with remote backends, and HashiCorp Consul\u2014the S3-DynamoDB combination remains one of the most accessible options for learning and experimentation.</p> <p>This approach is particularly well-suited for Cloud Guru environments and provides a solid foundation for understanding state management concepts without requiring enterprise tooling or complex setup. Our <code>sample-tf-state-lock</code> project demonstrates this with a clean, production-ready structure:</p> <pre><code>sample-tf-state-lock/\n\u251c\u2500\u2500 infrastructure/\n\u2502   \u251c\u2500\u2500 environments/\n\u2502   \u2502   \u2514\u2500\u2500 dev/\n\u2502   \u2502       \u251c\u2500\u2500 main.tf           # S3 backend configuration\n\u2502   \u2502       \u251c\u2500\u2500 variables.tf      \n\u2502   \u2502       \u2514\u2500\u2500 outputs.tf        \n\u2502   \u2514\u2500\u2500 modules/\n\u2502       \u251c\u2500\u2500 lambda/\n\u2502       \u2514\u2500\u2500 s3/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 lambda/\n\u2514\u2500\u2500 scripts/\n</code></pre> <p>The magic happens in the backend configuration in <code>infrastructure/environments/dev/main.tf</code>:</p> <pre><code>backend \"s3\" {\n  bucket         = \"cloudguru-terraform-state-767398100921\"\n  key            = \"sample-tf-state-lock/dev/terraform.tfstate\"\n  encrypt        = false\n  dynamodb_table = \"cloudguru-terraform-state-767398100921-lock\"\n  region         = \"us-east-1\"\n}\n</code></pre> <p>This setup provides:</p> <ol> <li>Remote storage: State files stored in S3, not locally</li> <li>State locking: DynamoDB prevents concurrent modifications</li> <li>Environment isolation: Separate state files for dev/staging/prod</li> <li>Team collaboration: Multiple developers can work safely</li> </ol>","tags":["terraform","state-management","tf-tutorial","infrastructure","devops"]},{"location":"blog/2025/05/29/dont-let-your-terraform-state-file-ruin-your-day---a-hard-learned-lesson/#the-three-pillars-of-state-management","title":"The Three Pillars of State Management","text":"<p>Based on painful experience, here are the non-negotiables for Terraform state management:</p> <p>1. Remote State Storage: Never store state files locally or in version control. Use S3, Azure Storage, or similar cloud storage with versioning enabled.</p> <p>2. State Locking: Always configure state locking (DynamoDB for S3 backend) to prevent multiple users from modifying infrastructure simultaneously.</p> <p>3. Environment Separation: Use separate state files for different environments. The last thing you want is a dev deployment accidentally affecting production.</p> <p>The <code>sample-tf-state-lock</code> project implements all three pillars, creating a foundation that scales from small experiments to enterprise deployments.</p>","tags":["terraform","state-management","tf-tutorial","infrastructure","devops"]},{"location":"blog/2025/05/29/dont-let-your-terraform-state-file-ruin-your-day---a-hard-learned-lesson/#making-it-foolproof","title":"Making It Foolproof","text":"<p>The project includes deployment scripts that make state management transparent:</p> <pre><code>./scripts/deploy.sh dev init\n./scripts/deploy.sh dev apply\n</code></pre> <p>These scripts handle the complexity while ensuring proper state management practices. The modular structure means you can extend the pattern to new environments and projects without reinventing the wheel.</p>","tags":["terraform","state-management","tf-tutorial","infrastructure","devops"]},{"location":"blog/2025/05/29/dont-let-your-terraform-state-file-ruin-your-day---a-hard-learned-lesson/#dont-learn-the-hard-way","title":"Don't Learn the Hard Way","text":"<p>State file corruption will teach you about Terraform state management, but it's a lesson you'd rather avoid. By starting with proper remote state configuration and locking, you can focus on building infrastructure instead of recovering from disasters.</p> <p>\ud83d\udd17 GitHub Repository: The complete example is available at tf-tutorial \ud83d\udcc1</p> <p>Use it as a foundation for your own projects, and save yourself the headaches I experienced learning Terraform the hard way.</p> <p>Remember: your future self will thank you for setting up proper state management from the beginning. Trust me on this one.</p>","tags":["terraform","state-management","tf-tutorial","infrastructure","devops"]},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/code-quality/","title":"Code Quality","text":""},{"location":"blog/category/python/","title":"Python","text":""},{"location":"blog/category/development-tools/","title":"Development Tools","text":""},{"location":"blog/category/architecture-evolution/","title":"Architecture Evolution","text":""},{"location":"blog/category/software-design/","title":"Software Design","text":""},{"location":"blog/category/architecture/","title":"Architecture","text":""},{"location":"blog/category/aws/","title":"AWS","text":""},{"location":"blog/category/cost-optimization/","title":"Cost Optimization","text":""},{"location":"blog/category/deployment/","title":"Deployment","text":""},{"location":"blog/category/fastapi/","title":"FastAPI","text":""},{"location":"blog/category/clean-architecture/","title":"Clean Architecture","text":""},{"location":"blog/category/api-design/","title":"API Design","text":""},{"location":"blog/category/authentication/","title":"Authentication","text":""},{"location":"blog/category/security/","title":"Security","text":""},{"location":"blog/category/logging/","title":"Logging","text":""},{"location":"blog/category/observability/","title":"Observability","text":""},{"location":"blog/category/devops/","title":"DevOps","text":""},{"location":"blog/category/testing/","title":"Testing","text":""},{"location":"blog/category/microservices/","title":"Microservices","text":""},{"location":"blog/category/type-safety/","title":"Type Safety","text":""},{"location":"blog/category/infrastructure-as-code/","title":"Infrastructure as Code","text":""},{"location":"blog/category/terraform/","title":"Terraform","text":""},{"location":"blog/category/design-patterns/","title":"Design Patterns","text":""},{"location":"blog/category/domain-driven-design/","title":"Domain-Driven Design","text":""},{"location":"blog/category/software-architecture/","title":"Software Architecture","text":""},{"location":"blog/category/project-setup/","title":"Project Setup","text":""},{"location":"blog/category/development-workflow/","title":"Development Workflow","text":""},{"location":"blog/category/announcements/","title":"Announcements","text":""},{"location":"blog/category/serverless/","title":"Serverless","text":""},{"location":"blog/page/2/","title":"buildshift.dev Blog","text":""},{"location":"blog/archive/2025/page/2/","title":"2025","text":""},{"location":"blog/category/python/page/2/","title":"Python","text":""}]}